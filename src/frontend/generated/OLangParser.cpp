
// Generated from /home/scott/Projects/olang/grammar/OLangParser.g4 by ANTLR 4.11.1


#include <mutex>
#include "OLangParserListener.h"
#include <mutex>
#include "OLangParserVisitor.h"

#include <mutex>
#include "OLangParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct OLangParserStaticData final {
  OLangParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  OLangParserStaticData(const OLangParserStaticData&) = delete;
  OLangParserStaticData(OLangParserStaticData&&) = delete;
  OLangParserStaticData& operator=(const OLangParserStaticData&) = delete;
  OLangParserStaticData& operator=(OLangParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

std::once_flag olangparserParserOnceFlag;
OLangParserStaticData *olangparserParserStaticData = nullptr;

void olangparserParserInitialize() {
  assert(olangparserParserStaticData == nullptr);
  auto staticData = std::make_unique<OLangParserStaticData>(
    std::vector<std::string>{
      "program", "statementList", "statement", "expressionStatement", "emitStatement", 
      "signalStatement", "assertStatement", "declaration", "agentDeclaration", 
      "agentMember", "solverDeclaration", "solverMember", "proofDeclaration", 
      "invariantDeclaration", "importDeclaration", "dottedAsNamesList", 
      "dottedAsNames", "relativeModule", "importTargets", "importAsNames", 
      "bindingDeclaration", "functionDeclaration", "pipelineDeclaration", 
      "typeDeclaration", "annotationTypeDeclaration", "annotationStatement", 
      "expression", "pipelineExpression", "pipelineBody", "nullCoalesceExpression", 
      "ternaryExpression", "logicalOrExpression", "logicalAndExpression", 
      "equalityExpression", "relationalExpression", "additiveExpression", 
      "multiplicativeExpression", "unaryExpression", "errorPropagationExpression", 
      "postfixExpression", "callSuffix", "callArguments", "primaryExpression", 
      "type", "optionalType", "baseType", "primitiveType", "userDefinedType", 
      "pipelineType", "listType", "mapType", "setType", "streamType", "futureType", 
      "resultType", "optionType", "provenanceType", "functionType", "parenthesisType", 
      "genericArguments", "typeList", "genericParameters", "genericParameterList", 
      "genericParameter", "genericParameterConstraint", "whereClause", "constraintList", 
      "constraint", "typedField", "typedFieldList", "typedParameter", "typedParameterList", 
      "functionalExpression", "mapExpression", "filterExpression", "reduceExpression", 
      "foreachExpression", "groupByExpression", "flatMapExpression", "zipExpression", 
      "partitionExpression", "takeExpression", "dropExpression", "takeWhileExpression", 
      "dropWhileExpression", "sortByExpression", "distinctExpression", "countExpression", 
      "findExpression", "anyExpression", "allExpression", "joinExpression", 
      "joinClause", "windowExpression", "chunkExpression", "scanExpression", 
      "collectExpression", "lambdaExpression", "multipleParameterLambda", 
      "parameterList", "parameter", "simplePatternLambda", "simpleDestructure", 
      "simpleLambda", "simplePatternList", "simplePatternFieldList", "simplePatternElement", 
      "simplePatternField", "blockExpression", "transformationList", "transformation", 
      "matchExpression", "matchArm", "matchArmList", "pattern", "orPattern", 
      "andPattern", "primaryPattern", "wildcardPattern", "literalPattern", 
      "identifierPattern", "destructurePattern", "objectDestructure", "listDestructure", 
      "tupleDestructure", "namedDestructure", "rangePattern", "simpleRangeValue", 
      "typePattern", "simplePattern", "guardPattern", "simpleCondition", 
      "parenthesisPattern", "patternField", "patternFieldList", "patternList", 
      "mutationExpression", "mutationSite", "mutationChange", "rangeExpression", 
      "listExpression", "objectExpression", "objectField", "objectFieldList", 
      "assignmentStatement", "annotationPairList", "annotationPair", "annotationValue", 
      "listLiteral", "annotationValueList", "qualifiedName", "literalValue", 
      "expressionList", "idList", "argument", "lambdaArgumentRule", "argumentList"
    },
    std::vector<std::string>{
      "", "'import'", "'from'", "'let'", "'as'", "'with'", "'type'", "'extends'", 
      "'annotation'", "'annotated'", "'def'", "'match'", "'when'", "'where'", 
      "'in'", "'agent'", "'capability'", "'PHYSICAL'", "'VIRTUAL'", "'ATOMIC'", 
      "'proof'", "'invariant'", "'assert'", "'always'", "'eventually'", 
      "'during'", "'until'", "'solver'", "'satisfy'", "'minimize'", "'maximize'", 
      "'variable'", "'stream'", "'rule'", "'emit'", "'signal'", "'within'", 
      "'map'", "'filter'", "'reduce'", "'foreach'", "'group_by'", "'flatmap'", 
      "'zip'", "'partition'", "'take'", "'drop'", "'take_while'", "'drop_while'", 
      "'sort_by'", "'distinct'", "'count'", "'find'", "'any'", "'all'", 
      "'join'", "'on'", "'window'", "'chunk'", "'scan'", "'collect'", "'int'", 
      "'long'", "'float'", "'double'", "'bool'", "'char'", "'string'", "'any_type'", 
      "'never_type'", "'null'", "'List'", "'Map'", "'Set'", "'Pipeline'", 
      "'Stream'", "'Future'", "'Result'", "'Option'", "'Provenance'", "'+'", 
      "'-'", "'*'", "'/'", "'%'", "'=='", "'!='", "'<='", "'<'", "'>='", 
      "'>'", "'&&'", "'||'", "'!'", "'and'", "'or'", "", "'|||'", "'=>'", 
      "'->'", "'|'", "'\\u003F\\u003F'", "'@'", "", "'..'", "'..='", "'..<'", 
      "'^'", "'$'", "'~'", "'_'", "", "", "", "", "", "", "'('", "')'", 
      "'['", "']'", "'{'", "'}'", "'.'", "','", "':'", "';'", "'='"
    },
    std::vector<std::string>{
      "", "IMPORT", "FROM", "LET", "AS", "WITH", "TYPE", "EXTENDS", "ANNOTATION", 
      "ANNOTATED", "DEF", "MATCH", "WHEN", "WHERE", "IN", "AGENT", "CAPABILITY", 
      "PHYSICAL", "VIRTUAL", "ATOMIC", "PROOF", "INVARIANT", "ASSERT", "ALWAYS", 
      "EVENTUALLY", "DURING", "UNTIL", "SOLVER", "SATISFY", "MINIMIZE", 
      "MAXIMIZE", "VARIABLE", "STREAM", "RULE", "EMIT", "SIGNAL", "WITHIN", 
      "MAP", "FILTER", "REDUCE", "FOREACH", "GROUP_BY", "FLATMAP", "ZIP", 
      "PARTITION", "TAKE", "DROP", "TAKE_WHILE", "DROP_WHILE", "SORT_BY", 
      "DISTINCT", "COUNT", "FIND", "ANY", "ALL", "JOIN", "ON", "WINDOW", 
      "CHUNK", "SCAN", "COLLECT", "INT_TYPE", "LONG_TYPE", "FLOAT_TYPE", 
      "DOUBLE_TYPE", "BOOL_TYPE", "CHAR_TYPE", "STRING_TYPE", "ANY_TYPE", 
      "NEVER_TYPE", "NULL_LIT", "LIST_TYPE", "MAP_TYPE", "SET_TYPE", "PIPELINE_TYPE", 
      "STREAM_TYPE", "FUTURE_TYPE", "RESULT_TYPE", "OPTION_TYPE", "PROVENANCE_TYPE", 
      "ADD", "SUB", "MUL", "DIV", "MOD", "EQ", "NEQ", "LE", "LT", "GE", 
      "GT", "AND_OP", "OR_OP", "NOT", "AND", "OR", "PIPELINE_OP", "PARALLEL_OP", 
      "LAMBDA_ARROW", "ARROW", "UNION_PIPE", "NULL_COALESCE", "MUTATE_AT", 
      "BIO_TRANSFORM", "RANGE_OP", "INCLUSIVE_RANGE", "EXCLUSIVE_RANGE", 
      "POSITION_START", "POSITION_END", "COMPLEMENT", "WILDCARD", "BOOLEAN", 
      "INT_LITERAL", "DECIMAL_LITERAL", "STRING", "RAW_STRING", "MULTILINE_STRING", 
      "LPAREN", "RPAREN", "LBRACK", "RBRACK", "LCURLY", "RCURLY", "DOT", 
      "COMMA", "COLON", "SEMI", "EQUALS", "ID", "COMMENT", "BLOCK_COMMENT", 
      "WS", "OPTIONAL"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,132,1544,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,
  	7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,7,120,2,121,7,121,2,122,
  	7,122,2,123,7,123,2,124,7,124,2,125,7,125,2,126,7,126,2,127,7,127,2,128,
  	7,128,2,129,7,129,2,130,7,130,2,131,7,131,2,132,7,132,2,133,7,133,2,134,
  	7,134,2,135,7,135,2,136,7,136,2,137,7,137,2,138,7,138,2,139,7,139,2,140,
  	7,140,2,141,7,141,2,142,7,142,2,143,7,143,2,144,7,144,2,145,7,145,2,146,
  	7,146,2,147,7,147,2,148,7,148,2,149,7,149,2,150,7,150,2,151,7,151,2,152,
  	7,152,2,153,7,153,2,154,7,154,2,155,7,155,2,156,7,156,1,0,1,0,1,0,1,1,
  	1,1,3,1,320,8,1,1,1,5,1,323,8,1,10,1,12,1,326,9,1,1,1,3,1,329,8,1,1,2,
  	1,2,1,2,1,2,1,2,1,2,1,2,3,2,338,8,2,1,3,1,3,1,3,1,4,1,4,1,4,1,4,1,5,1,
  	5,1,5,1,5,1,6,1,6,1,6,1,6,1,6,1,6,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,
  	3,7,366,8,7,1,8,1,8,1,8,1,8,5,8,372,8,8,10,8,12,8,375,9,8,1,8,1,8,1,9,
  	1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,
  	9,1,9,3,9,399,8,9,1,10,1,10,1,10,1,10,5,10,405,8,10,10,10,12,10,408,9,
  	10,1,10,1,10,1,11,1,11,1,11,1,11,1,11,1,11,3,11,418,8,11,1,11,1,11,1,
  	11,1,11,1,11,5,11,425,8,11,10,11,12,11,428,9,11,1,11,1,11,1,11,1,11,1,
  	11,3,11,435,8,11,1,12,1,12,1,12,1,12,5,12,441,8,12,10,12,12,12,444,9,
  	12,1,12,1,12,1,13,1,13,1,13,1,13,5,13,452,8,13,10,13,12,13,455,9,13,1,
  	13,1,13,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,3,14,469,8,
  	14,1,15,1,15,1,15,5,15,474,8,15,10,15,12,15,477,9,15,1,16,1,16,1,16,3,
  	16,482,8,16,1,17,1,17,1,18,1,18,1,18,5,18,489,8,18,10,18,12,18,492,9,
  	18,1,18,3,18,495,8,18,1,19,1,19,1,19,3,19,500,8,19,1,20,1,20,1,20,1,20,
  	3,20,506,8,20,1,20,1,20,1,20,1,21,1,21,1,21,1,21,3,21,515,8,21,1,21,1,
  	21,1,21,1,21,1,21,1,21,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,
  	22,1,22,1,23,1,23,1,23,3,23,537,8,23,1,23,1,23,1,23,1,23,3,23,543,8,23,
  	1,24,1,24,1,24,1,24,1,24,1,24,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,26,
  	1,26,1,26,3,26,561,8,26,1,27,1,27,1,27,5,27,566,8,27,10,27,12,27,569,
  	9,27,1,28,1,28,1,28,5,28,574,8,28,10,28,12,28,577,9,28,1,29,1,29,1,29,
  	5,29,582,8,29,10,29,12,29,585,9,29,1,30,1,30,1,30,1,30,1,30,1,30,3,30,
  	593,8,30,1,31,1,31,1,31,5,31,598,8,31,10,31,12,31,601,9,31,1,32,1,32,
  	1,32,5,32,606,8,32,10,32,12,32,609,9,32,1,33,1,33,1,33,5,33,614,8,33,
  	10,33,12,33,617,9,33,1,34,1,34,1,34,5,34,622,8,34,10,34,12,34,625,9,34,
  	1,35,1,35,1,35,5,35,630,8,35,10,35,12,35,633,9,35,1,36,1,36,1,36,5,36,
  	638,8,36,10,36,12,36,641,9,36,1,37,1,37,1,37,3,37,646,8,37,1,38,1,38,
  	3,38,650,8,38,1,39,1,39,5,39,654,8,39,10,39,12,39,657,9,39,1,40,1,40,
  	1,40,1,40,3,40,663,8,40,1,40,1,40,1,40,1,40,3,40,669,8,40,1,41,1,41,3,
  	41,673,8,41,1,41,1,41,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,
  	42,3,42,687,8,42,1,43,1,43,1,43,5,43,692,8,43,10,43,12,43,695,9,43,1,
  	44,1,44,3,44,699,8,44,1,45,1,45,1,45,1,45,1,45,1,45,1,45,1,45,1,45,1,
  	45,1,45,1,45,1,45,3,45,714,8,45,1,46,1,46,1,47,1,47,3,47,720,8,47,1,48,
  	1,48,1,48,1,48,1,48,1,48,1,48,1,49,1,49,1,49,1,49,1,49,1,50,1,50,1,50,
  	1,50,1,50,1,50,1,50,1,51,1,51,1,51,1,51,1,51,1,52,1,52,1,52,1,52,1,52,
  	1,53,1,53,1,53,1,53,1,53,1,54,1,54,1,54,1,54,1,54,1,54,1,54,1,55,1,55,
  	1,55,1,55,1,55,1,56,1,56,1,56,1,56,1,56,1,57,1,57,3,57,775,8,57,1,57,
  	1,57,1,57,1,57,1,58,1,58,1,58,1,58,1,59,1,59,1,59,1,59,1,60,1,60,1,60,
  	5,60,792,8,60,10,60,12,60,795,9,60,1,61,1,61,1,61,1,61,1,62,1,62,1,62,
  	5,62,804,8,62,10,62,12,62,807,9,62,1,63,1,63,5,63,811,8,63,10,63,12,63,
  	814,9,63,1,64,1,64,1,64,1,64,1,64,1,64,3,64,822,8,64,1,65,1,65,1,65,1,
  	66,1,66,1,66,5,66,830,8,66,10,66,12,66,833,9,66,1,67,1,67,1,67,1,67,1,
  	67,1,67,1,67,1,67,1,67,1,67,3,67,845,8,67,1,68,1,68,1,68,1,68,1,69,1,
  	69,1,69,5,69,854,8,69,10,69,12,69,857,9,69,1,70,1,70,1,70,1,70,1,71,1,
  	71,1,71,5,71,866,8,71,10,71,12,71,869,9,71,1,72,1,72,1,72,1,72,1,72,1,
  	72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,
  	72,1,72,1,72,1,72,3,72,894,8,72,1,73,1,73,1,73,1,73,3,73,900,8,73,1,73,
  	1,73,1,73,1,73,1,74,1,74,1,74,1,74,1,74,1,74,3,74,912,8,74,1,74,1,74,
  	1,75,1,75,1,75,1,75,1,75,1,75,3,75,922,8,75,1,75,1,75,3,75,926,8,75,1,
  	75,1,75,1,76,1,76,1,76,1,76,1,76,1,76,3,76,936,8,76,1,76,1,76,1,77,1,
  	77,1,77,1,77,1,77,1,77,3,77,946,8,77,1,77,1,77,1,78,1,78,1,78,1,78,1,
  	78,1,78,3,78,956,8,78,1,78,1,78,1,79,1,79,1,79,1,79,1,79,1,79,1,79,3,
  	79,967,8,79,1,79,1,79,1,80,1,80,1,80,1,80,1,80,1,80,3,80,977,8,80,1,80,
  	1,80,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,82,1,82,1,82,1,82,1,82,1,82,
  	1,82,1,83,1,83,1,83,1,83,1,83,1,83,3,83,1001,8,83,1,83,1,83,1,84,1,84,
  	1,84,1,84,1,84,1,84,3,84,1011,8,84,1,84,1,84,1,85,1,85,1,85,1,85,1,85,
  	1,85,3,85,1021,8,85,1,85,1,85,1,86,1,86,1,86,1,86,1,86,1,86,3,86,1031,
  	8,86,3,86,1033,8,86,1,86,1,86,1,87,1,87,1,87,1,87,1,87,1,87,3,87,1043,
  	8,87,3,87,1045,8,87,1,87,1,87,1,88,1,88,1,88,1,88,1,88,1,88,3,88,1055,
  	8,88,1,88,1,88,1,89,1,89,1,89,1,89,1,89,1,89,3,89,1065,8,89,1,89,1,89,
  	1,90,1,90,1,90,1,90,1,90,1,90,3,90,1075,8,90,1,90,1,90,1,91,1,91,1,91,
  	1,91,1,91,1,91,1,91,1,91,1,91,3,91,1088,8,91,1,91,1,91,1,92,1,92,1,92,
  	1,92,3,92,1096,8,92,1,93,1,93,1,93,1,93,1,93,1,93,1,93,3,93,1105,8,93,
  	1,93,1,93,1,94,1,94,1,94,1,94,1,94,1,94,1,94,1,95,1,95,1,95,1,95,1,95,
  	1,95,3,95,1122,8,95,1,95,1,95,3,95,1126,8,95,1,95,1,95,1,96,1,96,1,96,
  	1,96,1,96,1,96,3,96,1136,8,96,1,96,1,96,1,96,1,96,1,97,1,97,1,97,3,97,
  	1145,8,97,1,98,1,98,1,98,1,98,1,98,1,98,3,98,1153,8,98,1,99,1,99,1,99,
  	5,99,1158,8,99,10,99,12,99,1161,9,99,1,100,1,100,1,100,3,100,1166,8,100,
  	1,101,1,101,1,101,1,101,3,101,1172,8,101,1,102,1,102,1,102,1,102,1,102,
  	1,102,1,102,1,102,3,102,1182,8,102,1,103,1,103,1,103,1,103,3,103,1188,
  	8,103,1,104,1,104,1,104,5,104,1193,8,104,10,104,12,104,1196,9,104,1,105,
  	1,105,1,105,5,105,1201,8,105,10,105,12,105,1204,9,105,1,106,1,106,1,107,
  	1,107,1,107,1,107,1,107,3,107,1213,8,107,1,108,1,108,1,108,1,108,1,109,
  	1,109,1,109,5,109,1222,8,109,10,109,12,109,1225,9,109,1,109,3,109,1228,
  	8,109,1,110,1,110,1,110,1,110,3,110,1234,8,110,1,110,1,110,1,110,3,110,
  	1239,8,110,1,111,1,111,1,111,1,111,1,111,1,111,1,112,1,112,1,112,1,112,
  	3,112,1251,8,112,1,113,1,113,1,113,5,113,1256,8,113,10,113,12,113,1259,
  	9,113,1,113,3,113,1262,8,113,1,114,1,114,1,115,1,115,1,115,5,115,1269,
  	8,115,10,115,12,115,1272,9,115,1,116,1,116,1,117,1,117,1,117,1,117,1,
  	117,1,117,1,117,1,117,3,117,1284,8,117,1,118,1,118,1,119,1,119,1,120,
  	1,120,1,121,1,121,1,121,1,121,3,121,1296,8,121,1,122,1,122,3,122,1300,
  	8,122,1,122,1,122,1,123,1,123,3,123,1306,8,123,1,123,1,123,1,124,1,124,
  	1,124,1,124,1,125,1,125,1,125,3,125,1317,8,125,1,125,1,125,1,126,1,126,
  	1,126,1,126,1,127,1,127,1,127,3,127,1328,8,127,1,128,1,128,1,128,1,128,
  	1,129,1,129,1,129,1,129,3,129,1338,8,129,1,130,1,130,1,130,1,130,1,131,
  	1,131,1,131,1,131,3,131,1348,8,131,1,132,1,132,1,132,1,132,1,133,1,133,
  	1,133,1,133,1,133,3,133,1359,8,133,1,134,1,134,1,134,5,134,1364,8,134,
  	10,134,12,134,1367,9,134,1,134,3,134,1370,8,134,1,135,1,135,1,135,5,135,
  	1375,8,135,10,135,12,135,1378,9,135,1,135,3,135,1381,8,135,1,136,1,136,
  	1,136,1,136,1,136,1,137,1,137,1,137,1,137,1,137,1,137,3,137,1394,8,137,
  	1,138,1,138,1,138,1,138,1,138,1,138,1,138,3,138,1403,8,138,1,139,1,139,
  	1,139,1,139,1,139,1,139,1,139,1,139,1,139,1,139,1,139,1,139,3,139,1417,
  	8,139,1,140,1,140,3,140,1421,8,140,1,140,1,140,1,141,1,141,3,141,1427,
  	8,141,1,141,1,141,1,142,1,142,1,142,1,142,1,143,1,143,1,143,5,143,1438,
  	8,143,10,143,12,143,1441,9,143,1,143,3,143,1444,8,143,1,144,1,144,1,144,
  	1,144,1,144,1,145,1,145,1,145,5,145,1454,8,145,10,145,12,145,1457,9,145,
  	1,146,1,146,1,146,1,146,1,147,1,147,3,147,1465,8,147,1,148,1,148,3,148,
  	1469,8,148,1,148,1,148,1,149,1,149,1,149,5,149,1476,8,149,10,149,12,149,
  	1479,9,149,1,150,1,150,1,150,5,150,1484,8,150,10,150,12,150,1487,9,150,
  	1,151,1,151,1,152,1,152,1,152,5,152,1494,8,152,10,152,12,152,1497,9,152,
  	1,153,1,153,1,153,5,153,1502,8,153,10,153,12,153,1505,9,153,1,154,1,154,
  	1,154,1,154,1,154,3,154,1512,8,154,1,155,1,155,1,155,1,155,3,155,1518,
  	8,155,1,155,1,155,1,155,1,155,1,155,1,155,3,155,1526,8,155,1,155,1,155,
  	1,155,1,155,3,155,1532,8,155,3,155,1534,8,155,1,156,1,156,1,156,5,156,
  	1539,8,156,10,156,12,156,1542,9,156,1,156,0,0,157,0,2,4,6,8,10,12,14,
  	16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,
  	62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,
  	106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,
  	142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,
  	178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,
  	214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,
  	250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,
  	286,288,290,292,294,296,298,300,302,304,306,308,310,312,0,14,2,0,114,
  	114,128,128,1,0,29,30,1,0,96,97,2,0,92,92,95,95,1,0,85,86,3,0,25,26,36,
  	36,87,90,1,0,80,81,1,0,82,84,3,0,23,24,80,81,93,93,1,0,61,69,2,0,110,
  	110,128,128,1,0,104,105,1,0,85,90,2,0,70,70,111,116,1592,0,314,1,0,0,
  	0,2,317,1,0,0,0,4,337,1,0,0,0,6,339,1,0,0,0,8,342,1,0,0,0,10,346,1,0,
  	0,0,12,350,1,0,0,0,14,365,1,0,0,0,16,367,1,0,0,0,18,398,1,0,0,0,20,400,
  	1,0,0,0,22,434,1,0,0,0,24,436,1,0,0,0,26,447,1,0,0,0,28,468,1,0,0,0,30,
  	470,1,0,0,0,32,478,1,0,0,0,34,483,1,0,0,0,36,494,1,0,0,0,38,496,1,0,0,
  	0,40,501,1,0,0,0,42,510,1,0,0,0,44,522,1,0,0,0,46,533,1,0,0,0,48,544,
  	1,0,0,0,50,550,1,0,0,0,52,560,1,0,0,0,54,562,1,0,0,0,56,570,1,0,0,0,58,
  	578,1,0,0,0,60,586,1,0,0,0,62,594,1,0,0,0,64,602,1,0,0,0,66,610,1,0,0,
  	0,68,618,1,0,0,0,70,626,1,0,0,0,72,634,1,0,0,0,74,645,1,0,0,0,76,647,
  	1,0,0,0,78,651,1,0,0,0,80,668,1,0,0,0,82,670,1,0,0,0,84,686,1,0,0,0,86,
  	688,1,0,0,0,88,696,1,0,0,0,90,713,1,0,0,0,92,715,1,0,0,0,94,717,1,0,0,
  	0,96,721,1,0,0,0,98,728,1,0,0,0,100,733,1,0,0,0,102,740,1,0,0,0,104,745,
  	1,0,0,0,106,750,1,0,0,0,108,755,1,0,0,0,110,762,1,0,0,0,112,767,1,0,0,
  	0,114,772,1,0,0,0,116,780,1,0,0,0,118,784,1,0,0,0,120,788,1,0,0,0,122,
  	796,1,0,0,0,124,800,1,0,0,0,126,808,1,0,0,0,128,821,1,0,0,0,130,823,1,
  	0,0,0,132,826,1,0,0,0,134,844,1,0,0,0,136,846,1,0,0,0,138,850,1,0,0,0,
  	140,858,1,0,0,0,142,862,1,0,0,0,144,893,1,0,0,0,146,895,1,0,0,0,148,905,
  	1,0,0,0,150,915,1,0,0,0,152,929,1,0,0,0,154,939,1,0,0,0,156,949,1,0,0,
  	0,158,959,1,0,0,0,160,970,1,0,0,0,162,980,1,0,0,0,164,987,1,0,0,0,166,
  	994,1,0,0,0,168,1004,1,0,0,0,170,1014,1,0,0,0,172,1024,1,0,0,0,174,1036,
  	1,0,0,0,176,1048,1,0,0,0,178,1058,1,0,0,0,180,1068,1,0,0,0,182,1078,1,
  	0,0,0,184,1091,1,0,0,0,186,1097,1,0,0,0,188,1108,1,0,0,0,190,1115,1,0,
  	0,0,192,1129,1,0,0,0,194,1144,1,0,0,0,196,1146,1,0,0,0,198,1154,1,0,0,
  	0,200,1162,1,0,0,0,202,1167,1,0,0,0,204,1181,1,0,0,0,206,1183,1,0,0,0,
  	208,1189,1,0,0,0,210,1197,1,0,0,0,212,1205,1,0,0,0,214,1212,1,0,0,0,216,
  	1214,1,0,0,0,218,1218,1,0,0,0,220,1238,1,0,0,0,222,1240,1,0,0,0,224,1246,
  	1,0,0,0,226,1252,1,0,0,0,228,1263,1,0,0,0,230,1265,1,0,0,0,232,1273,1,
  	0,0,0,234,1283,1,0,0,0,236,1285,1,0,0,0,238,1287,1,0,0,0,240,1289,1,0,
  	0,0,242,1295,1,0,0,0,244,1297,1,0,0,0,246,1303,1,0,0,0,248,1309,1,0,0,
  	0,250,1313,1,0,0,0,252,1320,1,0,0,0,254,1327,1,0,0,0,256,1329,1,0,0,0,
  	258,1337,1,0,0,0,260,1339,1,0,0,0,262,1347,1,0,0,0,264,1349,1,0,0,0,266,
  	1358,1,0,0,0,268,1360,1,0,0,0,270,1371,1,0,0,0,272,1382,1,0,0,0,274,1393,
  	1,0,0,0,276,1402,1,0,0,0,278,1416,1,0,0,0,280,1418,1,0,0,0,282,1424,1,
  	0,0,0,284,1430,1,0,0,0,286,1434,1,0,0,0,288,1445,1,0,0,0,290,1450,1,0,
  	0,0,292,1458,1,0,0,0,294,1464,1,0,0,0,296,1466,1,0,0,0,298,1472,1,0,0,
  	0,300,1480,1,0,0,0,302,1488,1,0,0,0,304,1490,1,0,0,0,306,1498,1,0,0,0,
  	308,1511,1,0,0,0,310,1533,1,0,0,0,312,1535,1,0,0,0,314,315,3,2,1,0,315,
  	316,5,0,0,1,316,1,1,0,0,0,317,324,3,4,2,0,318,320,5,126,0,0,319,318,1,
  	0,0,0,319,320,1,0,0,0,320,321,1,0,0,0,321,323,3,4,2,0,322,319,1,0,0,0,
  	323,326,1,0,0,0,324,322,1,0,0,0,324,325,1,0,0,0,325,328,1,0,0,0,326,324,
  	1,0,0,0,327,329,5,126,0,0,328,327,1,0,0,0,328,329,1,0,0,0,329,3,1,0,0,
  	0,330,338,3,14,7,0,331,338,3,288,144,0,332,338,3,50,25,0,333,338,3,6,
  	3,0,334,338,3,8,4,0,335,338,3,10,5,0,336,338,3,12,6,0,337,330,1,0,0,0,
  	337,331,1,0,0,0,337,332,1,0,0,0,337,333,1,0,0,0,337,334,1,0,0,0,337,335,
  	1,0,0,0,337,336,1,0,0,0,338,5,1,0,0,0,339,340,3,52,26,0,340,341,5,126,
  	0,0,341,7,1,0,0,0,342,343,5,34,0,0,343,344,3,52,26,0,344,345,5,126,0,
  	0,345,9,1,0,0,0,346,347,5,35,0,0,347,348,3,52,26,0,348,349,5,126,0,0,
  	349,11,1,0,0,0,350,351,5,22,0,0,351,352,5,117,0,0,352,353,3,52,26,0,353,
  	354,5,118,0,0,354,355,5,126,0,0,355,13,1,0,0,0,356,366,3,28,14,0,357,
  	366,3,40,20,0,358,366,3,42,21,0,359,366,3,44,22,0,360,366,3,48,24,0,361,
  	366,3,46,23,0,362,366,3,16,8,0,363,366,3,20,10,0,364,366,3,24,12,0,365,
  	356,1,0,0,0,365,357,1,0,0,0,365,358,1,0,0,0,365,359,1,0,0,0,365,360,1,
  	0,0,0,365,361,1,0,0,0,365,362,1,0,0,0,365,363,1,0,0,0,365,364,1,0,0,0,
  	366,15,1,0,0,0,367,368,5,15,0,0,368,369,5,128,0,0,369,373,5,121,0,0,370,
  	372,3,18,9,0,371,370,1,0,0,0,372,375,1,0,0,0,373,371,1,0,0,0,373,374,
  	1,0,0,0,374,376,1,0,0,0,375,373,1,0,0,0,376,377,5,122,0,0,377,17,1,0,
  	0,0,378,379,5,16,0,0,379,380,3,306,153,0,380,381,5,126,0,0,381,399,1,
  	0,0,0,382,383,5,32,0,0,383,384,5,128,0,0,384,385,5,125,0,0,385,386,3,
  	86,43,0,386,387,5,126,0,0,387,399,1,0,0,0,388,389,5,33,0,0,389,390,7,
  	0,0,0,390,391,5,121,0,0,391,392,5,12,0,0,392,393,3,52,26,0,393,394,5,
  	99,0,0,394,395,3,216,108,0,395,396,5,122,0,0,396,399,1,0,0,0,397,399,
  	3,14,7,0,398,378,1,0,0,0,398,382,1,0,0,0,398,388,1,0,0,0,398,397,1,0,
  	0,0,399,19,1,0,0,0,400,401,5,27,0,0,401,402,5,128,0,0,402,406,5,121,0,
  	0,403,405,3,22,11,0,404,403,1,0,0,0,405,408,1,0,0,0,406,404,1,0,0,0,406,
  	407,1,0,0,0,407,409,1,0,0,0,408,406,1,0,0,0,409,410,5,122,0,0,410,21,
  	1,0,0,0,411,412,5,31,0,0,412,413,5,128,0,0,413,414,5,125,0,0,414,417,
  	3,86,43,0,415,416,5,14,0,0,416,418,3,52,26,0,417,415,1,0,0,0,417,418,
  	1,0,0,0,418,419,1,0,0,0,419,420,5,126,0,0,420,435,1,0,0,0,421,422,5,28,
  	0,0,422,426,5,121,0,0,423,425,3,6,3,0,424,423,1,0,0,0,425,428,1,0,0,0,
  	426,424,1,0,0,0,426,427,1,0,0,0,427,429,1,0,0,0,428,426,1,0,0,0,429,435,
  	5,122,0,0,430,431,7,1,0,0,431,432,3,52,26,0,432,433,5,126,0,0,433,435,
  	1,0,0,0,434,411,1,0,0,0,434,421,1,0,0,0,434,430,1,0,0,0,435,23,1,0,0,
  	0,436,437,5,20,0,0,437,438,5,128,0,0,438,442,5,121,0,0,439,441,3,26,13,
  	0,440,439,1,0,0,0,441,444,1,0,0,0,442,440,1,0,0,0,442,443,1,0,0,0,443,
  	445,1,0,0,0,444,442,1,0,0,0,445,446,5,122,0,0,446,25,1,0,0,0,447,448,
  	5,21,0,0,448,449,5,128,0,0,449,453,5,121,0,0,450,452,3,6,3,0,451,450,
  	1,0,0,0,452,455,1,0,0,0,453,451,1,0,0,0,453,454,1,0,0,0,454,456,1,0,0,
  	0,455,453,1,0,0,0,456,457,5,122,0,0,457,27,1,0,0,0,458,459,5,1,0,0,459,
  	460,3,30,15,0,460,461,5,126,0,0,461,469,1,0,0,0,462,463,5,2,0,0,463,464,
  	3,34,17,0,464,465,5,1,0,0,465,466,3,36,18,0,466,467,5,126,0,0,467,469,
  	1,0,0,0,468,458,1,0,0,0,468,462,1,0,0,0,469,29,1,0,0,0,470,475,3,32,16,
  	0,471,472,5,124,0,0,472,474,3,32,16,0,473,471,1,0,0,0,474,477,1,0,0,0,
  	475,473,1,0,0,0,475,476,1,0,0,0,476,31,1,0,0,0,477,475,1,0,0,0,478,481,
  	3,300,150,0,479,480,5,4,0,0,480,482,5,128,0,0,481,479,1,0,0,0,481,482,
  	1,0,0,0,482,33,1,0,0,0,483,484,3,300,150,0,484,35,1,0,0,0,485,490,3,38,
  	19,0,486,487,5,124,0,0,487,489,3,38,19,0,488,486,1,0,0,0,489,492,1,0,
  	0,0,490,488,1,0,0,0,490,491,1,0,0,0,491,495,1,0,0,0,492,490,1,0,0,0,493,
  	495,5,82,0,0,494,485,1,0,0,0,494,493,1,0,0,0,495,37,1,0,0,0,496,499,5,
  	128,0,0,497,498,5,4,0,0,498,500,5,128,0,0,499,497,1,0,0,0,499,500,1,0,
  	0,0,500,39,1,0,0,0,501,502,5,3,0,0,502,505,5,128,0,0,503,504,5,125,0,
  	0,504,506,3,86,43,0,505,503,1,0,0,0,505,506,1,0,0,0,506,507,1,0,0,0,507,
  	508,5,127,0,0,508,509,3,52,26,0,509,41,1,0,0,0,510,511,5,10,0,0,511,512,
  	5,128,0,0,512,514,5,117,0,0,513,515,3,142,71,0,514,513,1,0,0,0,514,515,
  	1,0,0,0,515,516,1,0,0,0,516,517,5,118,0,0,517,518,5,99,0,0,518,519,3,
  	86,43,0,519,520,5,127,0,0,520,521,3,52,26,0,521,43,1,0,0,0,522,523,5,
  	128,0,0,523,524,5,125,0,0,524,525,5,74,0,0,525,526,5,88,0,0,526,527,3,
  	86,43,0,527,528,5,99,0,0,528,529,3,86,43,0,529,530,5,90,0,0,530,531,5,
  	127,0,0,531,532,3,56,28,0,532,45,1,0,0,0,533,534,5,6,0,0,534,536,5,128,
  	0,0,535,537,3,122,61,0,536,535,1,0,0,0,536,537,1,0,0,0,537,538,1,0,0,
  	0,538,539,5,121,0,0,539,540,3,138,69,0,540,542,5,122,0,0,541,543,3,130,
  	65,0,542,541,1,0,0,0,542,543,1,0,0,0,543,47,1,0,0,0,544,545,5,8,0,0,545,
  	546,5,128,0,0,546,547,5,121,0,0,547,548,3,138,69,0,548,549,5,122,0,0,
  	549,49,1,0,0,0,550,551,5,9,0,0,551,552,3,14,7,0,552,553,5,5,0,0,553,554,
  	5,121,0,0,554,555,3,290,145,0,555,556,5,122,0,0,556,51,1,0,0,0,557,561,
  	3,194,97,0,558,561,3,144,72,0,559,561,3,54,27,0,560,557,1,0,0,0,560,558,
  	1,0,0,0,560,559,1,0,0,0,561,53,1,0,0,0,562,567,3,58,29,0,563,564,7,2,
  	0,0,564,566,3,58,29,0,565,563,1,0,0,0,566,569,1,0,0,0,567,565,1,0,0,0,
  	567,568,1,0,0,0,568,55,1,0,0,0,569,567,1,0,0,0,570,575,3,52,26,0,571,
  	572,7,2,0,0,572,574,3,52,26,0,573,571,1,0,0,0,574,577,1,0,0,0,575,573,
  	1,0,0,0,575,576,1,0,0,0,576,57,1,0,0,0,577,575,1,0,0,0,578,583,3,60,30,
  	0,579,580,5,101,0,0,580,582,3,60,30,0,581,579,1,0,0,0,582,585,1,0,0,0,
  	583,581,1,0,0,0,583,584,1,0,0,0,584,59,1,0,0,0,585,583,1,0,0,0,586,592,
  	3,62,31,0,587,588,5,132,0,0,588,589,3,52,26,0,589,590,5,125,0,0,590,591,
  	3,60,30,0,591,593,1,0,0,0,592,587,1,0,0,0,592,593,1,0,0,0,593,61,1,0,
  	0,0,594,599,3,64,32,0,595,596,7,3,0,0,596,598,3,64,32,0,597,595,1,0,0,
  	0,598,601,1,0,0,0,599,597,1,0,0,0,599,600,1,0,0,0,600,63,1,0,0,0,601,
  	599,1,0,0,0,602,607,3,66,33,0,603,604,5,91,0,0,604,606,3,66,33,0,605,
  	603,1,0,0,0,606,609,1,0,0,0,607,605,1,0,0,0,607,608,1,0,0,0,608,65,1,
  	0,0,0,609,607,1,0,0,0,610,615,3,68,34,0,611,612,7,4,0,0,612,614,3,68,
  	34,0,613,611,1,0,0,0,614,617,1,0,0,0,615,613,1,0,0,0,615,616,1,0,0,0,
  	616,67,1,0,0,0,617,615,1,0,0,0,618,623,3,70,35,0,619,620,7,5,0,0,620,
  	622,3,70,35,0,621,619,1,0,0,0,622,625,1,0,0,0,623,621,1,0,0,0,623,624,
  	1,0,0,0,624,69,1,0,0,0,625,623,1,0,0,0,626,631,3,72,36,0,627,628,7,6,
  	0,0,628,630,3,72,36,0,629,627,1,0,0,0,630,633,1,0,0,0,631,629,1,0,0,0,
  	631,632,1,0,0,0,632,71,1,0,0,0,633,631,1,0,0,0,634,639,3,74,37,0,635,
  	636,7,7,0,0,636,638,3,74,37,0,637,635,1,0,0,0,638,641,1,0,0,0,639,637,
  	1,0,0,0,639,640,1,0,0,0,640,73,1,0,0,0,641,639,1,0,0,0,642,643,7,8,0,
  	0,643,646,3,74,37,0,644,646,3,76,38,0,645,642,1,0,0,0,645,644,1,0,0,0,
  	646,75,1,0,0,0,647,649,3,78,39,0,648,650,5,132,0,0,649,648,1,0,0,0,649,
  	650,1,0,0,0,650,77,1,0,0,0,651,655,3,84,42,0,652,654,3,80,40,0,653,652,
  	1,0,0,0,654,657,1,0,0,0,655,653,1,0,0,0,655,656,1,0,0,0,656,79,1,0,0,
  	0,657,655,1,0,0,0,658,669,3,82,41,0,659,660,5,123,0,0,660,662,5,128,0,
  	0,661,663,3,82,41,0,662,661,1,0,0,0,662,663,1,0,0,0,663,669,1,0,0,0,664,
  	665,5,119,0,0,665,666,3,52,26,0,666,667,5,120,0,0,667,669,1,0,0,0,668,
  	658,1,0,0,0,668,659,1,0,0,0,668,664,1,0,0,0,669,81,1,0,0,0,670,672,5,
  	117,0,0,671,673,3,312,156,0,672,671,1,0,0,0,672,673,1,0,0,0,673,674,1,
  	0,0,0,674,675,5,118,0,0,675,83,1,0,0,0,676,687,3,302,151,0,677,687,3,
  	194,97,0,678,687,3,222,111,0,679,687,3,280,140,0,680,687,3,282,141,0,
  	681,687,3,300,150,0,682,683,5,117,0,0,683,684,3,52,26,0,684,685,5,118,
  	0,0,685,687,1,0,0,0,686,676,1,0,0,0,686,677,1,0,0,0,686,678,1,0,0,0,686,
  	679,1,0,0,0,686,680,1,0,0,0,686,681,1,0,0,0,686,682,1,0,0,0,687,85,1,
  	0,0,0,688,693,3,88,44,0,689,690,5,100,0,0,690,692,3,88,44,0,691,689,1,
  	0,0,0,692,695,1,0,0,0,693,691,1,0,0,0,693,694,1,0,0,0,694,87,1,0,0,0,
  	695,693,1,0,0,0,696,698,3,90,45,0,697,699,5,132,0,0,698,697,1,0,0,0,698,
  	699,1,0,0,0,699,89,1,0,0,0,700,714,3,92,46,0,701,714,3,94,47,0,702,714,
  	3,96,48,0,703,714,3,98,49,0,704,714,3,100,50,0,705,714,3,102,51,0,706,
  	714,3,104,52,0,707,714,3,106,53,0,708,714,3,108,54,0,709,714,3,110,55,
  	0,710,714,3,112,56,0,711,714,3,114,57,0,712,714,3,116,58,0,713,700,1,
  	0,0,0,713,701,1,0,0,0,713,702,1,0,0,0,713,703,1,0,0,0,713,704,1,0,0,0,
  	713,705,1,0,0,0,713,706,1,0,0,0,713,707,1,0,0,0,713,708,1,0,0,0,713,709,
  	1,0,0,0,713,710,1,0,0,0,713,711,1,0,0,0,713,712,1,0,0,0,714,91,1,0,0,
  	0,715,716,7,9,0,0,716,93,1,0,0,0,717,719,3,300,150,0,718,720,3,118,59,
  	0,719,718,1,0,0,0,719,720,1,0,0,0,720,95,1,0,0,0,721,722,5,74,0,0,722,
  	723,5,88,0,0,723,724,3,86,43,0,724,725,5,99,0,0,725,726,3,86,43,0,726,
  	727,5,90,0,0,727,97,1,0,0,0,728,729,5,71,0,0,729,730,5,88,0,0,730,731,
  	3,86,43,0,731,732,5,90,0,0,732,99,1,0,0,0,733,734,5,72,0,0,734,735,5,
  	88,0,0,735,736,3,86,43,0,736,737,5,124,0,0,737,738,3,86,43,0,738,739,
  	5,90,0,0,739,101,1,0,0,0,740,741,5,73,0,0,741,742,5,88,0,0,742,743,3,
  	86,43,0,743,744,5,90,0,0,744,103,1,0,0,0,745,746,5,75,0,0,746,747,5,88,
  	0,0,747,748,3,86,43,0,748,749,5,90,0,0,749,105,1,0,0,0,750,751,5,76,0,
  	0,751,752,5,88,0,0,752,753,3,86,43,0,753,754,5,90,0,0,754,107,1,0,0,0,
  	755,756,5,77,0,0,756,757,5,88,0,0,757,758,3,86,43,0,758,759,5,124,0,0,
  	759,760,3,86,43,0,760,761,5,90,0,0,761,109,1,0,0,0,762,763,5,78,0,0,763,
  	764,5,88,0,0,764,765,3,86,43,0,765,766,5,90,0,0,766,111,1,0,0,0,767,768,
  	5,79,0,0,768,769,5,88,0,0,769,770,3,86,43,0,770,771,5,90,0,0,771,113,
  	1,0,0,0,772,774,5,117,0,0,773,775,3,120,60,0,774,773,1,0,0,0,774,775,
  	1,0,0,0,775,776,1,0,0,0,776,777,5,118,0,0,777,778,5,99,0,0,778,779,3,
  	86,43,0,779,115,1,0,0,0,780,781,5,117,0,0,781,782,3,86,43,0,782,783,5,
  	118,0,0,783,117,1,0,0,0,784,785,5,88,0,0,785,786,3,120,60,0,786,787,5,
  	90,0,0,787,119,1,0,0,0,788,793,3,86,43,0,789,790,5,124,0,0,790,792,3,
  	86,43,0,791,789,1,0,0,0,792,795,1,0,0,0,793,791,1,0,0,0,793,794,1,0,0,
  	0,794,121,1,0,0,0,795,793,1,0,0,0,796,797,5,88,0,0,797,798,3,124,62,0,
  	798,799,5,90,0,0,799,123,1,0,0,0,800,805,3,126,63,0,801,802,5,124,0,0,
  	802,804,3,126,63,0,803,801,1,0,0,0,804,807,1,0,0,0,805,803,1,0,0,0,805,
  	806,1,0,0,0,806,125,1,0,0,0,807,805,1,0,0,0,808,812,5,128,0,0,809,811,
  	3,128,64,0,810,809,1,0,0,0,811,814,1,0,0,0,812,810,1,0,0,0,812,813,1,
  	0,0,0,813,127,1,0,0,0,814,812,1,0,0,0,815,816,5,125,0,0,816,822,3,86,
  	43,0,817,818,5,127,0,0,818,822,3,86,43,0,819,820,5,7,0,0,820,822,3,86,
  	43,0,821,815,1,0,0,0,821,817,1,0,0,0,821,819,1,0,0,0,822,129,1,0,0,0,
  	823,824,5,13,0,0,824,825,3,132,66,0,825,131,1,0,0,0,826,831,3,134,67,
  	0,827,828,5,124,0,0,828,830,3,134,67,0,829,827,1,0,0,0,830,833,1,0,0,
  	0,831,829,1,0,0,0,831,832,1,0,0,0,832,133,1,0,0,0,833,831,1,0,0,0,834,
  	835,5,128,0,0,835,836,5,125,0,0,836,845,3,86,43,0,837,838,5,128,0,0,838,
  	839,5,127,0,0,839,845,3,86,43,0,840,841,5,128,0,0,841,842,5,7,0,0,842,
  	845,3,86,43,0,843,845,3,52,26,0,844,834,1,0,0,0,844,837,1,0,0,0,844,840,
  	1,0,0,0,844,843,1,0,0,0,845,135,1,0,0,0,846,847,5,128,0,0,847,848,5,125,
  	0,0,848,849,3,86,43,0,849,137,1,0,0,0,850,855,3,136,68,0,851,852,5,124,
  	0,0,852,854,3,136,68,0,853,851,1,0,0,0,854,857,1,0,0,0,855,853,1,0,0,
  	0,855,856,1,0,0,0,856,139,1,0,0,0,857,855,1,0,0,0,858,859,5,128,0,0,859,
  	860,5,125,0,0,860,861,3,86,43,0,861,141,1,0,0,0,862,867,3,140,70,0,863,
  	864,5,124,0,0,864,866,3,140,70,0,865,863,1,0,0,0,866,869,1,0,0,0,867,
  	865,1,0,0,0,867,868,1,0,0,0,868,143,1,0,0,0,869,867,1,0,0,0,870,894,3,
  	146,73,0,871,894,3,148,74,0,872,894,3,150,75,0,873,894,3,152,76,0,874,
  	894,3,154,77,0,875,894,3,156,78,0,876,894,3,158,79,0,877,894,3,160,80,
  	0,878,894,3,162,81,0,879,894,3,164,82,0,880,894,3,166,83,0,881,894,3,
  	168,84,0,882,894,3,170,85,0,883,894,3,172,86,0,884,894,3,174,87,0,885,
  	894,3,176,88,0,886,894,3,178,89,0,887,894,3,180,90,0,888,894,3,182,91,
  	0,889,894,3,186,93,0,890,894,3,188,94,0,891,894,3,190,95,0,892,894,3,
  	192,96,0,893,870,1,0,0,0,893,871,1,0,0,0,893,872,1,0,0,0,893,873,1,0,
  	0,0,893,874,1,0,0,0,893,875,1,0,0,0,893,876,1,0,0,0,893,877,1,0,0,0,893,
  	878,1,0,0,0,893,879,1,0,0,0,893,880,1,0,0,0,893,881,1,0,0,0,893,882,1,
  	0,0,0,893,883,1,0,0,0,893,884,1,0,0,0,893,885,1,0,0,0,893,886,1,0,0,0,
  	893,887,1,0,0,0,893,888,1,0,0,0,893,889,1,0,0,0,893,890,1,0,0,0,893,891,
  	1,0,0,0,893,892,1,0,0,0,894,145,1,0,0,0,895,896,5,37,0,0,896,899,5,117,
  	0,0,897,900,3,194,97,0,898,900,3,52,26,0,899,897,1,0,0,0,899,898,1,0,
  	0,0,900,901,1,0,0,0,901,902,5,124,0,0,902,903,3,52,26,0,903,904,5,118,
  	0,0,904,147,1,0,0,0,905,906,5,38,0,0,906,907,5,117,0,0,907,908,3,52,26,
  	0,908,911,5,124,0,0,909,912,3,194,97,0,910,912,3,52,26,0,911,909,1,0,
  	0,0,911,910,1,0,0,0,912,913,1,0,0,0,913,914,5,118,0,0,914,149,1,0,0,0,
  	915,916,5,39,0,0,916,917,5,117,0,0,917,918,3,52,26,0,918,921,5,124,0,
  	0,919,922,3,194,97,0,920,922,3,52,26,0,921,919,1,0,0,0,921,920,1,0,0,
  	0,922,925,1,0,0,0,923,924,5,124,0,0,924,926,3,52,26,0,925,923,1,0,0,0,
  	925,926,1,0,0,0,926,927,1,0,0,0,927,928,5,118,0,0,928,151,1,0,0,0,929,
  	930,5,40,0,0,930,931,5,117,0,0,931,932,3,52,26,0,932,935,5,124,0,0,933,
  	936,3,194,97,0,934,936,3,52,26,0,935,933,1,0,0,0,935,934,1,0,0,0,936,
  	937,1,0,0,0,937,938,5,118,0,0,938,153,1,0,0,0,939,940,5,41,0,0,940,941,
  	5,117,0,0,941,942,3,52,26,0,942,945,5,124,0,0,943,946,3,194,97,0,944,
  	946,3,52,26,0,945,943,1,0,0,0,945,944,1,0,0,0,946,947,1,0,0,0,947,948,
  	5,118,0,0,948,155,1,0,0,0,949,950,5,42,0,0,950,951,5,117,0,0,951,952,
  	3,52,26,0,952,955,5,124,0,0,953,956,3,194,97,0,954,956,3,52,26,0,955,
  	953,1,0,0,0,955,954,1,0,0,0,956,957,1,0,0,0,957,958,5,118,0,0,958,157,
  	1,0,0,0,959,960,5,43,0,0,960,961,5,117,0,0,961,962,3,52,26,0,962,963,
  	5,124,0,0,963,966,3,52,26,0,964,965,5,124,0,0,965,967,3,194,97,0,966,
  	964,1,0,0,0,966,967,1,0,0,0,967,968,1,0,0,0,968,969,5,118,0,0,969,159,
  	1,0,0,0,970,971,5,44,0,0,971,972,5,117,0,0,972,973,3,52,26,0,973,976,
  	5,124,0,0,974,977,3,194,97,0,975,977,3,52,26,0,976,974,1,0,0,0,976,975,
  	1,0,0,0,977,978,1,0,0,0,978,979,5,118,0,0,979,161,1,0,0,0,980,981,5,45,
  	0,0,981,982,5,117,0,0,982,983,3,52,26,0,983,984,5,124,0,0,984,985,3,52,
  	26,0,985,986,5,118,0,0,986,163,1,0,0,0,987,988,5,46,0,0,988,989,5,117,
  	0,0,989,990,3,52,26,0,990,991,5,124,0,0,991,992,3,52,26,0,992,993,5,118,
  	0,0,993,165,1,0,0,0,994,995,5,47,0,0,995,996,5,117,0,0,996,997,3,52,26,
  	0,997,1000,5,124,0,0,998,1001,3,194,97,0,999,1001,3,52,26,0,1000,998,
  	1,0,0,0,1000,999,1,0,0,0,1001,1002,1,0,0,0,1002,1003,5,118,0,0,1003,167,
  	1,0,0,0,1004,1005,5,48,0,0,1005,1006,5,117,0,0,1006,1007,3,52,26,0,1007,
  	1010,5,124,0,0,1008,1011,3,194,97,0,1009,1011,3,52,26,0,1010,1008,1,0,
  	0,0,1010,1009,1,0,0,0,1011,1012,1,0,0,0,1012,1013,5,118,0,0,1013,169,
  	1,0,0,0,1014,1015,5,49,0,0,1015,1016,5,117,0,0,1016,1017,3,52,26,0,1017,
  	1020,5,124,0,0,1018,1021,3,194,97,0,1019,1021,3,52,26,0,1020,1018,1,0,
  	0,0,1020,1019,1,0,0,0,1021,1022,1,0,0,0,1022,1023,5,118,0,0,1023,171,
  	1,0,0,0,1024,1025,5,50,0,0,1025,1026,5,117,0,0,1026,1032,3,52,26,0,1027,
  	1030,5,124,0,0,1028,1031,3,194,97,0,1029,1031,3,52,26,0,1030,1028,1,0,
  	0,0,1030,1029,1,0,0,0,1031,1033,1,0,0,0,1032,1027,1,0,0,0,1032,1033,1,
  	0,0,0,1033,1034,1,0,0,0,1034,1035,5,118,0,0,1035,173,1,0,0,0,1036,1037,
  	5,51,0,0,1037,1038,5,117,0,0,1038,1044,3,52,26,0,1039,1042,5,124,0,0,
  	1040,1043,3,194,97,0,1041,1043,3,52,26,0,1042,1040,1,0,0,0,1042,1041,
  	1,0,0,0,1043,1045,1,0,0,0,1044,1039,1,0,0,0,1044,1045,1,0,0,0,1045,1046,
  	1,0,0,0,1046,1047,5,118,0,0,1047,175,1,0,0,0,1048,1049,5,52,0,0,1049,
  	1050,5,117,0,0,1050,1051,3,52,26,0,1051,1054,5,124,0,0,1052,1055,3,194,
  	97,0,1053,1055,3,52,26,0,1054,1052,1,0,0,0,1054,1053,1,0,0,0,1055,1056,
  	1,0,0,0,1056,1057,5,118,0,0,1057,177,1,0,0,0,1058,1059,5,53,0,0,1059,
  	1060,5,117,0,0,1060,1061,3,52,26,0,1061,1064,5,124,0,0,1062,1065,3,194,
  	97,0,1063,1065,3,52,26,0,1064,1062,1,0,0,0,1064,1063,1,0,0,0,1065,1066,
  	1,0,0,0,1066,1067,5,118,0,0,1067,179,1,0,0,0,1068,1069,5,54,0,0,1069,
  	1070,5,117,0,0,1070,1071,3,52,26,0,1071,1074,5,124,0,0,1072,1075,3,194,
  	97,0,1073,1075,3,52,26,0,1074,1072,1,0,0,0,1074,1073,1,0,0,0,1075,1076,
  	1,0,0,0,1076,1077,5,118,0,0,1077,181,1,0,0,0,1078,1079,5,55,0,0,1079,
  	1080,5,117,0,0,1080,1081,3,52,26,0,1081,1082,5,124,0,0,1082,1083,3,52,
  	26,0,1083,1084,5,124,0,0,1084,1087,3,184,92,0,1085,1086,5,124,0,0,1086,
  	1088,3,52,26,0,1087,1085,1,0,0,0,1087,1088,1,0,0,0,1088,1089,1,0,0,0,
  	1089,1090,5,118,0,0,1090,183,1,0,0,0,1091,1092,5,56,0,0,1092,1095,5,127,
  	0,0,1093,1096,3,194,97,0,1094,1096,3,52,26,0,1095,1093,1,0,0,0,1095,1094,
  	1,0,0,0,1096,185,1,0,0,0,1097,1098,5,57,0,0,1098,1099,5,117,0,0,1099,
  	1100,3,52,26,0,1100,1101,5,124,0,0,1101,1104,3,52,26,0,1102,1103,5,124,
  	0,0,1103,1105,3,52,26,0,1104,1102,1,0,0,0,1104,1105,1,0,0,0,1105,1106,
  	1,0,0,0,1106,1107,5,118,0,0,1107,187,1,0,0,0,1108,1109,5,58,0,0,1109,
  	1110,5,117,0,0,1110,1111,3,52,26,0,1111,1112,5,124,0,0,1112,1113,3,52,
  	26,0,1113,1114,5,118,0,0,1114,189,1,0,0,0,1115,1116,5,59,0,0,1116,1117,
  	5,117,0,0,1117,1118,3,52,26,0,1118,1121,5,124,0,0,1119,1122,3,194,97,
  	0,1120,1122,3,52,26,0,1121,1119,1,0,0,0,1121,1120,1,0,0,0,1122,1125,1,
  	0,0,0,1123,1124,5,124,0,0,1124,1126,3,52,26,0,1125,1123,1,0,0,0,1125,
  	1126,1,0,0,0,1126,1127,1,0,0,0,1127,1128,5,118,0,0,1128,191,1,0,0,0,1129,
  	1130,5,60,0,0,1130,1131,5,117,0,0,1131,1132,3,52,26,0,1132,1135,5,124,
  	0,0,1133,1136,3,194,97,0,1134,1136,3,52,26,0,1135,1133,1,0,0,0,1135,1134,
  	1,0,0,0,1136,1137,1,0,0,0,1137,1138,5,124,0,0,1138,1139,3,52,26,0,1139,
  	1140,5,118,0,0,1140,193,1,0,0,0,1141,1145,3,196,98,0,1142,1145,3,202,
  	101,0,1143,1145,3,206,103,0,1144,1141,1,0,0,0,1144,1142,1,0,0,0,1144,
  	1143,1,0,0,0,1145,195,1,0,0,0,1146,1147,5,117,0,0,1147,1148,3,198,99,
  	0,1148,1149,5,118,0,0,1149,1152,5,98,0,0,1150,1153,3,52,26,0,1151,1153,
  	3,216,108,0,1152,1150,1,0,0,0,1152,1151,1,0,0,0,1153,197,1,0,0,0,1154,
  	1159,3,200,100,0,1155,1156,5,124,0,0,1156,1158,3,200,100,0,1157,1155,
  	1,0,0,0,1158,1161,1,0,0,0,1159,1157,1,0,0,0,1159,1160,1,0,0,0,1160,199,
  	1,0,0,0,1161,1159,1,0,0,0,1162,1165,5,128,0,0,1163,1164,5,125,0,0,1164,
  	1166,3,86,43,0,1165,1163,1,0,0,0,1165,1166,1,0,0,0,1166,201,1,0,0,0,1167,
  	1168,3,204,102,0,1168,1171,5,98,0,0,1169,1172,3,52,26,0,1170,1172,3,216,
  	108,0,1171,1169,1,0,0,0,1171,1170,1,0,0,0,1172,203,1,0,0,0,1173,1174,
  	5,121,0,0,1174,1175,3,210,105,0,1175,1176,5,122,0,0,1176,1182,1,0,0,0,
  	1177,1178,5,119,0,0,1178,1179,3,208,104,0,1179,1180,5,120,0,0,1180,1182,
  	1,0,0,0,1181,1173,1,0,0,0,1181,1177,1,0,0,0,1182,205,1,0,0,0,1183,1184,
  	5,128,0,0,1184,1187,5,98,0,0,1185,1188,3,52,26,0,1186,1188,3,216,108,
  	0,1187,1185,1,0,0,0,1187,1186,1,0,0,0,1188,207,1,0,0,0,1189,1194,3,212,
  	106,0,1190,1191,5,124,0,0,1191,1193,3,212,106,0,1192,1190,1,0,0,0,1193,
  	1196,1,0,0,0,1194,1192,1,0,0,0,1194,1195,1,0,0,0,1195,209,1,0,0,0,1196,
  	1194,1,0,0,0,1197,1202,3,214,107,0,1198,1199,5,124,0,0,1199,1201,3,214,
  	107,0,1200,1198,1,0,0,0,1201,1204,1,0,0,0,1202,1200,1,0,0,0,1202,1203,
  	1,0,0,0,1203,211,1,0,0,0,1204,1202,1,0,0,0,1205,1206,7,10,0,0,1206,213,
  	1,0,0,0,1207,1213,5,128,0,0,1208,1209,5,128,0,0,1209,1210,5,125,0,0,1210,
  	1213,5,128,0,0,1211,1213,5,110,0,0,1212,1207,1,0,0,0,1212,1208,1,0,0,
  	0,1212,1211,1,0,0,0,1213,215,1,0,0,0,1214,1215,5,121,0,0,1215,1216,3,
  	218,109,0,1216,1217,5,122,0,0,1217,217,1,0,0,0,1218,1223,3,220,110,0,
  	1219,1220,5,126,0,0,1220,1222,3,220,110,0,1221,1219,1,0,0,0,1222,1225,
  	1,0,0,0,1223,1221,1,0,0,0,1223,1224,1,0,0,0,1224,1227,1,0,0,0,1225,1223,
  	1,0,0,0,1226,1228,5,126,0,0,1227,1226,1,0,0,0,1227,1228,1,0,0,0,1228,
  	219,1,0,0,0,1229,1230,5,3,0,0,1230,1233,5,128,0,0,1231,1232,5,125,0,0,
  	1232,1234,3,86,43,0,1233,1231,1,0,0,0,1233,1234,1,0,0,0,1234,1235,1,0,
  	0,0,1235,1236,5,127,0,0,1236,1239,3,52,26,0,1237,1239,3,52,26,0,1238,
  	1229,1,0,0,0,1238,1237,1,0,0,0,1239,221,1,0,0,0,1240,1241,5,11,0,0,1241,
  	1242,3,52,26,0,1242,1243,5,121,0,0,1243,1244,3,226,113,0,1244,1245,5,
  	122,0,0,1245,223,1,0,0,0,1246,1247,3,228,114,0,1247,1250,5,99,0,0,1248,
  	1251,3,52,26,0,1249,1251,3,216,108,0,1250,1248,1,0,0,0,1250,1249,1,0,
  	0,0,1251,225,1,0,0,0,1252,1257,3,224,112,0,1253,1254,5,124,0,0,1254,1256,
  	3,224,112,0,1255,1253,1,0,0,0,1256,1259,1,0,0,0,1257,1255,1,0,0,0,1257,
  	1258,1,0,0,0,1258,1261,1,0,0,0,1259,1257,1,0,0,0,1260,1262,5,124,0,0,
  	1261,1260,1,0,0,0,1261,1262,1,0,0,0,1262,227,1,0,0,0,1263,1264,3,230,
  	115,0,1264,229,1,0,0,0,1265,1270,3,232,116,0,1266,1267,5,100,0,0,1267,
  	1269,3,232,116,0,1268,1266,1,0,0,0,1269,1272,1,0,0,0,1270,1268,1,0,0,
  	0,1270,1271,1,0,0,0,1271,231,1,0,0,0,1272,1270,1,0,0,0,1273,1274,3,234,
  	117,0,1274,233,1,0,0,0,1275,1284,3,236,118,0,1276,1284,3,238,119,0,1277,
  	1284,3,240,120,0,1278,1284,3,242,121,0,1279,1284,3,252,126,0,1280,1284,
  	3,256,128,0,1281,1284,3,260,130,0,1282,1284,3,264,132,0,1283,1275,1,0,
  	0,0,1283,1276,1,0,0,0,1283,1277,1,0,0,0,1283,1278,1,0,0,0,1283,1279,1,
  	0,0,0,1283,1280,1,0,0,0,1283,1281,1,0,0,0,1283,1282,1,0,0,0,1284,235,
  	1,0,0,0,1285,1286,5,110,0,0,1286,237,1,0,0,0,1287,1288,3,302,151,0,1288,
  	239,1,0,0,0,1289,1290,5,128,0,0,1290,241,1,0,0,0,1291,1296,3,244,122,
  	0,1292,1296,3,246,123,0,1293,1296,3,248,124,0,1294,1296,3,250,125,0,1295,
  	1291,1,0,0,0,1295,1292,1,0,0,0,1295,1293,1,0,0,0,1295,1294,1,0,0,0,1296,
  	243,1,0,0,0,1297,1299,5,121,0,0,1298,1300,3,268,134,0,1299,1298,1,0,0,
  	0,1299,1300,1,0,0,0,1300,1301,1,0,0,0,1301,1302,5,122,0,0,1302,245,1,
  	0,0,0,1303,1305,5,119,0,0,1304,1306,3,270,135,0,1305,1304,1,0,0,0,1305,
  	1306,1,0,0,0,1306,1307,1,0,0,0,1307,1308,5,120,0,0,1308,247,1,0,0,0,1309,
  	1310,5,117,0,0,1310,1311,3,270,135,0,1311,1312,5,118,0,0,1312,249,1,0,
  	0,0,1313,1314,3,300,150,0,1314,1316,5,121,0,0,1315,1317,3,268,134,0,1316,
  	1315,1,0,0,0,1316,1317,1,0,0,0,1317,1318,1,0,0,0,1318,1319,5,122,0,0,
  	1319,251,1,0,0,0,1320,1321,3,254,127,0,1321,1322,7,11,0,0,1322,1323,3,
  	254,127,0,1323,253,1,0,0,0,1324,1328,3,302,151,0,1325,1328,5,128,0,0,
  	1326,1328,3,300,150,0,1327,1324,1,0,0,0,1327,1325,1,0,0,0,1327,1326,1,
  	0,0,0,1328,255,1,0,0,0,1329,1330,3,258,129,0,1330,1331,5,125,0,0,1331,
  	1332,3,86,43,0,1332,257,1,0,0,0,1333,1338,3,236,118,0,1334,1338,3,238,
  	119,0,1335,1338,3,240,120,0,1336,1338,3,264,132,0,1337,1333,1,0,0,0,1337,
  	1334,1,0,0,0,1337,1335,1,0,0,0,1337,1336,1,0,0,0,1338,259,1,0,0,0,1339,
  	1340,3,258,129,0,1340,1341,5,12,0,0,1341,1342,3,262,131,0,1342,261,1,
  	0,0,0,1343,1344,5,128,0,0,1344,1345,7,12,0,0,1345,1348,3,302,151,0,1346,
  	1348,3,302,151,0,1347,1343,1,0,0,0,1347,1346,1,0,0,0,1348,263,1,0,0,0,
  	1349,1350,5,117,0,0,1350,1351,3,228,114,0,1351,1352,5,118,0,0,1352,265,
  	1,0,0,0,1353,1354,5,128,0,0,1354,1355,5,125,0,0,1355,1359,3,228,114,0,
  	1356,1359,5,128,0,0,1357,1359,5,110,0,0,1358,1353,1,0,0,0,1358,1356,1,
  	0,0,0,1358,1357,1,0,0,0,1359,267,1,0,0,0,1360,1365,3,266,133,0,1361,1362,
  	5,124,0,0,1362,1364,3,266,133,0,1363,1361,1,0,0,0,1364,1367,1,0,0,0,1365,
  	1363,1,0,0,0,1365,1366,1,0,0,0,1366,1369,1,0,0,0,1367,1365,1,0,0,0,1368,
  	1370,5,124,0,0,1369,1368,1,0,0,0,1369,1370,1,0,0,0,1370,269,1,0,0,0,1371,
  	1376,3,228,114,0,1372,1373,5,124,0,0,1373,1375,3,228,114,0,1374,1372,
  	1,0,0,0,1375,1378,1,0,0,0,1376,1374,1,0,0,0,1376,1377,1,0,0,0,1377,1380,
  	1,0,0,0,1378,1376,1,0,0,0,1379,1381,5,124,0,0,1380,1379,1,0,0,0,1380,
  	1381,1,0,0,0,1381,271,1,0,0,0,1382,1383,3,78,39,0,1383,1384,5,102,0,0,
  	1384,1385,3,274,137,0,1385,1386,3,276,138,0,1386,273,1,0,0,0,1387,1394,
  	5,112,0,0,1388,1389,5,128,0,0,1389,1390,5,117,0,0,1390,1391,5,112,0,0,
  	1391,1394,5,118,0,0,1392,1394,3,278,139,0,1393,1387,1,0,0,0,1393,1388,
  	1,0,0,0,1393,1392,1,0,0,0,1394,275,1,0,0,0,1395,1396,5,128,0,0,1396,1397,
  	5,103,0,0,1397,1403,5,128,0,0,1398,1399,3,52,26,0,1399,1400,5,103,0,0,
  	1400,1401,3,52,26,0,1401,1403,1,0,0,0,1402,1395,1,0,0,0,1402,1398,1,0,
  	0,0,1403,277,1,0,0,0,1404,1405,3,52,26,0,1405,1406,5,104,0,0,1406,1407,
  	3,52,26,0,1407,1417,1,0,0,0,1408,1409,3,52,26,0,1409,1410,5,105,0,0,1410,
  	1411,3,52,26,0,1411,1417,1,0,0,0,1412,1413,3,52,26,0,1413,1414,5,106,
  	0,0,1414,1415,3,52,26,0,1415,1417,1,0,0,0,1416,1404,1,0,0,0,1416,1408,
  	1,0,0,0,1416,1412,1,0,0,0,1417,279,1,0,0,0,1418,1420,5,119,0,0,1419,1421,
  	3,304,152,0,1420,1419,1,0,0,0,1420,1421,1,0,0,0,1421,1422,1,0,0,0,1422,
  	1423,5,120,0,0,1423,281,1,0,0,0,1424,1426,5,121,0,0,1425,1427,3,286,143,
  	0,1426,1425,1,0,0,0,1426,1427,1,0,0,0,1427,1428,1,0,0,0,1428,1429,5,122,
  	0,0,1429,283,1,0,0,0,1430,1431,7,0,0,0,1431,1432,5,125,0,0,1432,1433,
  	3,52,26,0,1433,285,1,0,0,0,1434,1439,3,284,142,0,1435,1436,5,124,0,0,
  	1436,1438,3,284,142,0,1437,1435,1,0,0,0,1438,1441,1,0,0,0,1439,1437,1,
  	0,0,0,1439,1440,1,0,0,0,1440,1443,1,0,0,0,1441,1439,1,0,0,0,1442,1444,
  	5,124,0,0,1443,1442,1,0,0,0,1443,1444,1,0,0,0,1444,287,1,0,0,0,1445,1446,
  	3,300,150,0,1446,1447,5,127,0,0,1447,1448,3,52,26,0,1448,1449,5,126,0,
  	0,1449,289,1,0,0,0,1450,1455,3,292,146,0,1451,1452,5,124,0,0,1452,1454,
  	3,292,146,0,1453,1451,1,0,0,0,1454,1457,1,0,0,0,1455,1453,1,0,0,0,1455,
  	1456,1,0,0,0,1456,291,1,0,0,0,1457,1455,1,0,0,0,1458,1459,5,128,0,0,1459,
  	1460,5,125,0,0,1460,1461,3,294,147,0,1461,293,1,0,0,0,1462,1465,3,302,
  	151,0,1463,1465,3,296,148,0,1464,1462,1,0,0,0,1464,1463,1,0,0,0,1465,
  	295,1,0,0,0,1466,1468,5,119,0,0,1467,1469,3,298,149,0,1468,1467,1,0,0,
  	0,1468,1469,1,0,0,0,1469,1470,1,0,0,0,1470,1471,5,120,0,0,1471,297,1,
  	0,0,0,1472,1477,3,294,147,0,1473,1474,5,124,0,0,1474,1476,3,294,147,0,
  	1475,1473,1,0,0,0,1476,1479,1,0,0,0,1477,1475,1,0,0,0,1477,1478,1,0,0,
  	0,1478,299,1,0,0,0,1479,1477,1,0,0,0,1480,1485,5,128,0,0,1481,1482,5,
  	123,0,0,1482,1484,5,128,0,0,1483,1481,1,0,0,0,1484,1487,1,0,0,0,1485,
  	1483,1,0,0,0,1485,1486,1,0,0,0,1486,301,1,0,0,0,1487,1485,1,0,0,0,1488,
  	1489,7,13,0,0,1489,303,1,0,0,0,1490,1495,3,52,26,0,1491,1492,5,124,0,
  	0,1492,1494,3,52,26,0,1493,1491,1,0,0,0,1494,1497,1,0,0,0,1495,1493,1,
  	0,0,0,1495,1496,1,0,0,0,1496,305,1,0,0,0,1497,1495,1,0,0,0,1498,1503,
  	5,128,0,0,1499,1500,5,124,0,0,1500,1502,5,128,0,0,1501,1499,1,0,0,0,1502,
  	1505,1,0,0,0,1503,1501,1,0,0,0,1503,1504,1,0,0,0,1504,307,1,0,0,0,1505,
  	1503,1,0,0,0,1506,1507,5,128,0,0,1507,1508,5,127,0,0,1508,1512,3,52,26,
  	0,1509,1512,3,310,155,0,1510,1512,3,52,26,0,1511,1506,1,0,0,0,1511,1509,
  	1,0,0,0,1511,1510,1,0,0,0,1512,309,1,0,0,0,1513,1514,5,128,0,0,1514,1517,
  	5,98,0,0,1515,1518,3,52,26,0,1516,1518,3,216,108,0,1517,1515,1,0,0,0,
  	1517,1516,1,0,0,0,1518,1534,1,0,0,0,1519,1520,5,117,0,0,1520,1521,3,198,
  	99,0,1521,1522,5,118,0,0,1522,1525,5,98,0,0,1523,1526,3,52,26,0,1524,
  	1526,3,216,108,0,1525,1523,1,0,0,0,1525,1524,1,0,0,0,1526,1534,1,0,0,
  	0,1527,1528,3,204,102,0,1528,1531,5,98,0,0,1529,1532,3,52,26,0,1530,1532,
  	3,216,108,0,1531,1529,1,0,0,0,1531,1530,1,0,0,0,1532,1534,1,0,0,0,1533,
  	1513,1,0,0,0,1533,1519,1,0,0,0,1533,1527,1,0,0,0,1534,311,1,0,0,0,1535,
  	1540,3,308,154,0,1536,1537,5,124,0,0,1537,1539,3,308,154,0,1538,1536,
  	1,0,0,0,1539,1542,1,0,0,0,1540,1538,1,0,0,0,1540,1541,1,0,0,0,1541,313,
  	1,0,0,0,1542,1540,1,0,0,0,131,319,324,328,337,365,373,398,406,417,426,
  	434,442,453,468,475,481,490,494,499,505,514,536,542,560,567,575,583,592,
  	599,607,615,623,631,639,645,649,655,662,668,672,686,693,698,713,719,774,
  	793,805,812,821,831,844,855,867,893,899,911,921,925,935,945,955,966,976,
  	1000,1010,1020,1030,1032,1042,1044,1054,1064,1074,1087,1095,1104,1121,
  	1125,1135,1144,1152,1159,1165,1171,1181,1187,1194,1202,1212,1223,1227,
  	1233,1238,1250,1257,1261,1270,1283,1295,1299,1305,1316,1327,1337,1347,
  	1358,1365,1369,1376,1380,1393,1402,1416,1420,1426,1439,1443,1455,1464,
  	1468,1477,1485,1495,1503,1511,1517,1525,1531,1533,1540
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  olangparserParserStaticData = staticData.release();
}

}

OLangParser::OLangParser(TokenStream *input) : OLangParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

OLangParser::OLangParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  OLangParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *olangparserParserStaticData->atn, olangparserParserStaticData->decisionToDFA, olangparserParserStaticData->sharedContextCache, options);
}

OLangParser::~OLangParser() {
  delete _interpreter;
}

const atn::ATN& OLangParser::getATN() const {
  return *olangparserParserStaticData->atn;
}

std::string OLangParser::getGrammarFileName() const {
  return "OLangParser.g4";
}

const std::vector<std::string>& OLangParser::getRuleNames() const {
  return olangparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& OLangParser::getVocabulary() const {
  return olangparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView OLangParser::getSerializedATN() const {
  return olangparserParserStaticData->serializedATN;
}


//----------------- ProgramContext ------------------------------------------------------------------

OLangParser::ProgramContext::ProgramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::StatementListContext* OLangParser::ProgramContext::statementList() {
  return getRuleContext<OLangParser::StatementListContext>(0);
}

tree::TerminalNode* OLangParser::ProgramContext::EOF() {
  return getToken(OLangParser::EOF, 0);
}


size_t OLangParser::ProgramContext::getRuleIndex() const {
  return OLangParser::RuleProgram;
}

void OLangParser::ProgramContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProgram(this);
}

void OLangParser::ProgramContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProgram(this);
}


std::any OLangParser::ProgramContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitProgram(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ProgramContext* OLangParser::program() {
  ProgramContext *_localctx = _tracker.createInstance<ProgramContext>(_ctx, getState());
  enterRule(_localctx, 0, OLangParser::RuleProgram);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(314);
    statementList();
    setState(315);
    match(OLangParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementListContext ------------------------------------------------------------------

OLangParser::StatementListContext::StatementListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::StatementContext *> OLangParser::StatementListContext::statement() {
  return getRuleContexts<OLangParser::StatementContext>();
}

OLangParser::StatementContext* OLangParser::StatementListContext::statement(size_t i) {
  return getRuleContext<OLangParser::StatementContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::StatementListContext::SEMI() {
  return getTokens(OLangParser::SEMI);
}

tree::TerminalNode* OLangParser::StatementListContext::SEMI(size_t i) {
  return getToken(OLangParser::SEMI, i);
}


size_t OLangParser::StatementListContext::getRuleIndex() const {
  return OLangParser::RuleStatementList;
}

void OLangParser::StatementListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatementList(this);
}

void OLangParser::StatementListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatementList(this);
}


std::any OLangParser::StatementListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitStatementList(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::StatementListContext* OLangParser::statementList() {
  StatementListContext *_localctx = _tracker.createInstance<StatementListContext>(_ctx, getState());
  enterRule(_localctx, 2, OLangParser::RuleStatementList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(317);
    statement();
    setState(324);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(319);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == OLangParser::SEMI) {
          setState(318);
          match(OLangParser::SEMI);
        }
        setState(321);
        statement(); 
      }
      setState(326);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx);
    }
    setState(328);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == OLangParser::SEMI) {
      setState(327);
      match(OLangParser::SEMI);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

OLangParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::DeclarationContext* OLangParser::StatementContext::declaration() {
  return getRuleContext<OLangParser::DeclarationContext>(0);
}

OLangParser::AssignmentStatementContext* OLangParser::StatementContext::assignmentStatement() {
  return getRuleContext<OLangParser::AssignmentStatementContext>(0);
}

OLangParser::AnnotationStatementContext* OLangParser::StatementContext::annotationStatement() {
  return getRuleContext<OLangParser::AnnotationStatementContext>(0);
}

OLangParser::ExpressionStatementContext* OLangParser::StatementContext::expressionStatement() {
  return getRuleContext<OLangParser::ExpressionStatementContext>(0);
}

OLangParser::EmitStatementContext* OLangParser::StatementContext::emitStatement() {
  return getRuleContext<OLangParser::EmitStatementContext>(0);
}

OLangParser::SignalStatementContext* OLangParser::StatementContext::signalStatement() {
  return getRuleContext<OLangParser::SignalStatementContext>(0);
}

OLangParser::AssertStatementContext* OLangParser::StatementContext::assertStatement() {
  return getRuleContext<OLangParser::AssertStatementContext>(0);
}


size_t OLangParser::StatementContext::getRuleIndex() const {
  return OLangParser::RuleStatement;
}

void OLangParser::StatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement(this);
}

void OLangParser::StatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement(this);
}


std::any OLangParser::StatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitStatement(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::StatementContext* OLangParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 4, OLangParser::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(337);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(330);
      declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(331);
      assignmentStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(332);
      annotationStatement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(333);
      expressionStatement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(334);
      emitStatement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(335);
      signalStatement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(336);
      assertStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionStatementContext ------------------------------------------------------------------

OLangParser::ExpressionStatementContext::ExpressionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::ExpressionContext* OLangParser::ExpressionStatementContext::expression() {
  return getRuleContext<OLangParser::ExpressionContext>(0);
}

tree::TerminalNode* OLangParser::ExpressionStatementContext::SEMI() {
  return getToken(OLangParser::SEMI, 0);
}


size_t OLangParser::ExpressionStatementContext::getRuleIndex() const {
  return OLangParser::RuleExpressionStatement;
}

void OLangParser::ExpressionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionStatement(this);
}

void OLangParser::ExpressionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionStatement(this);
}


std::any OLangParser::ExpressionStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitExpressionStatement(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ExpressionStatementContext* OLangParser::expressionStatement() {
  ExpressionStatementContext *_localctx = _tracker.createInstance<ExpressionStatementContext>(_ctx, getState());
  enterRule(_localctx, 6, OLangParser::RuleExpressionStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(339);
    expression();
    setState(340);
    match(OLangParser::SEMI);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EmitStatementContext ------------------------------------------------------------------

OLangParser::EmitStatementContext::EmitStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::EmitStatementContext::EMIT() {
  return getToken(OLangParser::EMIT, 0);
}

OLangParser::ExpressionContext* OLangParser::EmitStatementContext::expression() {
  return getRuleContext<OLangParser::ExpressionContext>(0);
}

tree::TerminalNode* OLangParser::EmitStatementContext::SEMI() {
  return getToken(OLangParser::SEMI, 0);
}


size_t OLangParser::EmitStatementContext::getRuleIndex() const {
  return OLangParser::RuleEmitStatement;
}

void OLangParser::EmitStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEmitStatement(this);
}

void OLangParser::EmitStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEmitStatement(this);
}


std::any OLangParser::EmitStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitEmitStatement(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::EmitStatementContext* OLangParser::emitStatement() {
  EmitStatementContext *_localctx = _tracker.createInstance<EmitStatementContext>(_ctx, getState());
  enterRule(_localctx, 8, OLangParser::RuleEmitStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(342);
    match(OLangParser::EMIT);
    setState(343);
    expression();
    setState(344);
    match(OLangParser::SEMI);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignalStatementContext ------------------------------------------------------------------

OLangParser::SignalStatementContext::SignalStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::SignalStatementContext::SIGNAL() {
  return getToken(OLangParser::SIGNAL, 0);
}

OLangParser::ExpressionContext* OLangParser::SignalStatementContext::expression() {
  return getRuleContext<OLangParser::ExpressionContext>(0);
}

tree::TerminalNode* OLangParser::SignalStatementContext::SEMI() {
  return getToken(OLangParser::SEMI, 0);
}


size_t OLangParser::SignalStatementContext::getRuleIndex() const {
  return OLangParser::RuleSignalStatement;
}

void OLangParser::SignalStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSignalStatement(this);
}

void OLangParser::SignalStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSignalStatement(this);
}


std::any OLangParser::SignalStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitSignalStatement(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::SignalStatementContext* OLangParser::signalStatement() {
  SignalStatementContext *_localctx = _tracker.createInstance<SignalStatementContext>(_ctx, getState());
  enterRule(_localctx, 10, OLangParser::RuleSignalStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(346);
    match(OLangParser::SIGNAL);
    setState(347);
    expression();
    setState(348);
    match(OLangParser::SEMI);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssertStatementContext ------------------------------------------------------------------

OLangParser::AssertStatementContext::AssertStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::AssertStatementContext::ASSERT() {
  return getToken(OLangParser::ASSERT, 0);
}

tree::TerminalNode* OLangParser::AssertStatementContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

OLangParser::ExpressionContext* OLangParser::AssertStatementContext::expression() {
  return getRuleContext<OLangParser::ExpressionContext>(0);
}

tree::TerminalNode* OLangParser::AssertStatementContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}

tree::TerminalNode* OLangParser::AssertStatementContext::SEMI() {
  return getToken(OLangParser::SEMI, 0);
}


size_t OLangParser::AssertStatementContext::getRuleIndex() const {
  return OLangParser::RuleAssertStatement;
}

void OLangParser::AssertStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssertStatement(this);
}

void OLangParser::AssertStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssertStatement(this);
}


std::any OLangParser::AssertStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitAssertStatement(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::AssertStatementContext* OLangParser::assertStatement() {
  AssertStatementContext *_localctx = _tracker.createInstance<AssertStatementContext>(_ctx, getState());
  enterRule(_localctx, 12, OLangParser::RuleAssertStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(350);
    match(OLangParser::ASSERT);
    setState(351);
    match(OLangParser::LPAREN);
    setState(352);
    expression();
    setState(353);
    match(OLangParser::RPAREN);
    setState(354);
    match(OLangParser::SEMI);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclarationContext ------------------------------------------------------------------

OLangParser::DeclarationContext::DeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::ImportDeclarationContext* OLangParser::DeclarationContext::importDeclaration() {
  return getRuleContext<OLangParser::ImportDeclarationContext>(0);
}

OLangParser::BindingDeclarationContext* OLangParser::DeclarationContext::bindingDeclaration() {
  return getRuleContext<OLangParser::BindingDeclarationContext>(0);
}

OLangParser::FunctionDeclarationContext* OLangParser::DeclarationContext::functionDeclaration() {
  return getRuleContext<OLangParser::FunctionDeclarationContext>(0);
}

OLangParser::PipelineDeclarationContext* OLangParser::DeclarationContext::pipelineDeclaration() {
  return getRuleContext<OLangParser::PipelineDeclarationContext>(0);
}

OLangParser::AnnotationTypeDeclarationContext* OLangParser::DeclarationContext::annotationTypeDeclaration() {
  return getRuleContext<OLangParser::AnnotationTypeDeclarationContext>(0);
}

OLangParser::TypeDeclarationContext* OLangParser::DeclarationContext::typeDeclaration() {
  return getRuleContext<OLangParser::TypeDeclarationContext>(0);
}

OLangParser::AgentDeclarationContext* OLangParser::DeclarationContext::agentDeclaration() {
  return getRuleContext<OLangParser::AgentDeclarationContext>(0);
}

OLangParser::SolverDeclarationContext* OLangParser::DeclarationContext::solverDeclaration() {
  return getRuleContext<OLangParser::SolverDeclarationContext>(0);
}

OLangParser::ProofDeclarationContext* OLangParser::DeclarationContext::proofDeclaration() {
  return getRuleContext<OLangParser::ProofDeclarationContext>(0);
}


size_t OLangParser::DeclarationContext::getRuleIndex() const {
  return OLangParser::RuleDeclaration;
}

void OLangParser::DeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclaration(this);
}

void OLangParser::DeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclaration(this);
}


std::any OLangParser::DeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitDeclaration(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::DeclarationContext* OLangParser::declaration() {
  DeclarationContext *_localctx = _tracker.createInstance<DeclarationContext>(_ctx, getState());
  enterRule(_localctx, 14, OLangParser::RuleDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(365);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case OLangParser::IMPORT:
      case OLangParser::FROM: {
        enterOuterAlt(_localctx, 1);
        setState(356);
        importDeclaration();
        break;
      }

      case OLangParser::LET: {
        enterOuterAlt(_localctx, 2);
        setState(357);
        bindingDeclaration();
        break;
      }

      case OLangParser::DEF: {
        enterOuterAlt(_localctx, 3);
        setState(358);
        functionDeclaration();
        break;
      }

      case OLangParser::ID: {
        enterOuterAlt(_localctx, 4);
        setState(359);
        pipelineDeclaration();
        break;
      }

      case OLangParser::ANNOTATION: {
        enterOuterAlt(_localctx, 5);
        setState(360);
        annotationTypeDeclaration();
        break;
      }

      case OLangParser::TYPE: {
        enterOuterAlt(_localctx, 6);
        setState(361);
        typeDeclaration();
        break;
      }

      case OLangParser::AGENT: {
        enterOuterAlt(_localctx, 7);
        setState(362);
        agentDeclaration();
        break;
      }

      case OLangParser::SOLVER: {
        enterOuterAlt(_localctx, 8);
        setState(363);
        solverDeclaration();
        break;
      }

      case OLangParser::PROOF: {
        enterOuterAlt(_localctx, 9);
        setState(364);
        proofDeclaration();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AgentDeclarationContext ------------------------------------------------------------------

OLangParser::AgentDeclarationContext::AgentDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::AgentDeclarationContext::AGENT() {
  return getToken(OLangParser::AGENT, 0);
}

tree::TerminalNode* OLangParser::AgentDeclarationContext::ID() {
  return getToken(OLangParser::ID, 0);
}

tree::TerminalNode* OLangParser::AgentDeclarationContext::LCURLY() {
  return getToken(OLangParser::LCURLY, 0);
}

tree::TerminalNode* OLangParser::AgentDeclarationContext::RCURLY() {
  return getToken(OLangParser::RCURLY, 0);
}

std::vector<OLangParser::AgentMemberContext *> OLangParser::AgentDeclarationContext::agentMember() {
  return getRuleContexts<OLangParser::AgentMemberContext>();
}

OLangParser::AgentMemberContext* OLangParser::AgentDeclarationContext::agentMember(size_t i) {
  return getRuleContext<OLangParser::AgentMemberContext>(i);
}


size_t OLangParser::AgentDeclarationContext::getRuleIndex() const {
  return OLangParser::RuleAgentDeclaration;
}

void OLangParser::AgentDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAgentDeclaration(this);
}

void OLangParser::AgentDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAgentDeclaration(this);
}


std::any OLangParser::AgentDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitAgentDeclaration(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::AgentDeclarationContext* OLangParser::agentDeclaration() {
  AgentDeclarationContext *_localctx = _tracker.createInstance<AgentDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 16, OLangParser::RuleAgentDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(367);
    match(OLangParser::AGENT);
    setState(368);
    match(OLangParser::ID);
    setState(369);
    match(OLangParser::LCURLY);
    setState(373);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 13020267854) != 0 || _la == OLangParser::ID) {
      setState(370);
      agentMember();
      setState(375);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(376);
    match(OLangParser::RCURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AgentMemberContext ------------------------------------------------------------------

OLangParser::AgentMemberContext::AgentMemberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::AgentMemberContext::CAPABILITY() {
  return getToken(OLangParser::CAPABILITY, 0);
}

OLangParser::IdListContext* OLangParser::AgentMemberContext::idList() {
  return getRuleContext<OLangParser::IdListContext>(0);
}

tree::TerminalNode* OLangParser::AgentMemberContext::SEMI() {
  return getToken(OLangParser::SEMI, 0);
}

tree::TerminalNode* OLangParser::AgentMemberContext::STREAM() {
  return getToken(OLangParser::STREAM, 0);
}

tree::TerminalNode* OLangParser::AgentMemberContext::ID() {
  return getToken(OLangParser::ID, 0);
}

tree::TerminalNode* OLangParser::AgentMemberContext::COLON() {
  return getToken(OLangParser::COLON, 0);
}

OLangParser::TypeContext* OLangParser::AgentMemberContext::type() {
  return getRuleContext<OLangParser::TypeContext>(0);
}

tree::TerminalNode* OLangParser::AgentMemberContext::RULE() {
  return getToken(OLangParser::RULE, 0);
}

tree::TerminalNode* OLangParser::AgentMemberContext::LCURLY() {
  return getToken(OLangParser::LCURLY, 0);
}

tree::TerminalNode* OLangParser::AgentMemberContext::WHEN() {
  return getToken(OLangParser::WHEN, 0);
}

OLangParser::ExpressionContext* OLangParser::AgentMemberContext::expression() {
  return getRuleContext<OLangParser::ExpressionContext>(0);
}

tree::TerminalNode* OLangParser::AgentMemberContext::ARROW() {
  return getToken(OLangParser::ARROW, 0);
}

OLangParser::BlockExpressionContext* OLangParser::AgentMemberContext::blockExpression() {
  return getRuleContext<OLangParser::BlockExpressionContext>(0);
}

tree::TerminalNode* OLangParser::AgentMemberContext::RCURLY() {
  return getToken(OLangParser::RCURLY, 0);
}

tree::TerminalNode* OLangParser::AgentMemberContext::STRING() {
  return getToken(OLangParser::STRING, 0);
}

OLangParser::DeclarationContext* OLangParser::AgentMemberContext::declaration() {
  return getRuleContext<OLangParser::DeclarationContext>(0);
}


size_t OLangParser::AgentMemberContext::getRuleIndex() const {
  return OLangParser::RuleAgentMember;
}

void OLangParser::AgentMemberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAgentMember(this);
}

void OLangParser::AgentMemberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAgentMember(this);
}


std::any OLangParser::AgentMemberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitAgentMember(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::AgentMemberContext* OLangParser::agentMember() {
  AgentMemberContext *_localctx = _tracker.createInstance<AgentMemberContext>(_ctx, getState());
  enterRule(_localctx, 18, OLangParser::RuleAgentMember);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(398);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case OLangParser::CAPABILITY: {
        enterOuterAlt(_localctx, 1);
        setState(378);
        match(OLangParser::CAPABILITY);
        setState(379);
        idList();
        setState(380);
        match(OLangParser::SEMI);
        break;
      }

      case OLangParser::STREAM: {
        enterOuterAlt(_localctx, 2);
        setState(382);
        match(OLangParser::STREAM);
        setState(383);
        match(OLangParser::ID);
        setState(384);
        match(OLangParser::COLON);
        setState(385);
        type();
        setState(386);
        match(OLangParser::SEMI);
        break;
      }

      case OLangParser::RULE: {
        enterOuterAlt(_localctx, 3);
        setState(388);
        match(OLangParser::RULE);
        setState(389);
        _la = _input->LA(1);
        if (!(_la == OLangParser::STRING

        || _la == OLangParser::ID)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(390);
        match(OLangParser::LCURLY);
        setState(391);
        match(OLangParser::WHEN);
        setState(392);
        expression();
        setState(393);
        match(OLangParser::ARROW);
        setState(394);
        blockExpression();
        setState(395);
        match(OLangParser::RCURLY);
        break;
      }

      case OLangParser::IMPORT:
      case OLangParser::FROM:
      case OLangParser::LET:
      case OLangParser::TYPE:
      case OLangParser::ANNOTATION:
      case OLangParser::DEF:
      case OLangParser::AGENT:
      case OLangParser::PROOF:
      case OLangParser::SOLVER:
      case OLangParser::ID: {
        enterOuterAlt(_localctx, 4);
        setState(397);
        declaration();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SolverDeclarationContext ------------------------------------------------------------------

OLangParser::SolverDeclarationContext::SolverDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::SolverDeclarationContext::SOLVER() {
  return getToken(OLangParser::SOLVER, 0);
}

tree::TerminalNode* OLangParser::SolverDeclarationContext::ID() {
  return getToken(OLangParser::ID, 0);
}

tree::TerminalNode* OLangParser::SolverDeclarationContext::LCURLY() {
  return getToken(OLangParser::LCURLY, 0);
}

tree::TerminalNode* OLangParser::SolverDeclarationContext::RCURLY() {
  return getToken(OLangParser::RCURLY, 0);
}

std::vector<OLangParser::SolverMemberContext *> OLangParser::SolverDeclarationContext::solverMember() {
  return getRuleContexts<OLangParser::SolverMemberContext>();
}

OLangParser::SolverMemberContext* OLangParser::SolverDeclarationContext::solverMember(size_t i) {
  return getRuleContext<OLangParser::SolverMemberContext>(i);
}


size_t OLangParser::SolverDeclarationContext::getRuleIndex() const {
  return OLangParser::RuleSolverDeclaration;
}

void OLangParser::SolverDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSolverDeclaration(this);
}

void OLangParser::SolverDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSolverDeclaration(this);
}


std::any OLangParser::SolverDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitSolverDeclaration(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::SolverDeclarationContext* OLangParser::solverDeclaration() {
  SolverDeclarationContext *_localctx = _tracker.createInstance<SolverDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 20, OLangParser::RuleSolverDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(400);
    match(OLangParser::SOLVER);
    setState(401);
    match(OLangParser::ID);
    setState(402);
    match(OLangParser::LCURLY);
    setState(406);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4026531840) != 0) {
      setState(403);
      solverMember();
      setState(408);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(409);
    match(OLangParser::RCURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SolverMemberContext ------------------------------------------------------------------

OLangParser::SolverMemberContext::SolverMemberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::SolverMemberContext::VARIABLE() {
  return getToken(OLangParser::VARIABLE, 0);
}

tree::TerminalNode* OLangParser::SolverMemberContext::ID() {
  return getToken(OLangParser::ID, 0);
}

tree::TerminalNode* OLangParser::SolverMemberContext::COLON() {
  return getToken(OLangParser::COLON, 0);
}

OLangParser::TypeContext* OLangParser::SolverMemberContext::type() {
  return getRuleContext<OLangParser::TypeContext>(0);
}

tree::TerminalNode* OLangParser::SolverMemberContext::SEMI() {
  return getToken(OLangParser::SEMI, 0);
}

tree::TerminalNode* OLangParser::SolverMemberContext::IN() {
  return getToken(OLangParser::IN, 0);
}

OLangParser::ExpressionContext* OLangParser::SolverMemberContext::expression() {
  return getRuleContext<OLangParser::ExpressionContext>(0);
}

tree::TerminalNode* OLangParser::SolverMemberContext::SATISFY() {
  return getToken(OLangParser::SATISFY, 0);
}

tree::TerminalNode* OLangParser::SolverMemberContext::LCURLY() {
  return getToken(OLangParser::LCURLY, 0);
}

tree::TerminalNode* OLangParser::SolverMemberContext::RCURLY() {
  return getToken(OLangParser::RCURLY, 0);
}

std::vector<OLangParser::ExpressionStatementContext *> OLangParser::SolverMemberContext::expressionStatement() {
  return getRuleContexts<OLangParser::ExpressionStatementContext>();
}

OLangParser::ExpressionStatementContext* OLangParser::SolverMemberContext::expressionStatement(size_t i) {
  return getRuleContext<OLangParser::ExpressionStatementContext>(i);
}

tree::TerminalNode* OLangParser::SolverMemberContext::MINIMIZE() {
  return getToken(OLangParser::MINIMIZE, 0);
}

tree::TerminalNode* OLangParser::SolverMemberContext::MAXIMIZE() {
  return getToken(OLangParser::MAXIMIZE, 0);
}


size_t OLangParser::SolverMemberContext::getRuleIndex() const {
  return OLangParser::RuleSolverMember;
}

void OLangParser::SolverMemberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSolverMember(this);
}

void OLangParser::SolverMemberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSolverMember(this);
}


std::any OLangParser::SolverMemberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitSolverMember(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::SolverMemberContext* OLangParser::solverMember() {
  SolverMemberContext *_localctx = _tracker.createInstance<SolverMemberContext>(_ctx, getState());
  enterRule(_localctx, 22, OLangParser::RuleSolverMember);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(434);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case OLangParser::VARIABLE: {
        enterOuterAlt(_localctx, 1);
        setState(411);
        match(OLangParser::VARIABLE);
        setState(412);
        match(OLangParser::ID);
        setState(413);
        match(OLangParser::COLON);
        setState(414);
        type();
        setState(417);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == OLangParser::IN) {
          setState(415);
          match(OLangParser::IN);
          setState(416);
          expression();
        }
        setState(419);
        match(OLangParser::SEMI);
        break;
      }

      case OLangParser::SATISFY: {
        enterOuterAlt(_localctx, 2);
        setState(421);
        match(OLangParser::SATISFY);
        setState(422);
        match(OLangParser::LCURLY);
        setState(426);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 2233785277761980416) != 0 || (((_la - 70) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 70)) & 291324401880665089) != 0) {
          setState(423);
          expressionStatement();
          setState(428);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(429);
        match(OLangParser::RCURLY);
        break;
      }

      case OLangParser::MINIMIZE:
      case OLangParser::MAXIMIZE: {
        enterOuterAlt(_localctx, 3);
        setState(430);
        _la = _input->LA(1);
        if (!(_la == OLangParser::MINIMIZE

        || _la == OLangParser::MAXIMIZE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(431);
        expression();
        setState(432);
        match(OLangParser::SEMI);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProofDeclarationContext ------------------------------------------------------------------

OLangParser::ProofDeclarationContext::ProofDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::ProofDeclarationContext::PROOF() {
  return getToken(OLangParser::PROOF, 0);
}

tree::TerminalNode* OLangParser::ProofDeclarationContext::ID() {
  return getToken(OLangParser::ID, 0);
}

tree::TerminalNode* OLangParser::ProofDeclarationContext::LCURLY() {
  return getToken(OLangParser::LCURLY, 0);
}

tree::TerminalNode* OLangParser::ProofDeclarationContext::RCURLY() {
  return getToken(OLangParser::RCURLY, 0);
}

std::vector<OLangParser::InvariantDeclarationContext *> OLangParser::ProofDeclarationContext::invariantDeclaration() {
  return getRuleContexts<OLangParser::InvariantDeclarationContext>();
}

OLangParser::InvariantDeclarationContext* OLangParser::ProofDeclarationContext::invariantDeclaration(size_t i) {
  return getRuleContext<OLangParser::InvariantDeclarationContext>(i);
}


size_t OLangParser::ProofDeclarationContext::getRuleIndex() const {
  return OLangParser::RuleProofDeclaration;
}

void OLangParser::ProofDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProofDeclaration(this);
}

void OLangParser::ProofDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProofDeclaration(this);
}


std::any OLangParser::ProofDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitProofDeclaration(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ProofDeclarationContext* OLangParser::proofDeclaration() {
  ProofDeclarationContext *_localctx = _tracker.createInstance<ProofDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 24, OLangParser::RuleProofDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(436);
    match(OLangParser::PROOF);
    setState(437);
    match(OLangParser::ID);
    setState(438);
    match(OLangParser::LCURLY);
    setState(442);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == OLangParser::INVARIANT) {
      setState(439);
      invariantDeclaration();
      setState(444);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(445);
    match(OLangParser::RCURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InvariantDeclarationContext ------------------------------------------------------------------

OLangParser::InvariantDeclarationContext::InvariantDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::InvariantDeclarationContext::INVARIANT() {
  return getToken(OLangParser::INVARIANT, 0);
}

tree::TerminalNode* OLangParser::InvariantDeclarationContext::ID() {
  return getToken(OLangParser::ID, 0);
}

tree::TerminalNode* OLangParser::InvariantDeclarationContext::LCURLY() {
  return getToken(OLangParser::LCURLY, 0);
}

tree::TerminalNode* OLangParser::InvariantDeclarationContext::RCURLY() {
  return getToken(OLangParser::RCURLY, 0);
}

std::vector<OLangParser::ExpressionStatementContext *> OLangParser::InvariantDeclarationContext::expressionStatement() {
  return getRuleContexts<OLangParser::ExpressionStatementContext>();
}

OLangParser::ExpressionStatementContext* OLangParser::InvariantDeclarationContext::expressionStatement(size_t i) {
  return getRuleContext<OLangParser::ExpressionStatementContext>(i);
}


size_t OLangParser::InvariantDeclarationContext::getRuleIndex() const {
  return OLangParser::RuleInvariantDeclaration;
}

void OLangParser::InvariantDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInvariantDeclaration(this);
}

void OLangParser::InvariantDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInvariantDeclaration(this);
}


std::any OLangParser::InvariantDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitInvariantDeclaration(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::InvariantDeclarationContext* OLangParser::invariantDeclaration() {
  InvariantDeclarationContext *_localctx = _tracker.createInstance<InvariantDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 26, OLangParser::RuleInvariantDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(447);
    match(OLangParser::INVARIANT);
    setState(448);
    match(OLangParser::ID);
    setState(449);
    match(OLangParser::LCURLY);
    setState(453);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2233785277761980416) != 0 || (((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & 291324401880665089) != 0) {
      setState(450);
      expressionStatement();
      setState(455);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(456);
    match(OLangParser::RCURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportDeclarationContext ------------------------------------------------------------------

OLangParser::ImportDeclarationContext::ImportDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::ImportDeclarationContext::IMPORT() {
  return getToken(OLangParser::IMPORT, 0);
}

OLangParser::DottedAsNamesListContext* OLangParser::ImportDeclarationContext::dottedAsNamesList() {
  return getRuleContext<OLangParser::DottedAsNamesListContext>(0);
}

tree::TerminalNode* OLangParser::ImportDeclarationContext::SEMI() {
  return getToken(OLangParser::SEMI, 0);
}

tree::TerminalNode* OLangParser::ImportDeclarationContext::FROM() {
  return getToken(OLangParser::FROM, 0);
}

OLangParser::RelativeModuleContext* OLangParser::ImportDeclarationContext::relativeModule() {
  return getRuleContext<OLangParser::RelativeModuleContext>(0);
}

OLangParser::ImportTargetsContext* OLangParser::ImportDeclarationContext::importTargets() {
  return getRuleContext<OLangParser::ImportTargetsContext>(0);
}


size_t OLangParser::ImportDeclarationContext::getRuleIndex() const {
  return OLangParser::RuleImportDeclaration;
}

void OLangParser::ImportDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportDeclaration(this);
}

void OLangParser::ImportDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportDeclaration(this);
}


std::any OLangParser::ImportDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitImportDeclaration(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ImportDeclarationContext* OLangParser::importDeclaration() {
  ImportDeclarationContext *_localctx = _tracker.createInstance<ImportDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 28, OLangParser::RuleImportDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(468);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case OLangParser::IMPORT: {
        enterOuterAlt(_localctx, 1);
        setState(458);
        match(OLangParser::IMPORT);
        setState(459);
        dottedAsNamesList();
        setState(460);
        match(OLangParser::SEMI);
        break;
      }

      case OLangParser::FROM: {
        enterOuterAlt(_localctx, 2);
        setState(462);
        match(OLangParser::FROM);
        setState(463);
        relativeModule();
        setState(464);
        match(OLangParser::IMPORT);
        setState(465);
        importTargets();
        setState(466);
        match(OLangParser::SEMI);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DottedAsNamesListContext ------------------------------------------------------------------

OLangParser::DottedAsNamesListContext::DottedAsNamesListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::DottedAsNamesContext *> OLangParser::DottedAsNamesListContext::dottedAsNames() {
  return getRuleContexts<OLangParser::DottedAsNamesContext>();
}

OLangParser::DottedAsNamesContext* OLangParser::DottedAsNamesListContext::dottedAsNames(size_t i) {
  return getRuleContext<OLangParser::DottedAsNamesContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::DottedAsNamesListContext::COMMA() {
  return getTokens(OLangParser::COMMA);
}

tree::TerminalNode* OLangParser::DottedAsNamesListContext::COMMA(size_t i) {
  return getToken(OLangParser::COMMA, i);
}


size_t OLangParser::DottedAsNamesListContext::getRuleIndex() const {
  return OLangParser::RuleDottedAsNamesList;
}

void OLangParser::DottedAsNamesListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDottedAsNamesList(this);
}

void OLangParser::DottedAsNamesListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDottedAsNamesList(this);
}


std::any OLangParser::DottedAsNamesListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitDottedAsNamesList(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::DottedAsNamesListContext* OLangParser::dottedAsNamesList() {
  DottedAsNamesListContext *_localctx = _tracker.createInstance<DottedAsNamesListContext>(_ctx, getState());
  enterRule(_localctx, 30, OLangParser::RuleDottedAsNamesList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(470);
    dottedAsNames();
    setState(475);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == OLangParser::COMMA) {
      setState(471);
      match(OLangParser::COMMA);
      setState(472);
      dottedAsNames();
      setState(477);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DottedAsNamesContext ------------------------------------------------------------------

OLangParser::DottedAsNamesContext::DottedAsNamesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::QualifiedNameContext* OLangParser::DottedAsNamesContext::qualifiedName() {
  return getRuleContext<OLangParser::QualifiedNameContext>(0);
}

tree::TerminalNode* OLangParser::DottedAsNamesContext::AS() {
  return getToken(OLangParser::AS, 0);
}

tree::TerminalNode* OLangParser::DottedAsNamesContext::ID() {
  return getToken(OLangParser::ID, 0);
}


size_t OLangParser::DottedAsNamesContext::getRuleIndex() const {
  return OLangParser::RuleDottedAsNames;
}

void OLangParser::DottedAsNamesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDottedAsNames(this);
}

void OLangParser::DottedAsNamesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDottedAsNames(this);
}


std::any OLangParser::DottedAsNamesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitDottedAsNames(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::DottedAsNamesContext* OLangParser::dottedAsNames() {
  DottedAsNamesContext *_localctx = _tracker.createInstance<DottedAsNamesContext>(_ctx, getState());
  enterRule(_localctx, 32, OLangParser::RuleDottedAsNames);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(478);
    qualifiedName();
    setState(481);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == OLangParser::AS) {
      setState(479);
      match(OLangParser::AS);
      setState(480);
      match(OLangParser::ID);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelativeModuleContext ------------------------------------------------------------------

OLangParser::RelativeModuleContext::RelativeModuleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::QualifiedNameContext* OLangParser::RelativeModuleContext::qualifiedName() {
  return getRuleContext<OLangParser::QualifiedNameContext>(0);
}


size_t OLangParser::RelativeModuleContext::getRuleIndex() const {
  return OLangParser::RuleRelativeModule;
}

void OLangParser::RelativeModuleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelativeModule(this);
}

void OLangParser::RelativeModuleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelativeModule(this);
}


std::any OLangParser::RelativeModuleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitRelativeModule(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::RelativeModuleContext* OLangParser::relativeModule() {
  RelativeModuleContext *_localctx = _tracker.createInstance<RelativeModuleContext>(_ctx, getState());
  enterRule(_localctx, 34, OLangParser::RuleRelativeModule);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(483);
    qualifiedName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportTargetsContext ------------------------------------------------------------------

OLangParser::ImportTargetsContext::ImportTargetsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::ImportAsNamesContext *> OLangParser::ImportTargetsContext::importAsNames() {
  return getRuleContexts<OLangParser::ImportAsNamesContext>();
}

OLangParser::ImportAsNamesContext* OLangParser::ImportTargetsContext::importAsNames(size_t i) {
  return getRuleContext<OLangParser::ImportAsNamesContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::ImportTargetsContext::COMMA() {
  return getTokens(OLangParser::COMMA);
}

tree::TerminalNode* OLangParser::ImportTargetsContext::COMMA(size_t i) {
  return getToken(OLangParser::COMMA, i);
}

tree::TerminalNode* OLangParser::ImportTargetsContext::MUL() {
  return getToken(OLangParser::MUL, 0);
}


size_t OLangParser::ImportTargetsContext::getRuleIndex() const {
  return OLangParser::RuleImportTargets;
}

void OLangParser::ImportTargetsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportTargets(this);
}

void OLangParser::ImportTargetsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportTargets(this);
}


std::any OLangParser::ImportTargetsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitImportTargets(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ImportTargetsContext* OLangParser::importTargets() {
  ImportTargetsContext *_localctx = _tracker.createInstance<ImportTargetsContext>(_ctx, getState());
  enterRule(_localctx, 36, OLangParser::RuleImportTargets);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(494);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case OLangParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(485);
        importAsNames();
        setState(490);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == OLangParser::COMMA) {
          setState(486);
          match(OLangParser::COMMA);
          setState(487);
          importAsNames();
          setState(492);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case OLangParser::MUL: {
        enterOuterAlt(_localctx, 2);
        setState(493);
        match(OLangParser::MUL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportAsNamesContext ------------------------------------------------------------------

OLangParser::ImportAsNamesContext::ImportAsNamesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> OLangParser::ImportAsNamesContext::ID() {
  return getTokens(OLangParser::ID);
}

tree::TerminalNode* OLangParser::ImportAsNamesContext::ID(size_t i) {
  return getToken(OLangParser::ID, i);
}

tree::TerminalNode* OLangParser::ImportAsNamesContext::AS() {
  return getToken(OLangParser::AS, 0);
}


size_t OLangParser::ImportAsNamesContext::getRuleIndex() const {
  return OLangParser::RuleImportAsNames;
}

void OLangParser::ImportAsNamesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportAsNames(this);
}

void OLangParser::ImportAsNamesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportAsNames(this);
}


std::any OLangParser::ImportAsNamesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitImportAsNames(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ImportAsNamesContext* OLangParser::importAsNames() {
  ImportAsNamesContext *_localctx = _tracker.createInstance<ImportAsNamesContext>(_ctx, getState());
  enterRule(_localctx, 38, OLangParser::RuleImportAsNames);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(496);
    match(OLangParser::ID);
    setState(499);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == OLangParser::AS) {
      setState(497);
      match(OLangParser::AS);
      setState(498);
      match(OLangParser::ID);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BindingDeclarationContext ------------------------------------------------------------------

OLangParser::BindingDeclarationContext::BindingDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::BindingDeclarationContext::LET() {
  return getToken(OLangParser::LET, 0);
}

tree::TerminalNode* OLangParser::BindingDeclarationContext::ID() {
  return getToken(OLangParser::ID, 0);
}

tree::TerminalNode* OLangParser::BindingDeclarationContext::EQUALS() {
  return getToken(OLangParser::EQUALS, 0);
}

OLangParser::ExpressionContext* OLangParser::BindingDeclarationContext::expression() {
  return getRuleContext<OLangParser::ExpressionContext>(0);
}

tree::TerminalNode* OLangParser::BindingDeclarationContext::COLON() {
  return getToken(OLangParser::COLON, 0);
}

OLangParser::TypeContext* OLangParser::BindingDeclarationContext::type() {
  return getRuleContext<OLangParser::TypeContext>(0);
}


size_t OLangParser::BindingDeclarationContext::getRuleIndex() const {
  return OLangParser::RuleBindingDeclaration;
}

void OLangParser::BindingDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBindingDeclaration(this);
}

void OLangParser::BindingDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBindingDeclaration(this);
}


std::any OLangParser::BindingDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitBindingDeclaration(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::BindingDeclarationContext* OLangParser::bindingDeclaration() {
  BindingDeclarationContext *_localctx = _tracker.createInstance<BindingDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 40, OLangParser::RuleBindingDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(501);
    match(OLangParser::LET);
    setState(502);
    match(OLangParser::ID);
    setState(505);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == OLangParser::COLON) {
      setState(503);
      match(OLangParser::COLON);
      setState(504);
      type();
    }
    setState(507);
    match(OLangParser::EQUALS);
    setState(508);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionDeclarationContext ------------------------------------------------------------------

OLangParser::FunctionDeclarationContext::FunctionDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::FunctionDeclarationContext::DEF() {
  return getToken(OLangParser::DEF, 0);
}

tree::TerminalNode* OLangParser::FunctionDeclarationContext::ID() {
  return getToken(OLangParser::ID, 0);
}

tree::TerminalNode* OLangParser::FunctionDeclarationContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

tree::TerminalNode* OLangParser::FunctionDeclarationContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}

tree::TerminalNode* OLangParser::FunctionDeclarationContext::ARROW() {
  return getToken(OLangParser::ARROW, 0);
}

OLangParser::TypeContext* OLangParser::FunctionDeclarationContext::type() {
  return getRuleContext<OLangParser::TypeContext>(0);
}

tree::TerminalNode* OLangParser::FunctionDeclarationContext::EQUALS() {
  return getToken(OLangParser::EQUALS, 0);
}

OLangParser::ExpressionContext* OLangParser::FunctionDeclarationContext::expression() {
  return getRuleContext<OLangParser::ExpressionContext>(0);
}

OLangParser::TypedParameterListContext* OLangParser::FunctionDeclarationContext::typedParameterList() {
  return getRuleContext<OLangParser::TypedParameterListContext>(0);
}


size_t OLangParser::FunctionDeclarationContext::getRuleIndex() const {
  return OLangParser::RuleFunctionDeclaration;
}

void OLangParser::FunctionDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionDeclaration(this);
}

void OLangParser::FunctionDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionDeclaration(this);
}


std::any OLangParser::FunctionDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitFunctionDeclaration(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::FunctionDeclarationContext* OLangParser::functionDeclaration() {
  FunctionDeclarationContext *_localctx = _tracker.createInstance<FunctionDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 42, OLangParser::RuleFunctionDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(510);
    match(OLangParser::DEF);
    setState(511);
    match(OLangParser::ID);
    setState(512);
    match(OLangParser::LPAREN);
    setState(514);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == OLangParser::ID) {
      setState(513);
      typedParameterList();
    }
    setState(516);
    match(OLangParser::RPAREN);
    setState(517);
    match(OLangParser::ARROW);
    setState(518);
    type();
    setState(519);
    match(OLangParser::EQUALS);
    setState(520);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PipelineDeclarationContext ------------------------------------------------------------------

OLangParser::PipelineDeclarationContext::PipelineDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::PipelineDeclarationContext::ID() {
  return getToken(OLangParser::ID, 0);
}

tree::TerminalNode* OLangParser::PipelineDeclarationContext::COLON() {
  return getToken(OLangParser::COLON, 0);
}

tree::TerminalNode* OLangParser::PipelineDeclarationContext::PIPELINE_TYPE() {
  return getToken(OLangParser::PIPELINE_TYPE, 0);
}

tree::TerminalNode* OLangParser::PipelineDeclarationContext::LT() {
  return getToken(OLangParser::LT, 0);
}

std::vector<OLangParser::TypeContext *> OLangParser::PipelineDeclarationContext::type() {
  return getRuleContexts<OLangParser::TypeContext>();
}

OLangParser::TypeContext* OLangParser::PipelineDeclarationContext::type(size_t i) {
  return getRuleContext<OLangParser::TypeContext>(i);
}

tree::TerminalNode* OLangParser::PipelineDeclarationContext::ARROW() {
  return getToken(OLangParser::ARROW, 0);
}

tree::TerminalNode* OLangParser::PipelineDeclarationContext::GT() {
  return getToken(OLangParser::GT, 0);
}

tree::TerminalNode* OLangParser::PipelineDeclarationContext::EQUALS() {
  return getToken(OLangParser::EQUALS, 0);
}

OLangParser::PipelineBodyContext* OLangParser::PipelineDeclarationContext::pipelineBody() {
  return getRuleContext<OLangParser::PipelineBodyContext>(0);
}


size_t OLangParser::PipelineDeclarationContext::getRuleIndex() const {
  return OLangParser::RulePipelineDeclaration;
}

void OLangParser::PipelineDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPipelineDeclaration(this);
}

void OLangParser::PipelineDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPipelineDeclaration(this);
}


std::any OLangParser::PipelineDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitPipelineDeclaration(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::PipelineDeclarationContext* OLangParser::pipelineDeclaration() {
  PipelineDeclarationContext *_localctx = _tracker.createInstance<PipelineDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 44, OLangParser::RulePipelineDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(522);
    match(OLangParser::ID);
    setState(523);
    match(OLangParser::COLON);
    setState(524);
    match(OLangParser::PIPELINE_TYPE);
    setState(525);
    match(OLangParser::LT);
    setState(526);
    type();
    setState(527);
    match(OLangParser::ARROW);
    setState(528);
    type();
    setState(529);
    match(OLangParser::GT);
    setState(530);
    match(OLangParser::EQUALS);
    setState(531);
    pipelineBody();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeDeclarationContext ------------------------------------------------------------------

OLangParser::TypeDeclarationContext::TypeDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::TypeDeclarationContext::TYPE() {
  return getToken(OLangParser::TYPE, 0);
}

tree::TerminalNode* OLangParser::TypeDeclarationContext::ID() {
  return getToken(OLangParser::ID, 0);
}

tree::TerminalNode* OLangParser::TypeDeclarationContext::LCURLY() {
  return getToken(OLangParser::LCURLY, 0);
}

OLangParser::TypedFieldListContext* OLangParser::TypeDeclarationContext::typedFieldList() {
  return getRuleContext<OLangParser::TypedFieldListContext>(0);
}

tree::TerminalNode* OLangParser::TypeDeclarationContext::RCURLY() {
  return getToken(OLangParser::RCURLY, 0);
}

OLangParser::GenericParametersContext* OLangParser::TypeDeclarationContext::genericParameters() {
  return getRuleContext<OLangParser::GenericParametersContext>(0);
}

OLangParser::WhereClauseContext* OLangParser::TypeDeclarationContext::whereClause() {
  return getRuleContext<OLangParser::WhereClauseContext>(0);
}


size_t OLangParser::TypeDeclarationContext::getRuleIndex() const {
  return OLangParser::RuleTypeDeclaration;
}

void OLangParser::TypeDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeDeclaration(this);
}

void OLangParser::TypeDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeDeclaration(this);
}


std::any OLangParser::TypeDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitTypeDeclaration(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::TypeDeclarationContext* OLangParser::typeDeclaration() {
  TypeDeclarationContext *_localctx = _tracker.createInstance<TypeDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 46, OLangParser::RuleTypeDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(533);
    match(OLangParser::TYPE);
    setState(534);
    match(OLangParser::ID);
    setState(536);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == OLangParser::LT) {
      setState(535);
      genericParameters();
    }
    setState(538);
    match(OLangParser::LCURLY);
    setState(539);
    typedFieldList();
    setState(540);
    match(OLangParser::RCURLY);
    setState(542);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == OLangParser::WHERE) {
      setState(541);
      whereClause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnnotationTypeDeclarationContext ------------------------------------------------------------------

OLangParser::AnnotationTypeDeclarationContext::AnnotationTypeDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::AnnotationTypeDeclarationContext::ANNOTATION() {
  return getToken(OLangParser::ANNOTATION, 0);
}

tree::TerminalNode* OLangParser::AnnotationTypeDeclarationContext::ID() {
  return getToken(OLangParser::ID, 0);
}

tree::TerminalNode* OLangParser::AnnotationTypeDeclarationContext::LCURLY() {
  return getToken(OLangParser::LCURLY, 0);
}

OLangParser::TypedFieldListContext* OLangParser::AnnotationTypeDeclarationContext::typedFieldList() {
  return getRuleContext<OLangParser::TypedFieldListContext>(0);
}

tree::TerminalNode* OLangParser::AnnotationTypeDeclarationContext::RCURLY() {
  return getToken(OLangParser::RCURLY, 0);
}


size_t OLangParser::AnnotationTypeDeclarationContext::getRuleIndex() const {
  return OLangParser::RuleAnnotationTypeDeclaration;
}

void OLangParser::AnnotationTypeDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnnotationTypeDeclaration(this);
}

void OLangParser::AnnotationTypeDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnnotationTypeDeclaration(this);
}


std::any OLangParser::AnnotationTypeDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitAnnotationTypeDeclaration(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::AnnotationTypeDeclarationContext* OLangParser::annotationTypeDeclaration() {
  AnnotationTypeDeclarationContext *_localctx = _tracker.createInstance<AnnotationTypeDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 48, OLangParser::RuleAnnotationTypeDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(544);
    match(OLangParser::ANNOTATION);
    setState(545);
    match(OLangParser::ID);
    setState(546);
    match(OLangParser::LCURLY);
    setState(547);
    typedFieldList();
    setState(548);
    match(OLangParser::RCURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnnotationStatementContext ------------------------------------------------------------------

OLangParser::AnnotationStatementContext::AnnotationStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::AnnotationStatementContext::ANNOTATED() {
  return getToken(OLangParser::ANNOTATED, 0);
}

OLangParser::DeclarationContext* OLangParser::AnnotationStatementContext::declaration() {
  return getRuleContext<OLangParser::DeclarationContext>(0);
}

tree::TerminalNode* OLangParser::AnnotationStatementContext::WITH() {
  return getToken(OLangParser::WITH, 0);
}

tree::TerminalNode* OLangParser::AnnotationStatementContext::LCURLY() {
  return getToken(OLangParser::LCURLY, 0);
}

OLangParser::AnnotationPairListContext* OLangParser::AnnotationStatementContext::annotationPairList() {
  return getRuleContext<OLangParser::AnnotationPairListContext>(0);
}

tree::TerminalNode* OLangParser::AnnotationStatementContext::RCURLY() {
  return getToken(OLangParser::RCURLY, 0);
}


size_t OLangParser::AnnotationStatementContext::getRuleIndex() const {
  return OLangParser::RuleAnnotationStatement;
}

void OLangParser::AnnotationStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnnotationStatement(this);
}

void OLangParser::AnnotationStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnnotationStatement(this);
}


std::any OLangParser::AnnotationStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitAnnotationStatement(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::AnnotationStatementContext* OLangParser::annotationStatement() {
  AnnotationStatementContext *_localctx = _tracker.createInstance<AnnotationStatementContext>(_ctx, getState());
  enterRule(_localctx, 50, OLangParser::RuleAnnotationStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(550);
    match(OLangParser::ANNOTATED);
    setState(551);
    declaration();
    setState(552);
    match(OLangParser::WITH);
    setState(553);
    match(OLangParser::LCURLY);
    setState(554);
    annotationPairList();
    setState(555);
    match(OLangParser::RCURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

OLangParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::LambdaExpressionContext* OLangParser::ExpressionContext::lambdaExpression() {
  return getRuleContext<OLangParser::LambdaExpressionContext>(0);
}

OLangParser::FunctionalExpressionContext* OLangParser::ExpressionContext::functionalExpression() {
  return getRuleContext<OLangParser::FunctionalExpressionContext>(0);
}

OLangParser::PipelineExpressionContext* OLangParser::ExpressionContext::pipelineExpression() {
  return getRuleContext<OLangParser::PipelineExpressionContext>(0);
}


size_t OLangParser::ExpressionContext::getRuleIndex() const {
  return OLangParser::RuleExpression;
}

void OLangParser::ExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression(this);
}

void OLangParser::ExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression(this);
}


std::any OLangParser::ExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ExpressionContext* OLangParser::expression() {
  ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, getState());
  enterRule(_localctx, 52, OLangParser::RuleExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(560);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(557);
      lambdaExpression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(558);
      functionalExpression();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(559);
      pipelineExpression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PipelineExpressionContext ------------------------------------------------------------------

OLangParser::PipelineExpressionContext::PipelineExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::NullCoalesceExpressionContext *> OLangParser::PipelineExpressionContext::nullCoalesceExpression() {
  return getRuleContexts<OLangParser::NullCoalesceExpressionContext>();
}

OLangParser::NullCoalesceExpressionContext* OLangParser::PipelineExpressionContext::nullCoalesceExpression(size_t i) {
  return getRuleContext<OLangParser::NullCoalesceExpressionContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::PipelineExpressionContext::PIPELINE_OP() {
  return getTokens(OLangParser::PIPELINE_OP);
}

tree::TerminalNode* OLangParser::PipelineExpressionContext::PIPELINE_OP(size_t i) {
  return getToken(OLangParser::PIPELINE_OP, i);
}

std::vector<tree::TerminalNode *> OLangParser::PipelineExpressionContext::PARALLEL_OP() {
  return getTokens(OLangParser::PARALLEL_OP);
}

tree::TerminalNode* OLangParser::PipelineExpressionContext::PARALLEL_OP(size_t i) {
  return getToken(OLangParser::PARALLEL_OP, i);
}


size_t OLangParser::PipelineExpressionContext::getRuleIndex() const {
  return OLangParser::RulePipelineExpression;
}

void OLangParser::PipelineExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPipelineExpression(this);
}

void OLangParser::PipelineExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPipelineExpression(this);
}


std::any OLangParser::PipelineExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitPipelineExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::PipelineExpressionContext* OLangParser::pipelineExpression() {
  PipelineExpressionContext *_localctx = _tracker.createInstance<PipelineExpressionContext>(_ctx, getState());
  enterRule(_localctx, 54, OLangParser::RulePipelineExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(562);
    nullCoalesceExpression();
    setState(567);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(563);
        _la = _input->LA(1);
        if (!(_la == OLangParser::PIPELINE_OP

        || _la == OLangParser::PARALLEL_OP)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(564);
        nullCoalesceExpression(); 
      }
      setState(569);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PipelineBodyContext ------------------------------------------------------------------

OLangParser::PipelineBodyContext::PipelineBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::ExpressionContext *> OLangParser::PipelineBodyContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::PipelineBodyContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::PipelineBodyContext::PIPELINE_OP() {
  return getTokens(OLangParser::PIPELINE_OP);
}

tree::TerminalNode* OLangParser::PipelineBodyContext::PIPELINE_OP(size_t i) {
  return getToken(OLangParser::PIPELINE_OP, i);
}

std::vector<tree::TerminalNode *> OLangParser::PipelineBodyContext::PARALLEL_OP() {
  return getTokens(OLangParser::PARALLEL_OP);
}

tree::TerminalNode* OLangParser::PipelineBodyContext::PARALLEL_OP(size_t i) {
  return getToken(OLangParser::PARALLEL_OP, i);
}


size_t OLangParser::PipelineBodyContext::getRuleIndex() const {
  return OLangParser::RulePipelineBody;
}

void OLangParser::PipelineBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPipelineBody(this);
}

void OLangParser::PipelineBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPipelineBody(this);
}


std::any OLangParser::PipelineBodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitPipelineBody(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::PipelineBodyContext* OLangParser::pipelineBody() {
  PipelineBodyContext *_localctx = _tracker.createInstance<PipelineBodyContext>(_ctx, getState());
  enterRule(_localctx, 56, OLangParser::RulePipelineBody);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(570);
    expression();
    setState(575);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == OLangParser::PIPELINE_OP

    || _la == OLangParser::PARALLEL_OP) {
      setState(571);
      _la = _input->LA(1);
      if (!(_la == OLangParser::PIPELINE_OP

      || _la == OLangParser::PARALLEL_OP)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(572);
      expression();
      setState(577);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NullCoalesceExpressionContext ------------------------------------------------------------------

OLangParser::NullCoalesceExpressionContext::NullCoalesceExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::TernaryExpressionContext *> OLangParser::NullCoalesceExpressionContext::ternaryExpression() {
  return getRuleContexts<OLangParser::TernaryExpressionContext>();
}

OLangParser::TernaryExpressionContext* OLangParser::NullCoalesceExpressionContext::ternaryExpression(size_t i) {
  return getRuleContext<OLangParser::TernaryExpressionContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::NullCoalesceExpressionContext::NULL_COALESCE() {
  return getTokens(OLangParser::NULL_COALESCE);
}

tree::TerminalNode* OLangParser::NullCoalesceExpressionContext::NULL_COALESCE(size_t i) {
  return getToken(OLangParser::NULL_COALESCE, i);
}


size_t OLangParser::NullCoalesceExpressionContext::getRuleIndex() const {
  return OLangParser::RuleNullCoalesceExpression;
}

void OLangParser::NullCoalesceExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNullCoalesceExpression(this);
}

void OLangParser::NullCoalesceExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNullCoalesceExpression(this);
}


std::any OLangParser::NullCoalesceExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitNullCoalesceExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::NullCoalesceExpressionContext* OLangParser::nullCoalesceExpression() {
  NullCoalesceExpressionContext *_localctx = _tracker.createInstance<NullCoalesceExpressionContext>(_ctx, getState());
  enterRule(_localctx, 58, OLangParser::RuleNullCoalesceExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(578);
    ternaryExpression();
    setState(583);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(579);
        match(OLangParser::NULL_COALESCE);
        setState(580);
        ternaryExpression(); 
      }
      setState(585);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TernaryExpressionContext ------------------------------------------------------------------

OLangParser::TernaryExpressionContext::TernaryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::LogicalOrExpressionContext* OLangParser::TernaryExpressionContext::logicalOrExpression() {
  return getRuleContext<OLangParser::LogicalOrExpressionContext>(0);
}

tree::TerminalNode* OLangParser::TernaryExpressionContext::OPTIONAL() {
  return getToken(OLangParser::OPTIONAL, 0);
}

OLangParser::ExpressionContext* OLangParser::TernaryExpressionContext::expression() {
  return getRuleContext<OLangParser::ExpressionContext>(0);
}

tree::TerminalNode* OLangParser::TernaryExpressionContext::COLON() {
  return getToken(OLangParser::COLON, 0);
}

OLangParser::TernaryExpressionContext* OLangParser::TernaryExpressionContext::ternaryExpression() {
  return getRuleContext<OLangParser::TernaryExpressionContext>(0);
}


size_t OLangParser::TernaryExpressionContext::getRuleIndex() const {
  return OLangParser::RuleTernaryExpression;
}

void OLangParser::TernaryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTernaryExpression(this);
}

void OLangParser::TernaryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTernaryExpression(this);
}


std::any OLangParser::TernaryExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitTernaryExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::TernaryExpressionContext* OLangParser::ternaryExpression() {
  TernaryExpressionContext *_localctx = _tracker.createInstance<TernaryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 60, OLangParser::RuleTernaryExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(586);
    logicalOrExpression();
    setState(592);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
    case 1: {
      setState(587);
      match(OLangParser::OPTIONAL);
      setState(588);
      expression();
      setState(589);
      match(OLangParser::COLON);
      setState(590);
      ternaryExpression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogicalOrExpressionContext ------------------------------------------------------------------

OLangParser::LogicalOrExpressionContext::LogicalOrExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::LogicalAndExpressionContext *> OLangParser::LogicalOrExpressionContext::logicalAndExpression() {
  return getRuleContexts<OLangParser::LogicalAndExpressionContext>();
}

OLangParser::LogicalAndExpressionContext* OLangParser::LogicalOrExpressionContext::logicalAndExpression(size_t i) {
  return getRuleContext<OLangParser::LogicalAndExpressionContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::LogicalOrExpressionContext::OR_OP() {
  return getTokens(OLangParser::OR_OP);
}

tree::TerminalNode* OLangParser::LogicalOrExpressionContext::OR_OP(size_t i) {
  return getToken(OLangParser::OR_OP, i);
}

std::vector<tree::TerminalNode *> OLangParser::LogicalOrExpressionContext::OR() {
  return getTokens(OLangParser::OR);
}

tree::TerminalNode* OLangParser::LogicalOrExpressionContext::OR(size_t i) {
  return getToken(OLangParser::OR, i);
}


size_t OLangParser::LogicalOrExpressionContext::getRuleIndex() const {
  return OLangParser::RuleLogicalOrExpression;
}

void OLangParser::LogicalOrExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogicalOrExpression(this);
}

void OLangParser::LogicalOrExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogicalOrExpression(this);
}


std::any OLangParser::LogicalOrExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitLogicalOrExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::LogicalOrExpressionContext* OLangParser::logicalOrExpression() {
  LogicalOrExpressionContext *_localctx = _tracker.createInstance<LogicalOrExpressionContext>(_ctx, getState());
  enterRule(_localctx, 62, OLangParser::RuleLogicalOrExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(594);
    logicalAndExpression();
    setState(599);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(595);
        _la = _input->LA(1);
        if (!(_la == OLangParser::OR_OP

        || _la == OLangParser::OR)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(596);
        logicalAndExpression(); 
      }
      setState(601);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogicalAndExpressionContext ------------------------------------------------------------------

OLangParser::LogicalAndExpressionContext::LogicalAndExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::EqualityExpressionContext *> OLangParser::LogicalAndExpressionContext::equalityExpression() {
  return getRuleContexts<OLangParser::EqualityExpressionContext>();
}

OLangParser::EqualityExpressionContext* OLangParser::LogicalAndExpressionContext::equalityExpression(size_t i) {
  return getRuleContext<OLangParser::EqualityExpressionContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::LogicalAndExpressionContext::AND_OP() {
  return getTokens(OLangParser::AND_OP);
}

tree::TerminalNode* OLangParser::LogicalAndExpressionContext::AND_OP(size_t i) {
  return getToken(OLangParser::AND_OP, i);
}


size_t OLangParser::LogicalAndExpressionContext::getRuleIndex() const {
  return OLangParser::RuleLogicalAndExpression;
}

void OLangParser::LogicalAndExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogicalAndExpression(this);
}

void OLangParser::LogicalAndExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogicalAndExpression(this);
}


std::any OLangParser::LogicalAndExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitLogicalAndExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::LogicalAndExpressionContext* OLangParser::logicalAndExpression() {
  LogicalAndExpressionContext *_localctx = _tracker.createInstance<LogicalAndExpressionContext>(_ctx, getState());
  enterRule(_localctx, 64, OLangParser::RuleLogicalAndExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(602);
    equalityExpression();
    setState(607);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(603);
        match(OLangParser::AND_OP);
        setState(604);
        equalityExpression(); 
      }
      setState(609);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EqualityExpressionContext ------------------------------------------------------------------

OLangParser::EqualityExpressionContext::EqualityExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::RelationalExpressionContext *> OLangParser::EqualityExpressionContext::relationalExpression() {
  return getRuleContexts<OLangParser::RelationalExpressionContext>();
}

OLangParser::RelationalExpressionContext* OLangParser::EqualityExpressionContext::relationalExpression(size_t i) {
  return getRuleContext<OLangParser::RelationalExpressionContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::EqualityExpressionContext::EQ() {
  return getTokens(OLangParser::EQ);
}

tree::TerminalNode* OLangParser::EqualityExpressionContext::EQ(size_t i) {
  return getToken(OLangParser::EQ, i);
}

std::vector<tree::TerminalNode *> OLangParser::EqualityExpressionContext::NEQ() {
  return getTokens(OLangParser::NEQ);
}

tree::TerminalNode* OLangParser::EqualityExpressionContext::NEQ(size_t i) {
  return getToken(OLangParser::NEQ, i);
}


size_t OLangParser::EqualityExpressionContext::getRuleIndex() const {
  return OLangParser::RuleEqualityExpression;
}

void OLangParser::EqualityExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEqualityExpression(this);
}

void OLangParser::EqualityExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEqualityExpression(this);
}


std::any OLangParser::EqualityExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitEqualityExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::EqualityExpressionContext* OLangParser::equalityExpression() {
  EqualityExpressionContext *_localctx = _tracker.createInstance<EqualityExpressionContext>(_ctx, getState());
  enterRule(_localctx, 66, OLangParser::RuleEqualityExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(610);
    relationalExpression();
    setState(615);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(611);
        _la = _input->LA(1);
        if (!(_la == OLangParser::EQ

        || _la == OLangParser::NEQ)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(612);
        relationalExpression(); 
      }
      setState(617);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelationalExpressionContext ------------------------------------------------------------------

OLangParser::RelationalExpressionContext::RelationalExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::AdditiveExpressionContext *> OLangParser::RelationalExpressionContext::additiveExpression() {
  return getRuleContexts<OLangParser::AdditiveExpressionContext>();
}

OLangParser::AdditiveExpressionContext* OLangParser::RelationalExpressionContext::additiveExpression(size_t i) {
  return getRuleContext<OLangParser::AdditiveExpressionContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::RelationalExpressionContext::LE() {
  return getTokens(OLangParser::LE);
}

tree::TerminalNode* OLangParser::RelationalExpressionContext::LE(size_t i) {
  return getToken(OLangParser::LE, i);
}

std::vector<tree::TerminalNode *> OLangParser::RelationalExpressionContext::LT() {
  return getTokens(OLangParser::LT);
}

tree::TerminalNode* OLangParser::RelationalExpressionContext::LT(size_t i) {
  return getToken(OLangParser::LT, i);
}

std::vector<tree::TerminalNode *> OLangParser::RelationalExpressionContext::GE() {
  return getTokens(OLangParser::GE);
}

tree::TerminalNode* OLangParser::RelationalExpressionContext::GE(size_t i) {
  return getToken(OLangParser::GE, i);
}

std::vector<tree::TerminalNode *> OLangParser::RelationalExpressionContext::GT() {
  return getTokens(OLangParser::GT);
}

tree::TerminalNode* OLangParser::RelationalExpressionContext::GT(size_t i) {
  return getToken(OLangParser::GT, i);
}

std::vector<tree::TerminalNode *> OLangParser::RelationalExpressionContext::WITHIN() {
  return getTokens(OLangParser::WITHIN);
}

tree::TerminalNode* OLangParser::RelationalExpressionContext::WITHIN(size_t i) {
  return getToken(OLangParser::WITHIN, i);
}

std::vector<tree::TerminalNode *> OLangParser::RelationalExpressionContext::DURING() {
  return getTokens(OLangParser::DURING);
}

tree::TerminalNode* OLangParser::RelationalExpressionContext::DURING(size_t i) {
  return getToken(OLangParser::DURING, i);
}

std::vector<tree::TerminalNode *> OLangParser::RelationalExpressionContext::UNTIL() {
  return getTokens(OLangParser::UNTIL);
}

tree::TerminalNode* OLangParser::RelationalExpressionContext::UNTIL(size_t i) {
  return getToken(OLangParser::UNTIL, i);
}


size_t OLangParser::RelationalExpressionContext::getRuleIndex() const {
  return OLangParser::RuleRelationalExpression;
}

void OLangParser::RelationalExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelationalExpression(this);
}

void OLangParser::RelationalExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelationalExpression(this);
}


std::any OLangParser::RelationalExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitRelationalExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::RelationalExpressionContext* OLangParser::relationalExpression() {
  RelationalExpressionContext *_localctx = _tracker.createInstance<RelationalExpressionContext>(_ctx, getState());
  enterRule(_localctx, 68, OLangParser::RuleRelationalExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(618);
    additiveExpression();
    setState(623);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(619);
        _la = _input->LA(1);
        if (!(((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 68820140032) != 0 || (((_la - 87) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 87)) & 15) != 0)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(620);
        additiveExpression(); 
      }
      setState(625);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AdditiveExpressionContext ------------------------------------------------------------------

OLangParser::AdditiveExpressionContext::AdditiveExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::MultiplicativeExpressionContext *> OLangParser::AdditiveExpressionContext::multiplicativeExpression() {
  return getRuleContexts<OLangParser::MultiplicativeExpressionContext>();
}

OLangParser::MultiplicativeExpressionContext* OLangParser::AdditiveExpressionContext::multiplicativeExpression(size_t i) {
  return getRuleContext<OLangParser::MultiplicativeExpressionContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::AdditiveExpressionContext::ADD() {
  return getTokens(OLangParser::ADD);
}

tree::TerminalNode* OLangParser::AdditiveExpressionContext::ADD(size_t i) {
  return getToken(OLangParser::ADD, i);
}

std::vector<tree::TerminalNode *> OLangParser::AdditiveExpressionContext::SUB() {
  return getTokens(OLangParser::SUB);
}

tree::TerminalNode* OLangParser::AdditiveExpressionContext::SUB(size_t i) {
  return getToken(OLangParser::SUB, i);
}


size_t OLangParser::AdditiveExpressionContext::getRuleIndex() const {
  return OLangParser::RuleAdditiveExpression;
}

void OLangParser::AdditiveExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAdditiveExpression(this);
}

void OLangParser::AdditiveExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAdditiveExpression(this);
}


std::any OLangParser::AdditiveExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitAdditiveExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::AdditiveExpressionContext* OLangParser::additiveExpression() {
  AdditiveExpressionContext *_localctx = _tracker.createInstance<AdditiveExpressionContext>(_ctx, getState());
  enterRule(_localctx, 70, OLangParser::RuleAdditiveExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(626);
    multiplicativeExpression();
    setState(631);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(627);
        _la = _input->LA(1);
        if (!(_la == OLangParser::ADD

        || _la == OLangParser::SUB)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(628);
        multiplicativeExpression(); 
      }
      setState(633);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultiplicativeExpressionContext ------------------------------------------------------------------

OLangParser::MultiplicativeExpressionContext::MultiplicativeExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::UnaryExpressionContext *> OLangParser::MultiplicativeExpressionContext::unaryExpression() {
  return getRuleContexts<OLangParser::UnaryExpressionContext>();
}

OLangParser::UnaryExpressionContext* OLangParser::MultiplicativeExpressionContext::unaryExpression(size_t i) {
  return getRuleContext<OLangParser::UnaryExpressionContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::MultiplicativeExpressionContext::MUL() {
  return getTokens(OLangParser::MUL);
}

tree::TerminalNode* OLangParser::MultiplicativeExpressionContext::MUL(size_t i) {
  return getToken(OLangParser::MUL, i);
}

std::vector<tree::TerminalNode *> OLangParser::MultiplicativeExpressionContext::DIV() {
  return getTokens(OLangParser::DIV);
}

tree::TerminalNode* OLangParser::MultiplicativeExpressionContext::DIV(size_t i) {
  return getToken(OLangParser::DIV, i);
}

std::vector<tree::TerminalNode *> OLangParser::MultiplicativeExpressionContext::MOD() {
  return getTokens(OLangParser::MOD);
}

tree::TerminalNode* OLangParser::MultiplicativeExpressionContext::MOD(size_t i) {
  return getToken(OLangParser::MOD, i);
}


size_t OLangParser::MultiplicativeExpressionContext::getRuleIndex() const {
  return OLangParser::RuleMultiplicativeExpression;
}

void OLangParser::MultiplicativeExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultiplicativeExpression(this);
}

void OLangParser::MultiplicativeExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultiplicativeExpression(this);
}


std::any OLangParser::MultiplicativeExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitMultiplicativeExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::MultiplicativeExpressionContext* OLangParser::multiplicativeExpression() {
  MultiplicativeExpressionContext *_localctx = _tracker.createInstance<MultiplicativeExpressionContext>(_ctx, getState());
  enterRule(_localctx, 72, OLangParser::RuleMultiplicativeExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(634);
    unaryExpression();
    setState(639);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(635);
        _la = _input->LA(1);
        if (!((((_la - 82) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 82)) & 7) != 0)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(636);
        unaryExpression(); 
      }
      setState(641);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnaryExpressionContext ------------------------------------------------------------------

OLangParser::UnaryExpressionContext::UnaryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::UnaryExpressionContext* OLangParser::UnaryExpressionContext::unaryExpression() {
  return getRuleContext<OLangParser::UnaryExpressionContext>(0);
}

tree::TerminalNode* OLangParser::UnaryExpressionContext::NOT() {
  return getToken(OLangParser::NOT, 0);
}

tree::TerminalNode* OLangParser::UnaryExpressionContext::SUB() {
  return getToken(OLangParser::SUB, 0);
}

tree::TerminalNode* OLangParser::UnaryExpressionContext::ADD() {
  return getToken(OLangParser::ADD, 0);
}

tree::TerminalNode* OLangParser::UnaryExpressionContext::ALWAYS() {
  return getToken(OLangParser::ALWAYS, 0);
}

tree::TerminalNode* OLangParser::UnaryExpressionContext::EVENTUALLY() {
  return getToken(OLangParser::EVENTUALLY, 0);
}

OLangParser::ErrorPropagationExpressionContext* OLangParser::UnaryExpressionContext::errorPropagationExpression() {
  return getRuleContext<OLangParser::ErrorPropagationExpressionContext>(0);
}


size_t OLangParser::UnaryExpressionContext::getRuleIndex() const {
  return OLangParser::RuleUnaryExpression;
}

void OLangParser::UnaryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryExpression(this);
}

void OLangParser::UnaryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryExpression(this);
}


std::any OLangParser::UnaryExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitUnaryExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::UnaryExpressionContext* OLangParser::unaryExpression() {
  UnaryExpressionContext *_localctx = _tracker.createInstance<UnaryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 74, OLangParser::RuleUnaryExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(645);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case OLangParser::ALWAYS:
      case OLangParser::EVENTUALLY:
      case OLangParser::ADD:
      case OLangParser::SUB:
      case OLangParser::NOT: {
        enterOuterAlt(_localctx, 1);
        setState(642);
        _la = _input->LA(1);
        if (!(_la == OLangParser::ALWAYS

        || _la == OLangParser::EVENTUALLY || (((_la - 80) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 80)) & 8195) != 0)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(643);
        unaryExpression();
        break;
      }

      case OLangParser::MATCH:
      case OLangParser::NULL_LIT:
      case OLangParser::BOOLEAN:
      case OLangParser::INT_LITERAL:
      case OLangParser::DECIMAL_LITERAL:
      case OLangParser::STRING:
      case OLangParser::RAW_STRING:
      case OLangParser::MULTILINE_STRING:
      case OLangParser::LPAREN:
      case OLangParser::LBRACK:
      case OLangParser::LCURLY:
      case OLangParser::ID: {
        enterOuterAlt(_localctx, 2);
        setState(644);
        errorPropagationExpression();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ErrorPropagationExpressionContext ------------------------------------------------------------------

OLangParser::ErrorPropagationExpressionContext::ErrorPropagationExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::PostfixExpressionContext* OLangParser::ErrorPropagationExpressionContext::postfixExpression() {
  return getRuleContext<OLangParser::PostfixExpressionContext>(0);
}

tree::TerminalNode* OLangParser::ErrorPropagationExpressionContext::OPTIONAL() {
  return getToken(OLangParser::OPTIONAL, 0);
}


size_t OLangParser::ErrorPropagationExpressionContext::getRuleIndex() const {
  return OLangParser::RuleErrorPropagationExpression;
}

void OLangParser::ErrorPropagationExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterErrorPropagationExpression(this);
}

void OLangParser::ErrorPropagationExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitErrorPropagationExpression(this);
}


std::any OLangParser::ErrorPropagationExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitErrorPropagationExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ErrorPropagationExpressionContext* OLangParser::errorPropagationExpression() {
  ErrorPropagationExpressionContext *_localctx = _tracker.createInstance<ErrorPropagationExpressionContext>(_ctx, getState());
  enterRule(_localctx, 76, OLangParser::RuleErrorPropagationExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(647);
    postfixExpression();
    setState(649);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx)) {
    case 1: {
      setState(648);
      match(OLangParser::OPTIONAL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PostfixExpressionContext ------------------------------------------------------------------

OLangParser::PostfixExpressionContext::PostfixExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::PrimaryExpressionContext* OLangParser::PostfixExpressionContext::primaryExpression() {
  return getRuleContext<OLangParser::PrimaryExpressionContext>(0);
}

std::vector<OLangParser::CallSuffixContext *> OLangParser::PostfixExpressionContext::callSuffix() {
  return getRuleContexts<OLangParser::CallSuffixContext>();
}

OLangParser::CallSuffixContext* OLangParser::PostfixExpressionContext::callSuffix(size_t i) {
  return getRuleContext<OLangParser::CallSuffixContext>(i);
}


size_t OLangParser::PostfixExpressionContext::getRuleIndex() const {
  return OLangParser::RulePostfixExpression;
}

void OLangParser::PostfixExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPostfixExpression(this);
}

void OLangParser::PostfixExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPostfixExpression(this);
}


std::any OLangParser::PostfixExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitPostfixExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::PostfixExpressionContext* OLangParser::postfixExpression() {
  PostfixExpressionContext *_localctx = _tracker.createInstance<PostfixExpressionContext>(_ctx, getState());
  enterRule(_localctx, 78, OLangParser::RulePostfixExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(651);
    primaryExpression();
    setState(655);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(652);
        callSuffix(); 
      }
      setState(657);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CallSuffixContext ------------------------------------------------------------------

OLangParser::CallSuffixContext::CallSuffixContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::CallArgumentsContext* OLangParser::CallSuffixContext::callArguments() {
  return getRuleContext<OLangParser::CallArgumentsContext>(0);
}

tree::TerminalNode* OLangParser::CallSuffixContext::DOT() {
  return getToken(OLangParser::DOT, 0);
}

tree::TerminalNode* OLangParser::CallSuffixContext::ID() {
  return getToken(OLangParser::ID, 0);
}

tree::TerminalNode* OLangParser::CallSuffixContext::LBRACK() {
  return getToken(OLangParser::LBRACK, 0);
}

OLangParser::ExpressionContext* OLangParser::CallSuffixContext::expression() {
  return getRuleContext<OLangParser::ExpressionContext>(0);
}

tree::TerminalNode* OLangParser::CallSuffixContext::RBRACK() {
  return getToken(OLangParser::RBRACK, 0);
}


size_t OLangParser::CallSuffixContext::getRuleIndex() const {
  return OLangParser::RuleCallSuffix;
}

void OLangParser::CallSuffixContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCallSuffix(this);
}

void OLangParser::CallSuffixContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCallSuffix(this);
}


std::any OLangParser::CallSuffixContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitCallSuffix(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::CallSuffixContext* OLangParser::callSuffix() {
  CallSuffixContext *_localctx = _tracker.createInstance<CallSuffixContext>(_ctx, getState());
  enterRule(_localctx, 80, OLangParser::RuleCallSuffix);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(668);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case OLangParser::LPAREN: {
        enterOuterAlt(_localctx, 1);
        setState(658);
        callArguments();
        break;
      }

      case OLangParser::DOT: {
        enterOuterAlt(_localctx, 2);
        setState(659);
        match(OLangParser::DOT);
        setState(660);
        match(OLangParser::ID);
        setState(662);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx)) {
        case 1: {
          setState(661);
          callArguments();
          break;
        }

        default:
          break;
        }
        break;
      }

      case OLangParser::LBRACK: {
        enterOuterAlt(_localctx, 3);
        setState(664);
        match(OLangParser::LBRACK);
        setState(665);
        expression();
        setState(666);
        match(OLangParser::RBRACK);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CallArgumentsContext ------------------------------------------------------------------

OLangParser::CallArgumentsContext::CallArgumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::CallArgumentsContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

tree::TerminalNode* OLangParser::CallArgumentsContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}

OLangParser::ArgumentListContext* OLangParser::CallArgumentsContext::argumentList() {
  return getRuleContext<OLangParser::ArgumentListContext>(0);
}


size_t OLangParser::CallArgumentsContext::getRuleIndex() const {
  return OLangParser::RuleCallArguments;
}

void OLangParser::CallArgumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCallArguments(this);
}

void OLangParser::CallArgumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCallArguments(this);
}


std::any OLangParser::CallArgumentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitCallArguments(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::CallArgumentsContext* OLangParser::callArguments() {
  CallArgumentsContext *_localctx = _tracker.createInstance<CallArgumentsContext>(_ctx, getState());
  enterRule(_localctx, 82, OLangParser::RuleCallArguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(670);
    match(OLangParser::LPAREN);
    setState(672);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2233785277761980416) != 0 || (((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & 291324401880665089) != 0) {
      setState(671);
      argumentList();
    }
    setState(674);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrimaryExpressionContext ------------------------------------------------------------------

OLangParser::PrimaryExpressionContext::PrimaryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::LiteralValueContext* OLangParser::PrimaryExpressionContext::literalValue() {
  return getRuleContext<OLangParser::LiteralValueContext>(0);
}

OLangParser::LambdaExpressionContext* OLangParser::PrimaryExpressionContext::lambdaExpression() {
  return getRuleContext<OLangParser::LambdaExpressionContext>(0);
}

OLangParser::MatchExpressionContext* OLangParser::PrimaryExpressionContext::matchExpression() {
  return getRuleContext<OLangParser::MatchExpressionContext>(0);
}

OLangParser::ListExpressionContext* OLangParser::PrimaryExpressionContext::listExpression() {
  return getRuleContext<OLangParser::ListExpressionContext>(0);
}

OLangParser::ObjectExpressionContext* OLangParser::PrimaryExpressionContext::objectExpression() {
  return getRuleContext<OLangParser::ObjectExpressionContext>(0);
}

OLangParser::QualifiedNameContext* OLangParser::PrimaryExpressionContext::qualifiedName() {
  return getRuleContext<OLangParser::QualifiedNameContext>(0);
}

tree::TerminalNode* OLangParser::PrimaryExpressionContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

OLangParser::ExpressionContext* OLangParser::PrimaryExpressionContext::expression() {
  return getRuleContext<OLangParser::ExpressionContext>(0);
}

tree::TerminalNode* OLangParser::PrimaryExpressionContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}


size_t OLangParser::PrimaryExpressionContext::getRuleIndex() const {
  return OLangParser::RulePrimaryExpression;
}

void OLangParser::PrimaryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryExpression(this);
}

void OLangParser::PrimaryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryExpression(this);
}


std::any OLangParser::PrimaryExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitPrimaryExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::PrimaryExpressionContext* OLangParser::primaryExpression() {
  PrimaryExpressionContext *_localctx = _tracker.createInstance<PrimaryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 84, OLangParser::RulePrimaryExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(686);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(676);
      literalValue();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(677);
      lambdaExpression();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(678);
      matchExpression();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(679);
      listExpression();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(680);
      objectExpression();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(681);
      qualifiedName();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(682);
      match(OLangParser::LPAREN);
      setState(683);
      expression();
      setState(684);
      match(OLangParser::RPAREN);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeContext ------------------------------------------------------------------

OLangParser::TypeContext::TypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::OptionalTypeContext *> OLangParser::TypeContext::optionalType() {
  return getRuleContexts<OLangParser::OptionalTypeContext>();
}

OLangParser::OptionalTypeContext* OLangParser::TypeContext::optionalType(size_t i) {
  return getRuleContext<OLangParser::OptionalTypeContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::TypeContext::UNION_PIPE() {
  return getTokens(OLangParser::UNION_PIPE);
}

tree::TerminalNode* OLangParser::TypeContext::UNION_PIPE(size_t i) {
  return getToken(OLangParser::UNION_PIPE, i);
}


size_t OLangParser::TypeContext::getRuleIndex() const {
  return OLangParser::RuleType;
}

void OLangParser::TypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType(this);
}

void OLangParser::TypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType(this);
}


std::any OLangParser::TypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitType(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::TypeContext* OLangParser::type() {
  TypeContext *_localctx = _tracker.createInstance<TypeContext>(_ctx, getState());
  enterRule(_localctx, 86, OLangParser::RuleType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(688);
    optionalType();
    setState(693);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(689);
        match(OLangParser::UNION_PIPE);
        setState(690);
        optionalType(); 
      }
      setState(695);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionalTypeContext ------------------------------------------------------------------

OLangParser::OptionalTypeContext::OptionalTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::BaseTypeContext* OLangParser::OptionalTypeContext::baseType() {
  return getRuleContext<OLangParser::BaseTypeContext>(0);
}

tree::TerminalNode* OLangParser::OptionalTypeContext::OPTIONAL() {
  return getToken(OLangParser::OPTIONAL, 0);
}


size_t OLangParser::OptionalTypeContext::getRuleIndex() const {
  return OLangParser::RuleOptionalType;
}

void OLangParser::OptionalTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionalType(this);
}

void OLangParser::OptionalTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionalType(this);
}


std::any OLangParser::OptionalTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitOptionalType(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::OptionalTypeContext* OLangParser::optionalType() {
  OptionalTypeContext *_localctx = _tracker.createInstance<OptionalTypeContext>(_ctx, getState());
  enterRule(_localctx, 88, OLangParser::RuleOptionalType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(696);
    baseType();
    setState(698);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx)) {
    case 1: {
      setState(697);
      match(OLangParser::OPTIONAL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BaseTypeContext ------------------------------------------------------------------

OLangParser::BaseTypeContext::BaseTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::PrimitiveTypeContext* OLangParser::BaseTypeContext::primitiveType() {
  return getRuleContext<OLangParser::PrimitiveTypeContext>(0);
}

OLangParser::UserDefinedTypeContext* OLangParser::BaseTypeContext::userDefinedType() {
  return getRuleContext<OLangParser::UserDefinedTypeContext>(0);
}

OLangParser::PipelineTypeContext* OLangParser::BaseTypeContext::pipelineType() {
  return getRuleContext<OLangParser::PipelineTypeContext>(0);
}

OLangParser::ListTypeContext* OLangParser::BaseTypeContext::listType() {
  return getRuleContext<OLangParser::ListTypeContext>(0);
}

OLangParser::MapTypeContext* OLangParser::BaseTypeContext::mapType() {
  return getRuleContext<OLangParser::MapTypeContext>(0);
}

OLangParser::SetTypeContext* OLangParser::BaseTypeContext::setType() {
  return getRuleContext<OLangParser::SetTypeContext>(0);
}

OLangParser::StreamTypeContext* OLangParser::BaseTypeContext::streamType() {
  return getRuleContext<OLangParser::StreamTypeContext>(0);
}

OLangParser::FutureTypeContext* OLangParser::BaseTypeContext::futureType() {
  return getRuleContext<OLangParser::FutureTypeContext>(0);
}

OLangParser::ResultTypeContext* OLangParser::BaseTypeContext::resultType() {
  return getRuleContext<OLangParser::ResultTypeContext>(0);
}

OLangParser::OptionTypeContext* OLangParser::BaseTypeContext::optionType() {
  return getRuleContext<OLangParser::OptionTypeContext>(0);
}

OLangParser::ProvenanceTypeContext* OLangParser::BaseTypeContext::provenanceType() {
  return getRuleContext<OLangParser::ProvenanceTypeContext>(0);
}

OLangParser::FunctionTypeContext* OLangParser::BaseTypeContext::functionType() {
  return getRuleContext<OLangParser::FunctionTypeContext>(0);
}

OLangParser::ParenthesisTypeContext* OLangParser::BaseTypeContext::parenthesisType() {
  return getRuleContext<OLangParser::ParenthesisTypeContext>(0);
}


size_t OLangParser::BaseTypeContext::getRuleIndex() const {
  return OLangParser::RuleBaseType;
}

void OLangParser::BaseTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBaseType(this);
}

void OLangParser::BaseTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBaseType(this);
}


std::any OLangParser::BaseTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitBaseType(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::BaseTypeContext* OLangParser::baseType() {
  BaseTypeContext *_localctx = _tracker.createInstance<BaseTypeContext>(_ctx, getState());
  enterRule(_localctx, 90, OLangParser::RuleBaseType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(713);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(700);
      primitiveType();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(701);
      userDefinedType();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(702);
      pipelineType();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(703);
      listType();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(704);
      mapType();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(705);
      setType();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(706);
      streamType();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(707);
      futureType();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(708);
      resultType();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(709);
      optionType();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(710);
      provenanceType();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(711);
      functionType();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(712);
      parenthesisType();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrimitiveTypeContext ------------------------------------------------------------------

OLangParser::PrimitiveTypeContext::PrimitiveTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::PrimitiveTypeContext::INT_TYPE() {
  return getToken(OLangParser::INT_TYPE, 0);
}

tree::TerminalNode* OLangParser::PrimitiveTypeContext::LONG_TYPE() {
  return getToken(OLangParser::LONG_TYPE, 0);
}

tree::TerminalNode* OLangParser::PrimitiveTypeContext::FLOAT_TYPE() {
  return getToken(OLangParser::FLOAT_TYPE, 0);
}

tree::TerminalNode* OLangParser::PrimitiveTypeContext::DOUBLE_TYPE() {
  return getToken(OLangParser::DOUBLE_TYPE, 0);
}

tree::TerminalNode* OLangParser::PrimitiveTypeContext::BOOL_TYPE() {
  return getToken(OLangParser::BOOL_TYPE, 0);
}

tree::TerminalNode* OLangParser::PrimitiveTypeContext::CHAR_TYPE() {
  return getToken(OLangParser::CHAR_TYPE, 0);
}

tree::TerminalNode* OLangParser::PrimitiveTypeContext::STRING_TYPE() {
  return getToken(OLangParser::STRING_TYPE, 0);
}

tree::TerminalNode* OLangParser::PrimitiveTypeContext::ANY_TYPE() {
  return getToken(OLangParser::ANY_TYPE, 0);
}

tree::TerminalNode* OLangParser::PrimitiveTypeContext::NEVER_TYPE() {
  return getToken(OLangParser::NEVER_TYPE, 0);
}


size_t OLangParser::PrimitiveTypeContext::getRuleIndex() const {
  return OLangParser::RulePrimitiveType;
}

void OLangParser::PrimitiveTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimitiveType(this);
}

void OLangParser::PrimitiveTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimitiveType(this);
}


std::any OLangParser::PrimitiveTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitPrimitiveType(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::PrimitiveTypeContext* OLangParser::primitiveType() {
  PrimitiveTypeContext *_localctx = _tracker.createInstance<PrimitiveTypeContext>(_ctx, getState());
  enterRule(_localctx, 92, OLangParser::RulePrimitiveType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(715);
    _la = _input->LA(1);
    if (!((((_la - 61) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 61)) & 511) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserDefinedTypeContext ------------------------------------------------------------------

OLangParser::UserDefinedTypeContext::UserDefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::QualifiedNameContext* OLangParser::UserDefinedTypeContext::qualifiedName() {
  return getRuleContext<OLangParser::QualifiedNameContext>(0);
}

OLangParser::GenericArgumentsContext* OLangParser::UserDefinedTypeContext::genericArguments() {
  return getRuleContext<OLangParser::GenericArgumentsContext>(0);
}


size_t OLangParser::UserDefinedTypeContext::getRuleIndex() const {
  return OLangParser::RuleUserDefinedType;
}

void OLangParser::UserDefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserDefinedType(this);
}

void OLangParser::UserDefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserDefinedType(this);
}


std::any OLangParser::UserDefinedTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitUserDefinedType(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::UserDefinedTypeContext* OLangParser::userDefinedType() {
  UserDefinedTypeContext *_localctx = _tracker.createInstance<UserDefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 94, OLangParser::RuleUserDefinedType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(717);
    qualifiedName();
    setState(719);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == OLangParser::LT) {
      setState(718);
      genericArguments();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PipelineTypeContext ------------------------------------------------------------------

OLangParser::PipelineTypeContext::PipelineTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::PipelineTypeContext::PIPELINE_TYPE() {
  return getToken(OLangParser::PIPELINE_TYPE, 0);
}

tree::TerminalNode* OLangParser::PipelineTypeContext::LT() {
  return getToken(OLangParser::LT, 0);
}

std::vector<OLangParser::TypeContext *> OLangParser::PipelineTypeContext::type() {
  return getRuleContexts<OLangParser::TypeContext>();
}

OLangParser::TypeContext* OLangParser::PipelineTypeContext::type(size_t i) {
  return getRuleContext<OLangParser::TypeContext>(i);
}

tree::TerminalNode* OLangParser::PipelineTypeContext::ARROW() {
  return getToken(OLangParser::ARROW, 0);
}

tree::TerminalNode* OLangParser::PipelineTypeContext::GT() {
  return getToken(OLangParser::GT, 0);
}


size_t OLangParser::PipelineTypeContext::getRuleIndex() const {
  return OLangParser::RulePipelineType;
}

void OLangParser::PipelineTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPipelineType(this);
}

void OLangParser::PipelineTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPipelineType(this);
}


std::any OLangParser::PipelineTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitPipelineType(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::PipelineTypeContext* OLangParser::pipelineType() {
  PipelineTypeContext *_localctx = _tracker.createInstance<PipelineTypeContext>(_ctx, getState());
  enterRule(_localctx, 96, OLangParser::RulePipelineType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(721);
    match(OLangParser::PIPELINE_TYPE);
    setState(722);
    match(OLangParser::LT);
    setState(723);
    type();
    setState(724);
    match(OLangParser::ARROW);
    setState(725);
    type();
    setState(726);
    match(OLangParser::GT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ListTypeContext ------------------------------------------------------------------

OLangParser::ListTypeContext::ListTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::ListTypeContext::LIST_TYPE() {
  return getToken(OLangParser::LIST_TYPE, 0);
}

tree::TerminalNode* OLangParser::ListTypeContext::LT() {
  return getToken(OLangParser::LT, 0);
}

OLangParser::TypeContext* OLangParser::ListTypeContext::type() {
  return getRuleContext<OLangParser::TypeContext>(0);
}

tree::TerminalNode* OLangParser::ListTypeContext::GT() {
  return getToken(OLangParser::GT, 0);
}


size_t OLangParser::ListTypeContext::getRuleIndex() const {
  return OLangParser::RuleListType;
}

void OLangParser::ListTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterListType(this);
}

void OLangParser::ListTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitListType(this);
}


std::any OLangParser::ListTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitListType(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ListTypeContext* OLangParser::listType() {
  ListTypeContext *_localctx = _tracker.createInstance<ListTypeContext>(_ctx, getState());
  enterRule(_localctx, 98, OLangParser::RuleListType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(728);
    match(OLangParser::LIST_TYPE);
    setState(729);
    match(OLangParser::LT);
    setState(730);
    type();
    setState(731);
    match(OLangParser::GT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MapTypeContext ------------------------------------------------------------------

OLangParser::MapTypeContext::MapTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::MapTypeContext::MAP_TYPE() {
  return getToken(OLangParser::MAP_TYPE, 0);
}

tree::TerminalNode* OLangParser::MapTypeContext::LT() {
  return getToken(OLangParser::LT, 0);
}

std::vector<OLangParser::TypeContext *> OLangParser::MapTypeContext::type() {
  return getRuleContexts<OLangParser::TypeContext>();
}

OLangParser::TypeContext* OLangParser::MapTypeContext::type(size_t i) {
  return getRuleContext<OLangParser::TypeContext>(i);
}

tree::TerminalNode* OLangParser::MapTypeContext::COMMA() {
  return getToken(OLangParser::COMMA, 0);
}

tree::TerminalNode* OLangParser::MapTypeContext::GT() {
  return getToken(OLangParser::GT, 0);
}


size_t OLangParser::MapTypeContext::getRuleIndex() const {
  return OLangParser::RuleMapType;
}

void OLangParser::MapTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMapType(this);
}

void OLangParser::MapTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMapType(this);
}


std::any OLangParser::MapTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitMapType(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::MapTypeContext* OLangParser::mapType() {
  MapTypeContext *_localctx = _tracker.createInstance<MapTypeContext>(_ctx, getState());
  enterRule(_localctx, 100, OLangParser::RuleMapType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(733);
    match(OLangParser::MAP_TYPE);
    setState(734);
    match(OLangParser::LT);
    setState(735);
    type();
    setState(736);
    match(OLangParser::COMMA);
    setState(737);
    type();
    setState(738);
    match(OLangParser::GT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetTypeContext ------------------------------------------------------------------

OLangParser::SetTypeContext::SetTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::SetTypeContext::SET_TYPE() {
  return getToken(OLangParser::SET_TYPE, 0);
}

tree::TerminalNode* OLangParser::SetTypeContext::LT() {
  return getToken(OLangParser::LT, 0);
}

OLangParser::TypeContext* OLangParser::SetTypeContext::type() {
  return getRuleContext<OLangParser::TypeContext>(0);
}

tree::TerminalNode* OLangParser::SetTypeContext::GT() {
  return getToken(OLangParser::GT, 0);
}


size_t OLangParser::SetTypeContext::getRuleIndex() const {
  return OLangParser::RuleSetType;
}

void OLangParser::SetTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetType(this);
}

void OLangParser::SetTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetType(this);
}


std::any OLangParser::SetTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitSetType(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::SetTypeContext* OLangParser::setType() {
  SetTypeContext *_localctx = _tracker.createInstance<SetTypeContext>(_ctx, getState());
  enterRule(_localctx, 102, OLangParser::RuleSetType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(740);
    match(OLangParser::SET_TYPE);
    setState(741);
    match(OLangParser::LT);
    setState(742);
    type();
    setState(743);
    match(OLangParser::GT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StreamTypeContext ------------------------------------------------------------------

OLangParser::StreamTypeContext::StreamTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::StreamTypeContext::STREAM_TYPE() {
  return getToken(OLangParser::STREAM_TYPE, 0);
}

tree::TerminalNode* OLangParser::StreamTypeContext::LT() {
  return getToken(OLangParser::LT, 0);
}

OLangParser::TypeContext* OLangParser::StreamTypeContext::type() {
  return getRuleContext<OLangParser::TypeContext>(0);
}

tree::TerminalNode* OLangParser::StreamTypeContext::GT() {
  return getToken(OLangParser::GT, 0);
}


size_t OLangParser::StreamTypeContext::getRuleIndex() const {
  return OLangParser::RuleStreamType;
}

void OLangParser::StreamTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStreamType(this);
}

void OLangParser::StreamTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStreamType(this);
}


std::any OLangParser::StreamTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitStreamType(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::StreamTypeContext* OLangParser::streamType() {
  StreamTypeContext *_localctx = _tracker.createInstance<StreamTypeContext>(_ctx, getState());
  enterRule(_localctx, 104, OLangParser::RuleStreamType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(745);
    match(OLangParser::STREAM_TYPE);
    setState(746);
    match(OLangParser::LT);
    setState(747);
    type();
    setState(748);
    match(OLangParser::GT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FutureTypeContext ------------------------------------------------------------------

OLangParser::FutureTypeContext::FutureTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::FutureTypeContext::FUTURE_TYPE() {
  return getToken(OLangParser::FUTURE_TYPE, 0);
}

tree::TerminalNode* OLangParser::FutureTypeContext::LT() {
  return getToken(OLangParser::LT, 0);
}

OLangParser::TypeContext* OLangParser::FutureTypeContext::type() {
  return getRuleContext<OLangParser::TypeContext>(0);
}

tree::TerminalNode* OLangParser::FutureTypeContext::GT() {
  return getToken(OLangParser::GT, 0);
}


size_t OLangParser::FutureTypeContext::getRuleIndex() const {
  return OLangParser::RuleFutureType;
}

void OLangParser::FutureTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFutureType(this);
}

void OLangParser::FutureTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFutureType(this);
}


std::any OLangParser::FutureTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitFutureType(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::FutureTypeContext* OLangParser::futureType() {
  FutureTypeContext *_localctx = _tracker.createInstance<FutureTypeContext>(_ctx, getState());
  enterRule(_localctx, 106, OLangParser::RuleFutureType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(750);
    match(OLangParser::FUTURE_TYPE);
    setState(751);
    match(OLangParser::LT);
    setState(752);
    type();
    setState(753);
    match(OLangParser::GT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResultTypeContext ------------------------------------------------------------------

OLangParser::ResultTypeContext::ResultTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::ResultTypeContext::RESULT_TYPE() {
  return getToken(OLangParser::RESULT_TYPE, 0);
}

tree::TerminalNode* OLangParser::ResultTypeContext::LT() {
  return getToken(OLangParser::LT, 0);
}

std::vector<OLangParser::TypeContext *> OLangParser::ResultTypeContext::type() {
  return getRuleContexts<OLangParser::TypeContext>();
}

OLangParser::TypeContext* OLangParser::ResultTypeContext::type(size_t i) {
  return getRuleContext<OLangParser::TypeContext>(i);
}

tree::TerminalNode* OLangParser::ResultTypeContext::COMMA() {
  return getToken(OLangParser::COMMA, 0);
}

tree::TerminalNode* OLangParser::ResultTypeContext::GT() {
  return getToken(OLangParser::GT, 0);
}


size_t OLangParser::ResultTypeContext::getRuleIndex() const {
  return OLangParser::RuleResultType;
}

void OLangParser::ResultTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResultType(this);
}

void OLangParser::ResultTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResultType(this);
}


std::any OLangParser::ResultTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitResultType(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ResultTypeContext* OLangParser::resultType() {
  ResultTypeContext *_localctx = _tracker.createInstance<ResultTypeContext>(_ctx, getState());
  enterRule(_localctx, 108, OLangParser::RuleResultType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(755);
    match(OLangParser::RESULT_TYPE);
    setState(756);
    match(OLangParser::LT);
    setState(757);
    type();
    setState(758);
    match(OLangParser::COMMA);
    setState(759);
    type();
    setState(760);
    match(OLangParser::GT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionTypeContext ------------------------------------------------------------------

OLangParser::OptionTypeContext::OptionTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::OptionTypeContext::OPTION_TYPE() {
  return getToken(OLangParser::OPTION_TYPE, 0);
}

tree::TerminalNode* OLangParser::OptionTypeContext::LT() {
  return getToken(OLangParser::LT, 0);
}

OLangParser::TypeContext* OLangParser::OptionTypeContext::type() {
  return getRuleContext<OLangParser::TypeContext>(0);
}

tree::TerminalNode* OLangParser::OptionTypeContext::GT() {
  return getToken(OLangParser::GT, 0);
}


size_t OLangParser::OptionTypeContext::getRuleIndex() const {
  return OLangParser::RuleOptionType;
}

void OLangParser::OptionTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionType(this);
}

void OLangParser::OptionTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionType(this);
}


std::any OLangParser::OptionTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitOptionType(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::OptionTypeContext* OLangParser::optionType() {
  OptionTypeContext *_localctx = _tracker.createInstance<OptionTypeContext>(_ctx, getState());
  enterRule(_localctx, 110, OLangParser::RuleOptionType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(762);
    match(OLangParser::OPTION_TYPE);
    setState(763);
    match(OLangParser::LT);
    setState(764);
    type();
    setState(765);
    match(OLangParser::GT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProvenanceTypeContext ------------------------------------------------------------------

OLangParser::ProvenanceTypeContext::ProvenanceTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::ProvenanceTypeContext::PROVENANCE_TYPE() {
  return getToken(OLangParser::PROVENANCE_TYPE, 0);
}

tree::TerminalNode* OLangParser::ProvenanceTypeContext::LT() {
  return getToken(OLangParser::LT, 0);
}

OLangParser::TypeContext* OLangParser::ProvenanceTypeContext::type() {
  return getRuleContext<OLangParser::TypeContext>(0);
}

tree::TerminalNode* OLangParser::ProvenanceTypeContext::GT() {
  return getToken(OLangParser::GT, 0);
}


size_t OLangParser::ProvenanceTypeContext::getRuleIndex() const {
  return OLangParser::RuleProvenanceType;
}

void OLangParser::ProvenanceTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProvenanceType(this);
}

void OLangParser::ProvenanceTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProvenanceType(this);
}


std::any OLangParser::ProvenanceTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitProvenanceType(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ProvenanceTypeContext* OLangParser::provenanceType() {
  ProvenanceTypeContext *_localctx = _tracker.createInstance<ProvenanceTypeContext>(_ctx, getState());
  enterRule(_localctx, 112, OLangParser::RuleProvenanceType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(767);
    match(OLangParser::PROVENANCE_TYPE);
    setState(768);
    match(OLangParser::LT);
    setState(769);
    type();
    setState(770);
    match(OLangParser::GT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionTypeContext ------------------------------------------------------------------

OLangParser::FunctionTypeContext::FunctionTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::FunctionTypeContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

tree::TerminalNode* OLangParser::FunctionTypeContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}

tree::TerminalNode* OLangParser::FunctionTypeContext::ARROW() {
  return getToken(OLangParser::ARROW, 0);
}

OLangParser::TypeContext* OLangParser::FunctionTypeContext::type() {
  return getRuleContext<OLangParser::TypeContext>(0);
}

OLangParser::TypeListContext* OLangParser::FunctionTypeContext::typeList() {
  return getRuleContext<OLangParser::TypeListContext>(0);
}


size_t OLangParser::FunctionTypeContext::getRuleIndex() const {
  return OLangParser::RuleFunctionType;
}

void OLangParser::FunctionTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionType(this);
}

void OLangParser::FunctionTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionType(this);
}


std::any OLangParser::FunctionTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitFunctionType(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::FunctionTypeContext* OLangParser::functionType() {
  FunctionTypeContext *_localctx = _tracker.createInstance<FunctionTypeContext>(_ctx, getState());
  enterRule(_localctx, 114, OLangParser::RuleFunctionType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(772);
    match(OLangParser::LPAREN);
    setState(774);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la - 61) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 61)) & 72057594038451711) != 0 || _la == OLangParser::ID) {
      setState(773);
      typeList();
    }
    setState(776);
    match(OLangParser::RPAREN);
    setState(777);
    match(OLangParser::ARROW);
    setState(778);
    type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParenthesisTypeContext ------------------------------------------------------------------

OLangParser::ParenthesisTypeContext::ParenthesisTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::ParenthesisTypeContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

OLangParser::TypeContext* OLangParser::ParenthesisTypeContext::type() {
  return getRuleContext<OLangParser::TypeContext>(0);
}

tree::TerminalNode* OLangParser::ParenthesisTypeContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}


size_t OLangParser::ParenthesisTypeContext::getRuleIndex() const {
  return OLangParser::RuleParenthesisType;
}

void OLangParser::ParenthesisTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParenthesisType(this);
}

void OLangParser::ParenthesisTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParenthesisType(this);
}


std::any OLangParser::ParenthesisTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitParenthesisType(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ParenthesisTypeContext* OLangParser::parenthesisType() {
  ParenthesisTypeContext *_localctx = _tracker.createInstance<ParenthesisTypeContext>(_ctx, getState());
  enterRule(_localctx, 116, OLangParser::RuleParenthesisType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(780);
    match(OLangParser::LPAREN);
    setState(781);
    type();
    setState(782);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GenericArgumentsContext ------------------------------------------------------------------

OLangParser::GenericArgumentsContext::GenericArgumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::GenericArgumentsContext::LT() {
  return getToken(OLangParser::LT, 0);
}

OLangParser::TypeListContext* OLangParser::GenericArgumentsContext::typeList() {
  return getRuleContext<OLangParser::TypeListContext>(0);
}

tree::TerminalNode* OLangParser::GenericArgumentsContext::GT() {
  return getToken(OLangParser::GT, 0);
}


size_t OLangParser::GenericArgumentsContext::getRuleIndex() const {
  return OLangParser::RuleGenericArguments;
}

void OLangParser::GenericArgumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenericArguments(this);
}

void OLangParser::GenericArgumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenericArguments(this);
}


std::any OLangParser::GenericArgumentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitGenericArguments(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::GenericArgumentsContext* OLangParser::genericArguments() {
  GenericArgumentsContext *_localctx = _tracker.createInstance<GenericArgumentsContext>(_ctx, getState());
  enterRule(_localctx, 118, OLangParser::RuleGenericArguments);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(784);
    match(OLangParser::LT);
    setState(785);
    typeList();
    setState(786);
    match(OLangParser::GT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeListContext ------------------------------------------------------------------

OLangParser::TypeListContext::TypeListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::TypeContext *> OLangParser::TypeListContext::type() {
  return getRuleContexts<OLangParser::TypeContext>();
}

OLangParser::TypeContext* OLangParser::TypeListContext::type(size_t i) {
  return getRuleContext<OLangParser::TypeContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::TypeListContext::COMMA() {
  return getTokens(OLangParser::COMMA);
}

tree::TerminalNode* OLangParser::TypeListContext::COMMA(size_t i) {
  return getToken(OLangParser::COMMA, i);
}


size_t OLangParser::TypeListContext::getRuleIndex() const {
  return OLangParser::RuleTypeList;
}

void OLangParser::TypeListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeList(this);
}

void OLangParser::TypeListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeList(this);
}


std::any OLangParser::TypeListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitTypeList(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::TypeListContext* OLangParser::typeList() {
  TypeListContext *_localctx = _tracker.createInstance<TypeListContext>(_ctx, getState());
  enterRule(_localctx, 120, OLangParser::RuleTypeList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(788);
    type();
    setState(793);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == OLangParser::COMMA) {
      setState(789);
      match(OLangParser::COMMA);
      setState(790);
      type();
      setState(795);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GenericParametersContext ------------------------------------------------------------------

OLangParser::GenericParametersContext::GenericParametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::GenericParametersContext::LT() {
  return getToken(OLangParser::LT, 0);
}

OLangParser::GenericParameterListContext* OLangParser::GenericParametersContext::genericParameterList() {
  return getRuleContext<OLangParser::GenericParameterListContext>(0);
}

tree::TerminalNode* OLangParser::GenericParametersContext::GT() {
  return getToken(OLangParser::GT, 0);
}


size_t OLangParser::GenericParametersContext::getRuleIndex() const {
  return OLangParser::RuleGenericParameters;
}

void OLangParser::GenericParametersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenericParameters(this);
}

void OLangParser::GenericParametersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenericParameters(this);
}


std::any OLangParser::GenericParametersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitGenericParameters(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::GenericParametersContext* OLangParser::genericParameters() {
  GenericParametersContext *_localctx = _tracker.createInstance<GenericParametersContext>(_ctx, getState());
  enterRule(_localctx, 122, OLangParser::RuleGenericParameters);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(796);
    match(OLangParser::LT);
    setState(797);
    genericParameterList();
    setState(798);
    match(OLangParser::GT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GenericParameterListContext ------------------------------------------------------------------

OLangParser::GenericParameterListContext::GenericParameterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::GenericParameterContext *> OLangParser::GenericParameterListContext::genericParameter() {
  return getRuleContexts<OLangParser::GenericParameterContext>();
}

OLangParser::GenericParameterContext* OLangParser::GenericParameterListContext::genericParameter(size_t i) {
  return getRuleContext<OLangParser::GenericParameterContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::GenericParameterListContext::COMMA() {
  return getTokens(OLangParser::COMMA);
}

tree::TerminalNode* OLangParser::GenericParameterListContext::COMMA(size_t i) {
  return getToken(OLangParser::COMMA, i);
}


size_t OLangParser::GenericParameterListContext::getRuleIndex() const {
  return OLangParser::RuleGenericParameterList;
}

void OLangParser::GenericParameterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenericParameterList(this);
}

void OLangParser::GenericParameterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenericParameterList(this);
}


std::any OLangParser::GenericParameterListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitGenericParameterList(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::GenericParameterListContext* OLangParser::genericParameterList() {
  GenericParameterListContext *_localctx = _tracker.createInstance<GenericParameterListContext>(_ctx, getState());
  enterRule(_localctx, 124, OLangParser::RuleGenericParameterList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(800);
    genericParameter();
    setState(805);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == OLangParser::COMMA) {
      setState(801);
      match(OLangParser::COMMA);
      setState(802);
      genericParameter();
      setState(807);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GenericParameterContext ------------------------------------------------------------------

OLangParser::GenericParameterContext::GenericParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::GenericParameterContext::ID() {
  return getToken(OLangParser::ID, 0);
}

std::vector<OLangParser::GenericParameterConstraintContext *> OLangParser::GenericParameterContext::genericParameterConstraint() {
  return getRuleContexts<OLangParser::GenericParameterConstraintContext>();
}

OLangParser::GenericParameterConstraintContext* OLangParser::GenericParameterContext::genericParameterConstraint(size_t i) {
  return getRuleContext<OLangParser::GenericParameterConstraintContext>(i);
}


size_t OLangParser::GenericParameterContext::getRuleIndex() const {
  return OLangParser::RuleGenericParameter;
}

void OLangParser::GenericParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenericParameter(this);
}

void OLangParser::GenericParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenericParameter(this);
}


std::any OLangParser::GenericParameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitGenericParameter(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::GenericParameterContext* OLangParser::genericParameter() {
  GenericParameterContext *_localctx = _tracker.createInstance<GenericParameterContext>(_ctx, getState());
  enterRule(_localctx, 126, OLangParser::RuleGenericParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(808);
    match(OLangParser::ID);
    setState(812);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == OLangParser::EXTENDS || _la == OLangParser::COLON

    || _la == OLangParser::EQUALS) {
      setState(809);
      genericParameterConstraint();
      setState(814);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GenericParameterConstraintContext ------------------------------------------------------------------

OLangParser::GenericParameterConstraintContext::GenericParameterConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::GenericParameterConstraintContext::COLON() {
  return getToken(OLangParser::COLON, 0);
}

OLangParser::TypeContext* OLangParser::GenericParameterConstraintContext::type() {
  return getRuleContext<OLangParser::TypeContext>(0);
}

tree::TerminalNode* OLangParser::GenericParameterConstraintContext::EQUALS() {
  return getToken(OLangParser::EQUALS, 0);
}

tree::TerminalNode* OLangParser::GenericParameterConstraintContext::EXTENDS() {
  return getToken(OLangParser::EXTENDS, 0);
}


size_t OLangParser::GenericParameterConstraintContext::getRuleIndex() const {
  return OLangParser::RuleGenericParameterConstraint;
}

void OLangParser::GenericParameterConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenericParameterConstraint(this);
}

void OLangParser::GenericParameterConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenericParameterConstraint(this);
}


std::any OLangParser::GenericParameterConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitGenericParameterConstraint(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::GenericParameterConstraintContext* OLangParser::genericParameterConstraint() {
  GenericParameterConstraintContext *_localctx = _tracker.createInstance<GenericParameterConstraintContext>(_ctx, getState());
  enterRule(_localctx, 128, OLangParser::RuleGenericParameterConstraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(821);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case OLangParser::COLON: {
        enterOuterAlt(_localctx, 1);
        setState(815);
        match(OLangParser::COLON);
        setState(816);
        type();
        break;
      }

      case OLangParser::EQUALS: {
        enterOuterAlt(_localctx, 2);
        setState(817);
        match(OLangParser::EQUALS);
        setState(818);
        type();
        break;
      }

      case OLangParser::EXTENDS: {
        enterOuterAlt(_localctx, 3);
        setState(819);
        match(OLangParser::EXTENDS);
        setState(820);
        type();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhereClauseContext ------------------------------------------------------------------

OLangParser::WhereClauseContext::WhereClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::WhereClauseContext::WHERE() {
  return getToken(OLangParser::WHERE, 0);
}

OLangParser::ConstraintListContext* OLangParser::WhereClauseContext::constraintList() {
  return getRuleContext<OLangParser::ConstraintListContext>(0);
}


size_t OLangParser::WhereClauseContext::getRuleIndex() const {
  return OLangParser::RuleWhereClause;
}

void OLangParser::WhereClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhereClause(this);
}

void OLangParser::WhereClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhereClause(this);
}


std::any OLangParser::WhereClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitWhereClause(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::WhereClauseContext* OLangParser::whereClause() {
  WhereClauseContext *_localctx = _tracker.createInstance<WhereClauseContext>(_ctx, getState());
  enterRule(_localctx, 130, OLangParser::RuleWhereClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(823);
    match(OLangParser::WHERE);
    setState(824);
    constraintList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintListContext ------------------------------------------------------------------

OLangParser::ConstraintListContext::ConstraintListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::ConstraintContext *> OLangParser::ConstraintListContext::constraint() {
  return getRuleContexts<OLangParser::ConstraintContext>();
}

OLangParser::ConstraintContext* OLangParser::ConstraintListContext::constraint(size_t i) {
  return getRuleContext<OLangParser::ConstraintContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::ConstraintListContext::COMMA() {
  return getTokens(OLangParser::COMMA);
}

tree::TerminalNode* OLangParser::ConstraintListContext::COMMA(size_t i) {
  return getToken(OLangParser::COMMA, i);
}


size_t OLangParser::ConstraintListContext::getRuleIndex() const {
  return OLangParser::RuleConstraintList;
}

void OLangParser::ConstraintListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraintList(this);
}

void OLangParser::ConstraintListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraintList(this);
}


std::any OLangParser::ConstraintListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitConstraintList(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ConstraintListContext* OLangParser::constraintList() {
  ConstraintListContext *_localctx = _tracker.createInstance<ConstraintListContext>(_ctx, getState());
  enterRule(_localctx, 132, OLangParser::RuleConstraintList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(826);
    constraint();
    setState(831);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == OLangParser::COMMA) {
      setState(827);
      match(OLangParser::COMMA);
      setState(828);
      constraint();
      setState(833);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintContext ------------------------------------------------------------------

OLangParser::ConstraintContext::ConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::ConstraintContext::ID() {
  return getToken(OLangParser::ID, 0);
}

tree::TerminalNode* OLangParser::ConstraintContext::COLON() {
  return getToken(OLangParser::COLON, 0);
}

OLangParser::TypeContext* OLangParser::ConstraintContext::type() {
  return getRuleContext<OLangParser::TypeContext>(0);
}

tree::TerminalNode* OLangParser::ConstraintContext::EQUALS() {
  return getToken(OLangParser::EQUALS, 0);
}

tree::TerminalNode* OLangParser::ConstraintContext::EXTENDS() {
  return getToken(OLangParser::EXTENDS, 0);
}

OLangParser::ExpressionContext* OLangParser::ConstraintContext::expression() {
  return getRuleContext<OLangParser::ExpressionContext>(0);
}


size_t OLangParser::ConstraintContext::getRuleIndex() const {
  return OLangParser::RuleConstraint;
}

void OLangParser::ConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraint(this);
}

void OLangParser::ConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraint(this);
}


std::any OLangParser::ConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitConstraint(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ConstraintContext* OLangParser::constraint() {
  ConstraintContext *_localctx = _tracker.createInstance<ConstraintContext>(_ctx, getState());
  enterRule(_localctx, 134, OLangParser::RuleConstraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(844);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(834);
      match(OLangParser::ID);
      setState(835);
      match(OLangParser::COLON);
      setState(836);
      type();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(837);
      match(OLangParser::ID);
      setState(838);
      match(OLangParser::EQUALS);
      setState(839);
      type();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(840);
      match(OLangParser::ID);
      setState(841);
      match(OLangParser::EXTENDS);
      setState(842);
      type();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(843);
      expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypedFieldContext ------------------------------------------------------------------

OLangParser::TypedFieldContext::TypedFieldContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::TypedFieldContext::ID() {
  return getToken(OLangParser::ID, 0);
}

tree::TerminalNode* OLangParser::TypedFieldContext::COLON() {
  return getToken(OLangParser::COLON, 0);
}

OLangParser::TypeContext* OLangParser::TypedFieldContext::type() {
  return getRuleContext<OLangParser::TypeContext>(0);
}


size_t OLangParser::TypedFieldContext::getRuleIndex() const {
  return OLangParser::RuleTypedField;
}

void OLangParser::TypedFieldContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypedField(this);
}

void OLangParser::TypedFieldContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypedField(this);
}


std::any OLangParser::TypedFieldContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitTypedField(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::TypedFieldContext* OLangParser::typedField() {
  TypedFieldContext *_localctx = _tracker.createInstance<TypedFieldContext>(_ctx, getState());
  enterRule(_localctx, 136, OLangParser::RuleTypedField);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(846);
    match(OLangParser::ID);
    setState(847);
    match(OLangParser::COLON);
    setState(848);
    type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypedFieldListContext ------------------------------------------------------------------

OLangParser::TypedFieldListContext::TypedFieldListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::TypedFieldContext *> OLangParser::TypedFieldListContext::typedField() {
  return getRuleContexts<OLangParser::TypedFieldContext>();
}

OLangParser::TypedFieldContext* OLangParser::TypedFieldListContext::typedField(size_t i) {
  return getRuleContext<OLangParser::TypedFieldContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::TypedFieldListContext::COMMA() {
  return getTokens(OLangParser::COMMA);
}

tree::TerminalNode* OLangParser::TypedFieldListContext::COMMA(size_t i) {
  return getToken(OLangParser::COMMA, i);
}


size_t OLangParser::TypedFieldListContext::getRuleIndex() const {
  return OLangParser::RuleTypedFieldList;
}

void OLangParser::TypedFieldListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypedFieldList(this);
}

void OLangParser::TypedFieldListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypedFieldList(this);
}


std::any OLangParser::TypedFieldListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitTypedFieldList(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::TypedFieldListContext* OLangParser::typedFieldList() {
  TypedFieldListContext *_localctx = _tracker.createInstance<TypedFieldListContext>(_ctx, getState());
  enterRule(_localctx, 138, OLangParser::RuleTypedFieldList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(850);
    typedField();
    setState(855);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == OLangParser::COMMA) {
      setState(851);
      match(OLangParser::COMMA);
      setState(852);
      typedField();
      setState(857);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypedParameterContext ------------------------------------------------------------------

OLangParser::TypedParameterContext::TypedParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::TypedParameterContext::ID() {
  return getToken(OLangParser::ID, 0);
}

tree::TerminalNode* OLangParser::TypedParameterContext::COLON() {
  return getToken(OLangParser::COLON, 0);
}

OLangParser::TypeContext* OLangParser::TypedParameterContext::type() {
  return getRuleContext<OLangParser::TypeContext>(0);
}


size_t OLangParser::TypedParameterContext::getRuleIndex() const {
  return OLangParser::RuleTypedParameter;
}

void OLangParser::TypedParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypedParameter(this);
}

void OLangParser::TypedParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypedParameter(this);
}


std::any OLangParser::TypedParameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitTypedParameter(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::TypedParameterContext* OLangParser::typedParameter() {
  TypedParameterContext *_localctx = _tracker.createInstance<TypedParameterContext>(_ctx, getState());
  enterRule(_localctx, 140, OLangParser::RuleTypedParameter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(858);
    match(OLangParser::ID);
    setState(859);
    match(OLangParser::COLON);
    setState(860);
    type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypedParameterListContext ------------------------------------------------------------------

OLangParser::TypedParameterListContext::TypedParameterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::TypedParameterContext *> OLangParser::TypedParameterListContext::typedParameter() {
  return getRuleContexts<OLangParser::TypedParameterContext>();
}

OLangParser::TypedParameterContext* OLangParser::TypedParameterListContext::typedParameter(size_t i) {
  return getRuleContext<OLangParser::TypedParameterContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::TypedParameterListContext::COMMA() {
  return getTokens(OLangParser::COMMA);
}

tree::TerminalNode* OLangParser::TypedParameterListContext::COMMA(size_t i) {
  return getToken(OLangParser::COMMA, i);
}


size_t OLangParser::TypedParameterListContext::getRuleIndex() const {
  return OLangParser::RuleTypedParameterList;
}

void OLangParser::TypedParameterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypedParameterList(this);
}

void OLangParser::TypedParameterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypedParameterList(this);
}


std::any OLangParser::TypedParameterListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitTypedParameterList(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::TypedParameterListContext* OLangParser::typedParameterList() {
  TypedParameterListContext *_localctx = _tracker.createInstance<TypedParameterListContext>(_ctx, getState());
  enterRule(_localctx, 142, OLangParser::RuleTypedParameterList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(862);
    typedParameter();
    setState(867);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == OLangParser::COMMA) {
      setState(863);
      match(OLangParser::COMMA);
      setState(864);
      typedParameter();
      setState(869);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionalExpressionContext ------------------------------------------------------------------

OLangParser::FunctionalExpressionContext::FunctionalExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::MapExpressionContext* OLangParser::FunctionalExpressionContext::mapExpression() {
  return getRuleContext<OLangParser::MapExpressionContext>(0);
}

OLangParser::FilterExpressionContext* OLangParser::FunctionalExpressionContext::filterExpression() {
  return getRuleContext<OLangParser::FilterExpressionContext>(0);
}

OLangParser::ReduceExpressionContext* OLangParser::FunctionalExpressionContext::reduceExpression() {
  return getRuleContext<OLangParser::ReduceExpressionContext>(0);
}

OLangParser::ForeachExpressionContext* OLangParser::FunctionalExpressionContext::foreachExpression() {
  return getRuleContext<OLangParser::ForeachExpressionContext>(0);
}

OLangParser::GroupByExpressionContext* OLangParser::FunctionalExpressionContext::groupByExpression() {
  return getRuleContext<OLangParser::GroupByExpressionContext>(0);
}

OLangParser::FlatMapExpressionContext* OLangParser::FunctionalExpressionContext::flatMapExpression() {
  return getRuleContext<OLangParser::FlatMapExpressionContext>(0);
}

OLangParser::ZipExpressionContext* OLangParser::FunctionalExpressionContext::zipExpression() {
  return getRuleContext<OLangParser::ZipExpressionContext>(0);
}

OLangParser::PartitionExpressionContext* OLangParser::FunctionalExpressionContext::partitionExpression() {
  return getRuleContext<OLangParser::PartitionExpressionContext>(0);
}

OLangParser::TakeExpressionContext* OLangParser::FunctionalExpressionContext::takeExpression() {
  return getRuleContext<OLangParser::TakeExpressionContext>(0);
}

OLangParser::DropExpressionContext* OLangParser::FunctionalExpressionContext::dropExpression() {
  return getRuleContext<OLangParser::DropExpressionContext>(0);
}

OLangParser::TakeWhileExpressionContext* OLangParser::FunctionalExpressionContext::takeWhileExpression() {
  return getRuleContext<OLangParser::TakeWhileExpressionContext>(0);
}

OLangParser::DropWhileExpressionContext* OLangParser::FunctionalExpressionContext::dropWhileExpression() {
  return getRuleContext<OLangParser::DropWhileExpressionContext>(0);
}

OLangParser::SortByExpressionContext* OLangParser::FunctionalExpressionContext::sortByExpression() {
  return getRuleContext<OLangParser::SortByExpressionContext>(0);
}

OLangParser::DistinctExpressionContext* OLangParser::FunctionalExpressionContext::distinctExpression() {
  return getRuleContext<OLangParser::DistinctExpressionContext>(0);
}

OLangParser::CountExpressionContext* OLangParser::FunctionalExpressionContext::countExpression() {
  return getRuleContext<OLangParser::CountExpressionContext>(0);
}

OLangParser::FindExpressionContext* OLangParser::FunctionalExpressionContext::findExpression() {
  return getRuleContext<OLangParser::FindExpressionContext>(0);
}

OLangParser::AnyExpressionContext* OLangParser::FunctionalExpressionContext::anyExpression() {
  return getRuleContext<OLangParser::AnyExpressionContext>(0);
}

OLangParser::AllExpressionContext* OLangParser::FunctionalExpressionContext::allExpression() {
  return getRuleContext<OLangParser::AllExpressionContext>(0);
}

OLangParser::JoinExpressionContext* OLangParser::FunctionalExpressionContext::joinExpression() {
  return getRuleContext<OLangParser::JoinExpressionContext>(0);
}

OLangParser::WindowExpressionContext* OLangParser::FunctionalExpressionContext::windowExpression() {
  return getRuleContext<OLangParser::WindowExpressionContext>(0);
}

OLangParser::ChunkExpressionContext* OLangParser::FunctionalExpressionContext::chunkExpression() {
  return getRuleContext<OLangParser::ChunkExpressionContext>(0);
}

OLangParser::ScanExpressionContext* OLangParser::FunctionalExpressionContext::scanExpression() {
  return getRuleContext<OLangParser::ScanExpressionContext>(0);
}

OLangParser::CollectExpressionContext* OLangParser::FunctionalExpressionContext::collectExpression() {
  return getRuleContext<OLangParser::CollectExpressionContext>(0);
}


size_t OLangParser::FunctionalExpressionContext::getRuleIndex() const {
  return OLangParser::RuleFunctionalExpression;
}

void OLangParser::FunctionalExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionalExpression(this);
}

void OLangParser::FunctionalExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionalExpression(this);
}


std::any OLangParser::FunctionalExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitFunctionalExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::FunctionalExpressionContext* OLangParser::functionalExpression() {
  FunctionalExpressionContext *_localctx = _tracker.createInstance<FunctionalExpressionContext>(_ctx, getState());
  enterRule(_localctx, 144, OLangParser::RuleFunctionalExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(893);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case OLangParser::MAP: {
        enterOuterAlt(_localctx, 1);
        setState(870);
        mapExpression();
        break;
      }

      case OLangParser::FILTER: {
        enterOuterAlt(_localctx, 2);
        setState(871);
        filterExpression();
        break;
      }

      case OLangParser::REDUCE: {
        enterOuterAlt(_localctx, 3);
        setState(872);
        reduceExpression();
        break;
      }

      case OLangParser::FOREACH: {
        enterOuterAlt(_localctx, 4);
        setState(873);
        foreachExpression();
        break;
      }

      case OLangParser::GROUP_BY: {
        enterOuterAlt(_localctx, 5);
        setState(874);
        groupByExpression();
        break;
      }

      case OLangParser::FLATMAP: {
        enterOuterAlt(_localctx, 6);
        setState(875);
        flatMapExpression();
        break;
      }

      case OLangParser::ZIP: {
        enterOuterAlt(_localctx, 7);
        setState(876);
        zipExpression();
        break;
      }

      case OLangParser::PARTITION: {
        enterOuterAlt(_localctx, 8);
        setState(877);
        partitionExpression();
        break;
      }

      case OLangParser::TAKE: {
        enterOuterAlt(_localctx, 9);
        setState(878);
        takeExpression();
        break;
      }

      case OLangParser::DROP: {
        enterOuterAlt(_localctx, 10);
        setState(879);
        dropExpression();
        break;
      }

      case OLangParser::TAKE_WHILE: {
        enterOuterAlt(_localctx, 11);
        setState(880);
        takeWhileExpression();
        break;
      }

      case OLangParser::DROP_WHILE: {
        enterOuterAlt(_localctx, 12);
        setState(881);
        dropWhileExpression();
        break;
      }

      case OLangParser::SORT_BY: {
        enterOuterAlt(_localctx, 13);
        setState(882);
        sortByExpression();
        break;
      }

      case OLangParser::DISTINCT: {
        enterOuterAlt(_localctx, 14);
        setState(883);
        distinctExpression();
        break;
      }

      case OLangParser::COUNT: {
        enterOuterAlt(_localctx, 15);
        setState(884);
        countExpression();
        break;
      }

      case OLangParser::FIND: {
        enterOuterAlt(_localctx, 16);
        setState(885);
        findExpression();
        break;
      }

      case OLangParser::ANY: {
        enterOuterAlt(_localctx, 17);
        setState(886);
        anyExpression();
        break;
      }

      case OLangParser::ALL: {
        enterOuterAlt(_localctx, 18);
        setState(887);
        allExpression();
        break;
      }

      case OLangParser::JOIN: {
        enterOuterAlt(_localctx, 19);
        setState(888);
        joinExpression();
        break;
      }

      case OLangParser::WINDOW: {
        enterOuterAlt(_localctx, 20);
        setState(889);
        windowExpression();
        break;
      }

      case OLangParser::CHUNK: {
        enterOuterAlt(_localctx, 21);
        setState(890);
        chunkExpression();
        break;
      }

      case OLangParser::SCAN: {
        enterOuterAlt(_localctx, 22);
        setState(891);
        scanExpression();
        break;
      }

      case OLangParser::COLLECT: {
        enterOuterAlt(_localctx, 23);
        setState(892);
        collectExpression();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MapExpressionContext ------------------------------------------------------------------

OLangParser::MapExpressionContext::MapExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::MapExpressionContext::MAP() {
  return getToken(OLangParser::MAP, 0);
}

tree::TerminalNode* OLangParser::MapExpressionContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

tree::TerminalNode* OLangParser::MapExpressionContext::COMMA() {
  return getToken(OLangParser::COMMA, 0);
}

std::vector<OLangParser::ExpressionContext *> OLangParser::MapExpressionContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::MapExpressionContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}

tree::TerminalNode* OLangParser::MapExpressionContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}

OLangParser::LambdaExpressionContext* OLangParser::MapExpressionContext::lambdaExpression() {
  return getRuleContext<OLangParser::LambdaExpressionContext>(0);
}


size_t OLangParser::MapExpressionContext::getRuleIndex() const {
  return OLangParser::RuleMapExpression;
}

void OLangParser::MapExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMapExpression(this);
}

void OLangParser::MapExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMapExpression(this);
}


std::any OLangParser::MapExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitMapExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::MapExpressionContext* OLangParser::mapExpression() {
  MapExpressionContext *_localctx = _tracker.createInstance<MapExpressionContext>(_ctx, getState());
  enterRule(_localctx, 146, OLangParser::RuleMapExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(895);
    match(OLangParser::MAP);
    setState(896);
    match(OLangParser::LPAREN);
    setState(899);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 55, _ctx)) {
    case 1: {
      setState(897);
      lambdaExpression();
      break;
    }

    case 2: {
      setState(898);
      expression();
      break;
    }

    default:
      break;
    }
    setState(901);
    match(OLangParser::COMMA);
    setState(902);
    expression();
    setState(903);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterExpressionContext ------------------------------------------------------------------

OLangParser::FilterExpressionContext::FilterExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::FilterExpressionContext::FILTER() {
  return getToken(OLangParser::FILTER, 0);
}

tree::TerminalNode* OLangParser::FilterExpressionContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

std::vector<OLangParser::ExpressionContext *> OLangParser::FilterExpressionContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::FilterExpressionContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}

tree::TerminalNode* OLangParser::FilterExpressionContext::COMMA() {
  return getToken(OLangParser::COMMA, 0);
}

tree::TerminalNode* OLangParser::FilterExpressionContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}

OLangParser::LambdaExpressionContext* OLangParser::FilterExpressionContext::lambdaExpression() {
  return getRuleContext<OLangParser::LambdaExpressionContext>(0);
}


size_t OLangParser::FilterExpressionContext::getRuleIndex() const {
  return OLangParser::RuleFilterExpression;
}

void OLangParser::FilterExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterExpression(this);
}

void OLangParser::FilterExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterExpression(this);
}


std::any OLangParser::FilterExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitFilterExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::FilterExpressionContext* OLangParser::filterExpression() {
  FilterExpressionContext *_localctx = _tracker.createInstance<FilterExpressionContext>(_ctx, getState());
  enterRule(_localctx, 148, OLangParser::RuleFilterExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(905);
    match(OLangParser::FILTER);
    setState(906);
    match(OLangParser::LPAREN);
    setState(907);
    expression();
    setState(908);
    match(OLangParser::COMMA);
    setState(911);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 56, _ctx)) {
    case 1: {
      setState(909);
      lambdaExpression();
      break;
    }

    case 2: {
      setState(910);
      expression();
      break;
    }

    default:
      break;
    }
    setState(913);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReduceExpressionContext ------------------------------------------------------------------

OLangParser::ReduceExpressionContext::ReduceExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::ReduceExpressionContext::REDUCE() {
  return getToken(OLangParser::REDUCE, 0);
}

tree::TerminalNode* OLangParser::ReduceExpressionContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

std::vector<OLangParser::ExpressionContext *> OLangParser::ReduceExpressionContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::ReduceExpressionContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::ReduceExpressionContext::COMMA() {
  return getTokens(OLangParser::COMMA);
}

tree::TerminalNode* OLangParser::ReduceExpressionContext::COMMA(size_t i) {
  return getToken(OLangParser::COMMA, i);
}

tree::TerminalNode* OLangParser::ReduceExpressionContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}

OLangParser::LambdaExpressionContext* OLangParser::ReduceExpressionContext::lambdaExpression() {
  return getRuleContext<OLangParser::LambdaExpressionContext>(0);
}


size_t OLangParser::ReduceExpressionContext::getRuleIndex() const {
  return OLangParser::RuleReduceExpression;
}

void OLangParser::ReduceExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReduceExpression(this);
}

void OLangParser::ReduceExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReduceExpression(this);
}


std::any OLangParser::ReduceExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitReduceExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ReduceExpressionContext* OLangParser::reduceExpression() {
  ReduceExpressionContext *_localctx = _tracker.createInstance<ReduceExpressionContext>(_ctx, getState());
  enterRule(_localctx, 150, OLangParser::RuleReduceExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(915);
    match(OLangParser::REDUCE);
    setState(916);
    match(OLangParser::LPAREN);
    setState(917);
    expression();
    setState(918);
    match(OLangParser::COMMA);
    setState(921);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx)) {
    case 1: {
      setState(919);
      lambdaExpression();
      break;
    }

    case 2: {
      setState(920);
      expression();
      break;
    }

    default:
      break;
    }
    setState(925);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == OLangParser::COMMA) {
      setState(923);
      match(OLangParser::COMMA);
      setState(924);
      expression();
    }
    setState(927);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ForeachExpressionContext ------------------------------------------------------------------

OLangParser::ForeachExpressionContext::ForeachExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::ForeachExpressionContext::FOREACH() {
  return getToken(OLangParser::FOREACH, 0);
}

tree::TerminalNode* OLangParser::ForeachExpressionContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

std::vector<OLangParser::ExpressionContext *> OLangParser::ForeachExpressionContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::ForeachExpressionContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}

tree::TerminalNode* OLangParser::ForeachExpressionContext::COMMA() {
  return getToken(OLangParser::COMMA, 0);
}

tree::TerminalNode* OLangParser::ForeachExpressionContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}

OLangParser::LambdaExpressionContext* OLangParser::ForeachExpressionContext::lambdaExpression() {
  return getRuleContext<OLangParser::LambdaExpressionContext>(0);
}


size_t OLangParser::ForeachExpressionContext::getRuleIndex() const {
  return OLangParser::RuleForeachExpression;
}

void OLangParser::ForeachExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForeachExpression(this);
}

void OLangParser::ForeachExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForeachExpression(this);
}


std::any OLangParser::ForeachExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitForeachExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ForeachExpressionContext* OLangParser::foreachExpression() {
  ForeachExpressionContext *_localctx = _tracker.createInstance<ForeachExpressionContext>(_ctx, getState());
  enterRule(_localctx, 152, OLangParser::RuleForeachExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(929);
    match(OLangParser::FOREACH);
    setState(930);
    match(OLangParser::LPAREN);
    setState(931);
    expression();
    setState(932);
    match(OLangParser::COMMA);
    setState(935);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx)) {
    case 1: {
      setState(933);
      lambdaExpression();
      break;
    }

    case 2: {
      setState(934);
      expression();
      break;
    }

    default:
      break;
    }
    setState(937);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupByExpressionContext ------------------------------------------------------------------

OLangParser::GroupByExpressionContext::GroupByExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::GroupByExpressionContext::GROUP_BY() {
  return getToken(OLangParser::GROUP_BY, 0);
}

tree::TerminalNode* OLangParser::GroupByExpressionContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

std::vector<OLangParser::ExpressionContext *> OLangParser::GroupByExpressionContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::GroupByExpressionContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}

tree::TerminalNode* OLangParser::GroupByExpressionContext::COMMA() {
  return getToken(OLangParser::COMMA, 0);
}

tree::TerminalNode* OLangParser::GroupByExpressionContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}

OLangParser::LambdaExpressionContext* OLangParser::GroupByExpressionContext::lambdaExpression() {
  return getRuleContext<OLangParser::LambdaExpressionContext>(0);
}


size_t OLangParser::GroupByExpressionContext::getRuleIndex() const {
  return OLangParser::RuleGroupByExpression;
}

void OLangParser::GroupByExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupByExpression(this);
}

void OLangParser::GroupByExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupByExpression(this);
}


std::any OLangParser::GroupByExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitGroupByExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::GroupByExpressionContext* OLangParser::groupByExpression() {
  GroupByExpressionContext *_localctx = _tracker.createInstance<GroupByExpressionContext>(_ctx, getState());
  enterRule(_localctx, 154, OLangParser::RuleGroupByExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(939);
    match(OLangParser::GROUP_BY);
    setState(940);
    match(OLangParser::LPAREN);
    setState(941);
    expression();
    setState(942);
    match(OLangParser::COMMA);
    setState(945);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx)) {
    case 1: {
      setState(943);
      lambdaExpression();
      break;
    }

    case 2: {
      setState(944);
      expression();
      break;
    }

    default:
      break;
    }
    setState(947);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FlatMapExpressionContext ------------------------------------------------------------------

OLangParser::FlatMapExpressionContext::FlatMapExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::FlatMapExpressionContext::FLATMAP() {
  return getToken(OLangParser::FLATMAP, 0);
}

tree::TerminalNode* OLangParser::FlatMapExpressionContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

std::vector<OLangParser::ExpressionContext *> OLangParser::FlatMapExpressionContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::FlatMapExpressionContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}

tree::TerminalNode* OLangParser::FlatMapExpressionContext::COMMA() {
  return getToken(OLangParser::COMMA, 0);
}

tree::TerminalNode* OLangParser::FlatMapExpressionContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}

OLangParser::LambdaExpressionContext* OLangParser::FlatMapExpressionContext::lambdaExpression() {
  return getRuleContext<OLangParser::LambdaExpressionContext>(0);
}


size_t OLangParser::FlatMapExpressionContext::getRuleIndex() const {
  return OLangParser::RuleFlatMapExpression;
}

void OLangParser::FlatMapExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFlatMapExpression(this);
}

void OLangParser::FlatMapExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFlatMapExpression(this);
}


std::any OLangParser::FlatMapExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitFlatMapExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::FlatMapExpressionContext* OLangParser::flatMapExpression() {
  FlatMapExpressionContext *_localctx = _tracker.createInstance<FlatMapExpressionContext>(_ctx, getState());
  enterRule(_localctx, 156, OLangParser::RuleFlatMapExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(949);
    match(OLangParser::FLATMAP);
    setState(950);
    match(OLangParser::LPAREN);
    setState(951);
    expression();
    setState(952);
    match(OLangParser::COMMA);
    setState(955);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx)) {
    case 1: {
      setState(953);
      lambdaExpression();
      break;
    }

    case 2: {
      setState(954);
      expression();
      break;
    }

    default:
      break;
    }
    setState(957);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ZipExpressionContext ------------------------------------------------------------------

OLangParser::ZipExpressionContext::ZipExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::ZipExpressionContext::ZIP() {
  return getToken(OLangParser::ZIP, 0);
}

tree::TerminalNode* OLangParser::ZipExpressionContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

std::vector<OLangParser::ExpressionContext *> OLangParser::ZipExpressionContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::ZipExpressionContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::ZipExpressionContext::COMMA() {
  return getTokens(OLangParser::COMMA);
}

tree::TerminalNode* OLangParser::ZipExpressionContext::COMMA(size_t i) {
  return getToken(OLangParser::COMMA, i);
}

tree::TerminalNode* OLangParser::ZipExpressionContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}

OLangParser::LambdaExpressionContext* OLangParser::ZipExpressionContext::lambdaExpression() {
  return getRuleContext<OLangParser::LambdaExpressionContext>(0);
}


size_t OLangParser::ZipExpressionContext::getRuleIndex() const {
  return OLangParser::RuleZipExpression;
}

void OLangParser::ZipExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterZipExpression(this);
}

void OLangParser::ZipExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitZipExpression(this);
}


std::any OLangParser::ZipExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitZipExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ZipExpressionContext* OLangParser::zipExpression() {
  ZipExpressionContext *_localctx = _tracker.createInstance<ZipExpressionContext>(_ctx, getState());
  enterRule(_localctx, 158, OLangParser::RuleZipExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(959);
    match(OLangParser::ZIP);
    setState(960);
    match(OLangParser::LPAREN);
    setState(961);
    expression();
    setState(962);
    match(OLangParser::COMMA);
    setState(963);
    expression();
    setState(966);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == OLangParser::COMMA) {
      setState(964);
      match(OLangParser::COMMA);
      setState(965);
      lambdaExpression();
    }
    setState(968);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionExpressionContext ------------------------------------------------------------------

OLangParser::PartitionExpressionContext::PartitionExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::PartitionExpressionContext::PARTITION() {
  return getToken(OLangParser::PARTITION, 0);
}

tree::TerminalNode* OLangParser::PartitionExpressionContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

std::vector<OLangParser::ExpressionContext *> OLangParser::PartitionExpressionContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::PartitionExpressionContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}

tree::TerminalNode* OLangParser::PartitionExpressionContext::COMMA() {
  return getToken(OLangParser::COMMA, 0);
}

tree::TerminalNode* OLangParser::PartitionExpressionContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}

OLangParser::LambdaExpressionContext* OLangParser::PartitionExpressionContext::lambdaExpression() {
  return getRuleContext<OLangParser::LambdaExpressionContext>(0);
}


size_t OLangParser::PartitionExpressionContext::getRuleIndex() const {
  return OLangParser::RulePartitionExpression;
}

void OLangParser::PartitionExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionExpression(this);
}

void OLangParser::PartitionExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionExpression(this);
}


std::any OLangParser::PartitionExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitPartitionExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::PartitionExpressionContext* OLangParser::partitionExpression() {
  PartitionExpressionContext *_localctx = _tracker.createInstance<PartitionExpressionContext>(_ctx, getState());
  enterRule(_localctx, 160, OLangParser::RulePartitionExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(970);
    match(OLangParser::PARTITION);
    setState(971);
    match(OLangParser::LPAREN);
    setState(972);
    expression();
    setState(973);
    match(OLangParser::COMMA);
    setState(976);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx)) {
    case 1: {
      setState(974);
      lambdaExpression();
      break;
    }

    case 2: {
      setState(975);
      expression();
      break;
    }

    default:
      break;
    }
    setState(978);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TakeExpressionContext ------------------------------------------------------------------

OLangParser::TakeExpressionContext::TakeExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::TakeExpressionContext::TAKE() {
  return getToken(OLangParser::TAKE, 0);
}

tree::TerminalNode* OLangParser::TakeExpressionContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

std::vector<OLangParser::ExpressionContext *> OLangParser::TakeExpressionContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::TakeExpressionContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}

tree::TerminalNode* OLangParser::TakeExpressionContext::COMMA() {
  return getToken(OLangParser::COMMA, 0);
}

tree::TerminalNode* OLangParser::TakeExpressionContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}


size_t OLangParser::TakeExpressionContext::getRuleIndex() const {
  return OLangParser::RuleTakeExpression;
}

void OLangParser::TakeExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTakeExpression(this);
}

void OLangParser::TakeExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTakeExpression(this);
}


std::any OLangParser::TakeExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitTakeExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::TakeExpressionContext* OLangParser::takeExpression() {
  TakeExpressionContext *_localctx = _tracker.createInstance<TakeExpressionContext>(_ctx, getState());
  enterRule(_localctx, 162, OLangParser::RuleTakeExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(980);
    match(OLangParser::TAKE);
    setState(981);
    match(OLangParser::LPAREN);
    setState(982);
    expression();
    setState(983);
    match(OLangParser::COMMA);
    setState(984);
    expression();
    setState(985);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropExpressionContext ------------------------------------------------------------------

OLangParser::DropExpressionContext::DropExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::DropExpressionContext::DROP() {
  return getToken(OLangParser::DROP, 0);
}

tree::TerminalNode* OLangParser::DropExpressionContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

std::vector<OLangParser::ExpressionContext *> OLangParser::DropExpressionContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::DropExpressionContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}

tree::TerminalNode* OLangParser::DropExpressionContext::COMMA() {
  return getToken(OLangParser::COMMA, 0);
}

tree::TerminalNode* OLangParser::DropExpressionContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}


size_t OLangParser::DropExpressionContext::getRuleIndex() const {
  return OLangParser::RuleDropExpression;
}

void OLangParser::DropExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropExpression(this);
}

void OLangParser::DropExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropExpression(this);
}


std::any OLangParser::DropExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitDropExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::DropExpressionContext* OLangParser::dropExpression() {
  DropExpressionContext *_localctx = _tracker.createInstance<DropExpressionContext>(_ctx, getState());
  enterRule(_localctx, 164, OLangParser::RuleDropExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(987);
    match(OLangParser::DROP);
    setState(988);
    match(OLangParser::LPAREN);
    setState(989);
    expression();
    setState(990);
    match(OLangParser::COMMA);
    setState(991);
    expression();
    setState(992);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TakeWhileExpressionContext ------------------------------------------------------------------

OLangParser::TakeWhileExpressionContext::TakeWhileExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::TakeWhileExpressionContext::TAKE_WHILE() {
  return getToken(OLangParser::TAKE_WHILE, 0);
}

tree::TerminalNode* OLangParser::TakeWhileExpressionContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

std::vector<OLangParser::ExpressionContext *> OLangParser::TakeWhileExpressionContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::TakeWhileExpressionContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}

tree::TerminalNode* OLangParser::TakeWhileExpressionContext::COMMA() {
  return getToken(OLangParser::COMMA, 0);
}

tree::TerminalNode* OLangParser::TakeWhileExpressionContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}

OLangParser::LambdaExpressionContext* OLangParser::TakeWhileExpressionContext::lambdaExpression() {
  return getRuleContext<OLangParser::LambdaExpressionContext>(0);
}


size_t OLangParser::TakeWhileExpressionContext::getRuleIndex() const {
  return OLangParser::RuleTakeWhileExpression;
}

void OLangParser::TakeWhileExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTakeWhileExpression(this);
}

void OLangParser::TakeWhileExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTakeWhileExpression(this);
}


std::any OLangParser::TakeWhileExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitTakeWhileExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::TakeWhileExpressionContext* OLangParser::takeWhileExpression() {
  TakeWhileExpressionContext *_localctx = _tracker.createInstance<TakeWhileExpressionContext>(_ctx, getState());
  enterRule(_localctx, 166, OLangParser::RuleTakeWhileExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(994);
    match(OLangParser::TAKE_WHILE);
    setState(995);
    match(OLangParser::LPAREN);
    setState(996);
    expression();
    setState(997);
    match(OLangParser::COMMA);
    setState(1000);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, _ctx)) {
    case 1: {
      setState(998);
      lambdaExpression();
      break;
    }

    case 2: {
      setState(999);
      expression();
      break;
    }

    default:
      break;
    }
    setState(1002);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropWhileExpressionContext ------------------------------------------------------------------

OLangParser::DropWhileExpressionContext::DropWhileExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::DropWhileExpressionContext::DROP_WHILE() {
  return getToken(OLangParser::DROP_WHILE, 0);
}

tree::TerminalNode* OLangParser::DropWhileExpressionContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

std::vector<OLangParser::ExpressionContext *> OLangParser::DropWhileExpressionContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::DropWhileExpressionContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}

tree::TerminalNode* OLangParser::DropWhileExpressionContext::COMMA() {
  return getToken(OLangParser::COMMA, 0);
}

tree::TerminalNode* OLangParser::DropWhileExpressionContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}

OLangParser::LambdaExpressionContext* OLangParser::DropWhileExpressionContext::lambdaExpression() {
  return getRuleContext<OLangParser::LambdaExpressionContext>(0);
}


size_t OLangParser::DropWhileExpressionContext::getRuleIndex() const {
  return OLangParser::RuleDropWhileExpression;
}

void OLangParser::DropWhileExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropWhileExpression(this);
}

void OLangParser::DropWhileExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropWhileExpression(this);
}


std::any OLangParser::DropWhileExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitDropWhileExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::DropWhileExpressionContext* OLangParser::dropWhileExpression() {
  DropWhileExpressionContext *_localctx = _tracker.createInstance<DropWhileExpressionContext>(_ctx, getState());
  enterRule(_localctx, 168, OLangParser::RuleDropWhileExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1004);
    match(OLangParser::DROP_WHILE);
    setState(1005);
    match(OLangParser::LPAREN);
    setState(1006);
    expression();
    setState(1007);
    match(OLangParser::COMMA);
    setState(1010);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx)) {
    case 1: {
      setState(1008);
      lambdaExpression();
      break;
    }

    case 2: {
      setState(1009);
      expression();
      break;
    }

    default:
      break;
    }
    setState(1012);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SortByExpressionContext ------------------------------------------------------------------

OLangParser::SortByExpressionContext::SortByExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::SortByExpressionContext::SORT_BY() {
  return getToken(OLangParser::SORT_BY, 0);
}

tree::TerminalNode* OLangParser::SortByExpressionContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

std::vector<OLangParser::ExpressionContext *> OLangParser::SortByExpressionContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::SortByExpressionContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}

tree::TerminalNode* OLangParser::SortByExpressionContext::COMMA() {
  return getToken(OLangParser::COMMA, 0);
}

tree::TerminalNode* OLangParser::SortByExpressionContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}

OLangParser::LambdaExpressionContext* OLangParser::SortByExpressionContext::lambdaExpression() {
  return getRuleContext<OLangParser::LambdaExpressionContext>(0);
}


size_t OLangParser::SortByExpressionContext::getRuleIndex() const {
  return OLangParser::RuleSortByExpression;
}

void OLangParser::SortByExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSortByExpression(this);
}

void OLangParser::SortByExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSortByExpression(this);
}


std::any OLangParser::SortByExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitSortByExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::SortByExpressionContext* OLangParser::sortByExpression() {
  SortByExpressionContext *_localctx = _tracker.createInstance<SortByExpressionContext>(_ctx, getState());
  enterRule(_localctx, 170, OLangParser::RuleSortByExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1014);
    match(OLangParser::SORT_BY);
    setState(1015);
    match(OLangParser::LPAREN);
    setState(1016);
    expression();
    setState(1017);
    match(OLangParser::COMMA);
    setState(1020);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx)) {
    case 1: {
      setState(1018);
      lambdaExpression();
      break;
    }

    case 2: {
      setState(1019);
      expression();
      break;
    }

    default:
      break;
    }
    setState(1022);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DistinctExpressionContext ------------------------------------------------------------------

OLangParser::DistinctExpressionContext::DistinctExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::DistinctExpressionContext::DISTINCT() {
  return getToken(OLangParser::DISTINCT, 0);
}

tree::TerminalNode* OLangParser::DistinctExpressionContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

std::vector<OLangParser::ExpressionContext *> OLangParser::DistinctExpressionContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::DistinctExpressionContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}

tree::TerminalNode* OLangParser::DistinctExpressionContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}

tree::TerminalNode* OLangParser::DistinctExpressionContext::COMMA() {
  return getToken(OLangParser::COMMA, 0);
}

OLangParser::LambdaExpressionContext* OLangParser::DistinctExpressionContext::lambdaExpression() {
  return getRuleContext<OLangParser::LambdaExpressionContext>(0);
}


size_t OLangParser::DistinctExpressionContext::getRuleIndex() const {
  return OLangParser::RuleDistinctExpression;
}

void OLangParser::DistinctExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDistinctExpression(this);
}

void OLangParser::DistinctExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDistinctExpression(this);
}


std::any OLangParser::DistinctExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitDistinctExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::DistinctExpressionContext* OLangParser::distinctExpression() {
  DistinctExpressionContext *_localctx = _tracker.createInstance<DistinctExpressionContext>(_ctx, getState());
  enterRule(_localctx, 172, OLangParser::RuleDistinctExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1024);
    match(OLangParser::DISTINCT);
    setState(1025);
    match(OLangParser::LPAREN);
    setState(1026);
    expression();
    setState(1032);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == OLangParser::COMMA) {
      setState(1027);
      match(OLangParser::COMMA);
      setState(1030);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx)) {
      case 1: {
        setState(1028);
        lambdaExpression();
        break;
      }

      case 2: {
        setState(1029);
        expression();
        break;
      }

      default:
        break;
      }
    }
    setState(1034);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CountExpressionContext ------------------------------------------------------------------

OLangParser::CountExpressionContext::CountExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::CountExpressionContext::COUNT() {
  return getToken(OLangParser::COUNT, 0);
}

tree::TerminalNode* OLangParser::CountExpressionContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

std::vector<OLangParser::ExpressionContext *> OLangParser::CountExpressionContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::CountExpressionContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}

tree::TerminalNode* OLangParser::CountExpressionContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}

tree::TerminalNode* OLangParser::CountExpressionContext::COMMA() {
  return getToken(OLangParser::COMMA, 0);
}

OLangParser::LambdaExpressionContext* OLangParser::CountExpressionContext::lambdaExpression() {
  return getRuleContext<OLangParser::LambdaExpressionContext>(0);
}


size_t OLangParser::CountExpressionContext::getRuleIndex() const {
  return OLangParser::RuleCountExpression;
}

void OLangParser::CountExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCountExpression(this);
}

void OLangParser::CountExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCountExpression(this);
}


std::any OLangParser::CountExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitCountExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::CountExpressionContext* OLangParser::countExpression() {
  CountExpressionContext *_localctx = _tracker.createInstance<CountExpressionContext>(_ctx, getState());
  enterRule(_localctx, 174, OLangParser::RuleCountExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1036);
    match(OLangParser::COUNT);
    setState(1037);
    match(OLangParser::LPAREN);
    setState(1038);
    expression();
    setState(1044);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == OLangParser::COMMA) {
      setState(1039);
      match(OLangParser::COMMA);
      setState(1042);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx)) {
      case 1: {
        setState(1040);
        lambdaExpression();
        break;
      }

      case 2: {
        setState(1041);
        expression();
        break;
      }

      default:
        break;
      }
    }
    setState(1046);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FindExpressionContext ------------------------------------------------------------------

OLangParser::FindExpressionContext::FindExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::FindExpressionContext::FIND() {
  return getToken(OLangParser::FIND, 0);
}

tree::TerminalNode* OLangParser::FindExpressionContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

std::vector<OLangParser::ExpressionContext *> OLangParser::FindExpressionContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::FindExpressionContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}

tree::TerminalNode* OLangParser::FindExpressionContext::COMMA() {
  return getToken(OLangParser::COMMA, 0);
}

tree::TerminalNode* OLangParser::FindExpressionContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}

OLangParser::LambdaExpressionContext* OLangParser::FindExpressionContext::lambdaExpression() {
  return getRuleContext<OLangParser::LambdaExpressionContext>(0);
}


size_t OLangParser::FindExpressionContext::getRuleIndex() const {
  return OLangParser::RuleFindExpression;
}

void OLangParser::FindExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFindExpression(this);
}

void OLangParser::FindExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFindExpression(this);
}


std::any OLangParser::FindExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitFindExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::FindExpressionContext* OLangParser::findExpression() {
  FindExpressionContext *_localctx = _tracker.createInstance<FindExpressionContext>(_ctx, getState());
  enterRule(_localctx, 176, OLangParser::RuleFindExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1048);
    match(OLangParser::FIND);
    setState(1049);
    match(OLangParser::LPAREN);
    setState(1050);
    expression();
    setState(1051);
    match(OLangParser::COMMA);
    setState(1054);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx)) {
    case 1: {
      setState(1052);
      lambdaExpression();
      break;
    }

    case 2: {
      setState(1053);
      expression();
      break;
    }

    default:
      break;
    }
    setState(1056);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnyExpressionContext ------------------------------------------------------------------

OLangParser::AnyExpressionContext::AnyExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::AnyExpressionContext::ANY() {
  return getToken(OLangParser::ANY, 0);
}

tree::TerminalNode* OLangParser::AnyExpressionContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

std::vector<OLangParser::ExpressionContext *> OLangParser::AnyExpressionContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::AnyExpressionContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}

tree::TerminalNode* OLangParser::AnyExpressionContext::COMMA() {
  return getToken(OLangParser::COMMA, 0);
}

tree::TerminalNode* OLangParser::AnyExpressionContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}

OLangParser::LambdaExpressionContext* OLangParser::AnyExpressionContext::lambdaExpression() {
  return getRuleContext<OLangParser::LambdaExpressionContext>(0);
}


size_t OLangParser::AnyExpressionContext::getRuleIndex() const {
  return OLangParser::RuleAnyExpression;
}

void OLangParser::AnyExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnyExpression(this);
}

void OLangParser::AnyExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnyExpression(this);
}


std::any OLangParser::AnyExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitAnyExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::AnyExpressionContext* OLangParser::anyExpression() {
  AnyExpressionContext *_localctx = _tracker.createInstance<AnyExpressionContext>(_ctx, getState());
  enterRule(_localctx, 178, OLangParser::RuleAnyExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1058);
    match(OLangParser::ANY);
    setState(1059);
    match(OLangParser::LPAREN);
    setState(1060);
    expression();
    setState(1061);
    match(OLangParser::COMMA);
    setState(1064);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx)) {
    case 1: {
      setState(1062);
      lambdaExpression();
      break;
    }

    case 2: {
      setState(1063);
      expression();
      break;
    }

    default:
      break;
    }
    setState(1066);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AllExpressionContext ------------------------------------------------------------------

OLangParser::AllExpressionContext::AllExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::AllExpressionContext::ALL() {
  return getToken(OLangParser::ALL, 0);
}

tree::TerminalNode* OLangParser::AllExpressionContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

std::vector<OLangParser::ExpressionContext *> OLangParser::AllExpressionContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::AllExpressionContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}

tree::TerminalNode* OLangParser::AllExpressionContext::COMMA() {
  return getToken(OLangParser::COMMA, 0);
}

tree::TerminalNode* OLangParser::AllExpressionContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}

OLangParser::LambdaExpressionContext* OLangParser::AllExpressionContext::lambdaExpression() {
  return getRuleContext<OLangParser::LambdaExpressionContext>(0);
}


size_t OLangParser::AllExpressionContext::getRuleIndex() const {
  return OLangParser::RuleAllExpression;
}

void OLangParser::AllExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAllExpression(this);
}

void OLangParser::AllExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAllExpression(this);
}


std::any OLangParser::AllExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitAllExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::AllExpressionContext* OLangParser::allExpression() {
  AllExpressionContext *_localctx = _tracker.createInstance<AllExpressionContext>(_ctx, getState());
  enterRule(_localctx, 180, OLangParser::RuleAllExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1068);
    match(OLangParser::ALL);
    setState(1069);
    match(OLangParser::LPAREN);
    setState(1070);
    expression();
    setState(1071);
    match(OLangParser::COMMA);
    setState(1074);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx)) {
    case 1: {
      setState(1072);
      lambdaExpression();
      break;
    }

    case 2: {
      setState(1073);
      expression();
      break;
    }

    default:
      break;
    }
    setState(1076);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JoinExpressionContext ------------------------------------------------------------------

OLangParser::JoinExpressionContext::JoinExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::JoinExpressionContext::JOIN() {
  return getToken(OLangParser::JOIN, 0);
}

tree::TerminalNode* OLangParser::JoinExpressionContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

std::vector<OLangParser::ExpressionContext *> OLangParser::JoinExpressionContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::JoinExpressionContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::JoinExpressionContext::COMMA() {
  return getTokens(OLangParser::COMMA);
}

tree::TerminalNode* OLangParser::JoinExpressionContext::COMMA(size_t i) {
  return getToken(OLangParser::COMMA, i);
}

OLangParser::JoinClauseContext* OLangParser::JoinExpressionContext::joinClause() {
  return getRuleContext<OLangParser::JoinClauseContext>(0);
}

tree::TerminalNode* OLangParser::JoinExpressionContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}


size_t OLangParser::JoinExpressionContext::getRuleIndex() const {
  return OLangParser::RuleJoinExpression;
}

void OLangParser::JoinExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoinExpression(this);
}

void OLangParser::JoinExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoinExpression(this);
}


std::any OLangParser::JoinExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitJoinExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::JoinExpressionContext* OLangParser::joinExpression() {
  JoinExpressionContext *_localctx = _tracker.createInstance<JoinExpressionContext>(_ctx, getState());
  enterRule(_localctx, 182, OLangParser::RuleJoinExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1078);
    match(OLangParser::JOIN);
    setState(1079);
    match(OLangParser::LPAREN);
    setState(1080);
    expression();
    setState(1081);
    match(OLangParser::COMMA);
    setState(1082);
    expression();
    setState(1083);
    match(OLangParser::COMMA);
    setState(1084);
    joinClause();
    setState(1087);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == OLangParser::COMMA) {
      setState(1085);
      match(OLangParser::COMMA);
      setState(1086);
      expression();
    }
    setState(1089);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JoinClauseContext ------------------------------------------------------------------

OLangParser::JoinClauseContext::JoinClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::JoinClauseContext::ON() {
  return getToken(OLangParser::ON, 0);
}

tree::TerminalNode* OLangParser::JoinClauseContext::EQUALS() {
  return getToken(OLangParser::EQUALS, 0);
}

OLangParser::LambdaExpressionContext* OLangParser::JoinClauseContext::lambdaExpression() {
  return getRuleContext<OLangParser::LambdaExpressionContext>(0);
}

OLangParser::ExpressionContext* OLangParser::JoinClauseContext::expression() {
  return getRuleContext<OLangParser::ExpressionContext>(0);
}


size_t OLangParser::JoinClauseContext::getRuleIndex() const {
  return OLangParser::RuleJoinClause;
}

void OLangParser::JoinClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoinClause(this);
}

void OLangParser::JoinClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoinClause(this);
}


std::any OLangParser::JoinClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitJoinClause(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::JoinClauseContext* OLangParser::joinClause() {
  JoinClauseContext *_localctx = _tracker.createInstance<JoinClauseContext>(_ctx, getState());
  enterRule(_localctx, 184, OLangParser::RuleJoinClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1091);
    match(OLangParser::ON);
    setState(1092);
    match(OLangParser::EQUALS);
    setState(1095);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx)) {
    case 1: {
      setState(1093);
      lambdaExpression();
      break;
    }

    case 2: {
      setState(1094);
      expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowExpressionContext ------------------------------------------------------------------

OLangParser::WindowExpressionContext::WindowExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::WindowExpressionContext::WINDOW() {
  return getToken(OLangParser::WINDOW, 0);
}

tree::TerminalNode* OLangParser::WindowExpressionContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

std::vector<OLangParser::ExpressionContext *> OLangParser::WindowExpressionContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::WindowExpressionContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::WindowExpressionContext::COMMA() {
  return getTokens(OLangParser::COMMA);
}

tree::TerminalNode* OLangParser::WindowExpressionContext::COMMA(size_t i) {
  return getToken(OLangParser::COMMA, i);
}

tree::TerminalNode* OLangParser::WindowExpressionContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}


size_t OLangParser::WindowExpressionContext::getRuleIndex() const {
  return OLangParser::RuleWindowExpression;
}

void OLangParser::WindowExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowExpression(this);
}

void OLangParser::WindowExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowExpression(this);
}


std::any OLangParser::WindowExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitWindowExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::WindowExpressionContext* OLangParser::windowExpression() {
  WindowExpressionContext *_localctx = _tracker.createInstance<WindowExpressionContext>(_ctx, getState());
  enterRule(_localctx, 186, OLangParser::RuleWindowExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1097);
    match(OLangParser::WINDOW);
    setState(1098);
    match(OLangParser::LPAREN);
    setState(1099);
    expression();
    setState(1100);
    match(OLangParser::COMMA);
    setState(1101);
    expression();
    setState(1104);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == OLangParser::COMMA) {
      setState(1102);
      match(OLangParser::COMMA);
      setState(1103);
      expression();
    }
    setState(1106);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChunkExpressionContext ------------------------------------------------------------------

OLangParser::ChunkExpressionContext::ChunkExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::ChunkExpressionContext::CHUNK() {
  return getToken(OLangParser::CHUNK, 0);
}

tree::TerminalNode* OLangParser::ChunkExpressionContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

std::vector<OLangParser::ExpressionContext *> OLangParser::ChunkExpressionContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::ChunkExpressionContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}

tree::TerminalNode* OLangParser::ChunkExpressionContext::COMMA() {
  return getToken(OLangParser::COMMA, 0);
}

tree::TerminalNode* OLangParser::ChunkExpressionContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}


size_t OLangParser::ChunkExpressionContext::getRuleIndex() const {
  return OLangParser::RuleChunkExpression;
}

void OLangParser::ChunkExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChunkExpression(this);
}

void OLangParser::ChunkExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChunkExpression(this);
}


std::any OLangParser::ChunkExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitChunkExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ChunkExpressionContext* OLangParser::chunkExpression() {
  ChunkExpressionContext *_localctx = _tracker.createInstance<ChunkExpressionContext>(_ctx, getState());
  enterRule(_localctx, 188, OLangParser::RuleChunkExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1108);
    match(OLangParser::CHUNK);
    setState(1109);
    match(OLangParser::LPAREN);
    setState(1110);
    expression();
    setState(1111);
    match(OLangParser::COMMA);
    setState(1112);
    expression();
    setState(1113);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ScanExpressionContext ------------------------------------------------------------------

OLangParser::ScanExpressionContext::ScanExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::ScanExpressionContext::SCAN() {
  return getToken(OLangParser::SCAN, 0);
}

tree::TerminalNode* OLangParser::ScanExpressionContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

std::vector<OLangParser::ExpressionContext *> OLangParser::ScanExpressionContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::ScanExpressionContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::ScanExpressionContext::COMMA() {
  return getTokens(OLangParser::COMMA);
}

tree::TerminalNode* OLangParser::ScanExpressionContext::COMMA(size_t i) {
  return getToken(OLangParser::COMMA, i);
}

tree::TerminalNode* OLangParser::ScanExpressionContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}

OLangParser::LambdaExpressionContext* OLangParser::ScanExpressionContext::lambdaExpression() {
  return getRuleContext<OLangParser::LambdaExpressionContext>(0);
}


size_t OLangParser::ScanExpressionContext::getRuleIndex() const {
  return OLangParser::RuleScanExpression;
}

void OLangParser::ScanExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScanExpression(this);
}

void OLangParser::ScanExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScanExpression(this);
}


std::any OLangParser::ScanExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitScanExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ScanExpressionContext* OLangParser::scanExpression() {
  ScanExpressionContext *_localctx = _tracker.createInstance<ScanExpressionContext>(_ctx, getState());
  enterRule(_localctx, 190, OLangParser::RuleScanExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1115);
    match(OLangParser::SCAN);
    setState(1116);
    match(OLangParser::LPAREN);
    setState(1117);
    expression();
    setState(1118);
    match(OLangParser::COMMA);
    setState(1121);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx)) {
    case 1: {
      setState(1119);
      lambdaExpression();
      break;
    }

    case 2: {
      setState(1120);
      expression();
      break;
    }

    default:
      break;
    }
    setState(1125);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == OLangParser::COMMA) {
      setState(1123);
      match(OLangParser::COMMA);
      setState(1124);
      expression();
    }
    setState(1127);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CollectExpressionContext ------------------------------------------------------------------

OLangParser::CollectExpressionContext::CollectExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::CollectExpressionContext::COLLECT() {
  return getToken(OLangParser::COLLECT, 0);
}

tree::TerminalNode* OLangParser::CollectExpressionContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

std::vector<OLangParser::ExpressionContext *> OLangParser::CollectExpressionContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::CollectExpressionContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::CollectExpressionContext::COMMA() {
  return getTokens(OLangParser::COMMA);
}

tree::TerminalNode* OLangParser::CollectExpressionContext::COMMA(size_t i) {
  return getToken(OLangParser::COMMA, i);
}

tree::TerminalNode* OLangParser::CollectExpressionContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}

OLangParser::LambdaExpressionContext* OLangParser::CollectExpressionContext::lambdaExpression() {
  return getRuleContext<OLangParser::LambdaExpressionContext>(0);
}


size_t OLangParser::CollectExpressionContext::getRuleIndex() const {
  return OLangParser::RuleCollectExpression;
}

void OLangParser::CollectExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCollectExpression(this);
}

void OLangParser::CollectExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCollectExpression(this);
}


std::any OLangParser::CollectExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitCollectExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::CollectExpressionContext* OLangParser::collectExpression() {
  CollectExpressionContext *_localctx = _tracker.createInstance<CollectExpressionContext>(_ctx, getState());
  enterRule(_localctx, 192, OLangParser::RuleCollectExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1129);
    match(OLangParser::COLLECT);
    setState(1130);
    match(OLangParser::LPAREN);
    setState(1131);
    expression();
    setState(1132);
    match(OLangParser::COMMA);
    setState(1135);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx)) {
    case 1: {
      setState(1133);
      lambdaExpression();
      break;
    }

    case 2: {
      setState(1134);
      expression();
      break;
    }

    default:
      break;
    }
    setState(1137);
    match(OLangParser::COMMA);
    setState(1138);
    expression();
    setState(1139);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LambdaExpressionContext ------------------------------------------------------------------

OLangParser::LambdaExpressionContext::LambdaExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::MultipleParameterLambdaContext* OLangParser::LambdaExpressionContext::multipleParameterLambda() {
  return getRuleContext<OLangParser::MultipleParameterLambdaContext>(0);
}

OLangParser::SimplePatternLambdaContext* OLangParser::LambdaExpressionContext::simplePatternLambda() {
  return getRuleContext<OLangParser::SimplePatternLambdaContext>(0);
}

OLangParser::SimpleLambdaContext* OLangParser::LambdaExpressionContext::simpleLambda() {
  return getRuleContext<OLangParser::SimpleLambdaContext>(0);
}


size_t OLangParser::LambdaExpressionContext::getRuleIndex() const {
  return OLangParser::RuleLambdaExpression;
}

void OLangParser::LambdaExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLambdaExpression(this);
}

void OLangParser::LambdaExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLambdaExpression(this);
}


std::any OLangParser::LambdaExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitLambdaExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::LambdaExpressionContext* OLangParser::lambdaExpression() {
  LambdaExpressionContext *_localctx = _tracker.createInstance<LambdaExpressionContext>(_ctx, getState());
  enterRule(_localctx, 194, OLangParser::RuleLambdaExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1144);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case OLangParser::LPAREN: {
        enterOuterAlt(_localctx, 1);
        setState(1141);
        multipleParameterLambda();
        break;
      }

      case OLangParser::LBRACK:
      case OLangParser::LCURLY: {
        enterOuterAlt(_localctx, 2);
        setState(1142);
        simplePatternLambda();
        break;
      }

      case OLangParser::ID: {
        enterOuterAlt(_localctx, 3);
        setState(1143);
        simpleLambda();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultipleParameterLambdaContext ------------------------------------------------------------------

OLangParser::MultipleParameterLambdaContext::MultipleParameterLambdaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::MultipleParameterLambdaContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

OLangParser::ParameterListContext* OLangParser::MultipleParameterLambdaContext::parameterList() {
  return getRuleContext<OLangParser::ParameterListContext>(0);
}

tree::TerminalNode* OLangParser::MultipleParameterLambdaContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}

tree::TerminalNode* OLangParser::MultipleParameterLambdaContext::LAMBDA_ARROW() {
  return getToken(OLangParser::LAMBDA_ARROW, 0);
}

OLangParser::ExpressionContext* OLangParser::MultipleParameterLambdaContext::expression() {
  return getRuleContext<OLangParser::ExpressionContext>(0);
}

OLangParser::BlockExpressionContext* OLangParser::MultipleParameterLambdaContext::blockExpression() {
  return getRuleContext<OLangParser::BlockExpressionContext>(0);
}


size_t OLangParser::MultipleParameterLambdaContext::getRuleIndex() const {
  return OLangParser::RuleMultipleParameterLambda;
}

void OLangParser::MultipleParameterLambdaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultipleParameterLambda(this);
}

void OLangParser::MultipleParameterLambdaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultipleParameterLambda(this);
}


std::any OLangParser::MultipleParameterLambdaContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitMultipleParameterLambda(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::MultipleParameterLambdaContext* OLangParser::multipleParameterLambda() {
  MultipleParameterLambdaContext *_localctx = _tracker.createInstance<MultipleParameterLambdaContext>(_ctx, getState());
  enterRule(_localctx, 196, OLangParser::RuleMultipleParameterLambda);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1146);
    match(OLangParser::LPAREN);
    setState(1147);
    parameterList();
    setState(1148);
    match(OLangParser::RPAREN);
    setState(1149);
    match(OLangParser::LAMBDA_ARROW);
    setState(1152);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx)) {
    case 1: {
      setState(1150);
      expression();
      break;
    }

    case 2: {
      setState(1151);
      blockExpression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterListContext ------------------------------------------------------------------

OLangParser::ParameterListContext::ParameterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::ParameterContext *> OLangParser::ParameterListContext::parameter() {
  return getRuleContexts<OLangParser::ParameterContext>();
}

OLangParser::ParameterContext* OLangParser::ParameterListContext::parameter(size_t i) {
  return getRuleContext<OLangParser::ParameterContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::ParameterListContext::COMMA() {
  return getTokens(OLangParser::COMMA);
}

tree::TerminalNode* OLangParser::ParameterListContext::COMMA(size_t i) {
  return getToken(OLangParser::COMMA, i);
}


size_t OLangParser::ParameterListContext::getRuleIndex() const {
  return OLangParser::RuleParameterList;
}

void OLangParser::ParameterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameterList(this);
}

void OLangParser::ParameterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameterList(this);
}


std::any OLangParser::ParameterListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitParameterList(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ParameterListContext* OLangParser::parameterList() {
  ParameterListContext *_localctx = _tracker.createInstance<ParameterListContext>(_ctx, getState());
  enterRule(_localctx, 198, OLangParser::RuleParameterList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1154);
    parameter();
    setState(1159);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == OLangParser::COMMA) {
      setState(1155);
      match(OLangParser::COMMA);
      setState(1156);
      parameter();
      setState(1161);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterContext ------------------------------------------------------------------

OLangParser::ParameterContext::ParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::ParameterContext::ID() {
  return getToken(OLangParser::ID, 0);
}

tree::TerminalNode* OLangParser::ParameterContext::COLON() {
  return getToken(OLangParser::COLON, 0);
}

OLangParser::TypeContext* OLangParser::ParameterContext::type() {
  return getRuleContext<OLangParser::TypeContext>(0);
}


size_t OLangParser::ParameterContext::getRuleIndex() const {
  return OLangParser::RuleParameter;
}

void OLangParser::ParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter(this);
}

void OLangParser::ParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter(this);
}


std::any OLangParser::ParameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitParameter(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ParameterContext* OLangParser::parameter() {
  ParameterContext *_localctx = _tracker.createInstance<ParameterContext>(_ctx, getState());
  enterRule(_localctx, 200, OLangParser::RuleParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1162);
    match(OLangParser::ID);
    setState(1165);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == OLangParser::COLON) {
      setState(1163);
      match(OLangParser::COLON);
      setState(1164);
      type();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimplePatternLambdaContext ------------------------------------------------------------------

OLangParser::SimplePatternLambdaContext::SimplePatternLambdaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::SimpleDestructureContext* OLangParser::SimplePatternLambdaContext::simpleDestructure() {
  return getRuleContext<OLangParser::SimpleDestructureContext>(0);
}

tree::TerminalNode* OLangParser::SimplePatternLambdaContext::LAMBDA_ARROW() {
  return getToken(OLangParser::LAMBDA_ARROW, 0);
}

OLangParser::ExpressionContext* OLangParser::SimplePatternLambdaContext::expression() {
  return getRuleContext<OLangParser::ExpressionContext>(0);
}

OLangParser::BlockExpressionContext* OLangParser::SimplePatternLambdaContext::blockExpression() {
  return getRuleContext<OLangParser::BlockExpressionContext>(0);
}


size_t OLangParser::SimplePatternLambdaContext::getRuleIndex() const {
  return OLangParser::RuleSimplePatternLambda;
}

void OLangParser::SimplePatternLambdaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimplePatternLambda(this);
}

void OLangParser::SimplePatternLambdaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimplePatternLambda(this);
}


std::any OLangParser::SimplePatternLambdaContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitSimplePatternLambda(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::SimplePatternLambdaContext* OLangParser::simplePatternLambda() {
  SimplePatternLambdaContext *_localctx = _tracker.createInstance<SimplePatternLambdaContext>(_ctx, getState());
  enterRule(_localctx, 202, OLangParser::RuleSimplePatternLambda);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1167);
    simpleDestructure();
    setState(1168);
    match(OLangParser::LAMBDA_ARROW);
    setState(1171);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 84, _ctx)) {
    case 1: {
      setState(1169);
      expression();
      break;
    }

    case 2: {
      setState(1170);
      blockExpression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleDestructureContext ------------------------------------------------------------------

OLangParser::SimpleDestructureContext::SimpleDestructureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::SimpleDestructureContext::LCURLY() {
  return getToken(OLangParser::LCURLY, 0);
}

OLangParser::SimplePatternFieldListContext* OLangParser::SimpleDestructureContext::simplePatternFieldList() {
  return getRuleContext<OLangParser::SimplePatternFieldListContext>(0);
}

tree::TerminalNode* OLangParser::SimpleDestructureContext::RCURLY() {
  return getToken(OLangParser::RCURLY, 0);
}

tree::TerminalNode* OLangParser::SimpleDestructureContext::LBRACK() {
  return getToken(OLangParser::LBRACK, 0);
}

OLangParser::SimplePatternListContext* OLangParser::SimpleDestructureContext::simplePatternList() {
  return getRuleContext<OLangParser::SimplePatternListContext>(0);
}

tree::TerminalNode* OLangParser::SimpleDestructureContext::RBRACK() {
  return getToken(OLangParser::RBRACK, 0);
}


size_t OLangParser::SimpleDestructureContext::getRuleIndex() const {
  return OLangParser::RuleSimpleDestructure;
}

void OLangParser::SimpleDestructureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleDestructure(this);
}

void OLangParser::SimpleDestructureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleDestructure(this);
}


std::any OLangParser::SimpleDestructureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitSimpleDestructure(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::SimpleDestructureContext* OLangParser::simpleDestructure() {
  SimpleDestructureContext *_localctx = _tracker.createInstance<SimpleDestructureContext>(_ctx, getState());
  enterRule(_localctx, 204, OLangParser::RuleSimpleDestructure);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1181);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case OLangParser::LCURLY: {
        enterOuterAlt(_localctx, 1);
        setState(1173);
        match(OLangParser::LCURLY);
        setState(1174);
        simplePatternFieldList();
        setState(1175);
        match(OLangParser::RCURLY);
        break;
      }

      case OLangParser::LBRACK: {
        enterOuterAlt(_localctx, 2);
        setState(1177);
        match(OLangParser::LBRACK);
        setState(1178);
        simplePatternList();
        setState(1179);
        match(OLangParser::RBRACK);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleLambdaContext ------------------------------------------------------------------

OLangParser::SimpleLambdaContext::SimpleLambdaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::SimpleLambdaContext::ID() {
  return getToken(OLangParser::ID, 0);
}

tree::TerminalNode* OLangParser::SimpleLambdaContext::LAMBDA_ARROW() {
  return getToken(OLangParser::LAMBDA_ARROW, 0);
}

OLangParser::ExpressionContext* OLangParser::SimpleLambdaContext::expression() {
  return getRuleContext<OLangParser::ExpressionContext>(0);
}

OLangParser::BlockExpressionContext* OLangParser::SimpleLambdaContext::blockExpression() {
  return getRuleContext<OLangParser::BlockExpressionContext>(0);
}


size_t OLangParser::SimpleLambdaContext::getRuleIndex() const {
  return OLangParser::RuleSimpleLambda;
}

void OLangParser::SimpleLambdaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleLambda(this);
}

void OLangParser::SimpleLambdaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleLambda(this);
}


std::any OLangParser::SimpleLambdaContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitSimpleLambda(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::SimpleLambdaContext* OLangParser::simpleLambda() {
  SimpleLambdaContext *_localctx = _tracker.createInstance<SimpleLambdaContext>(_ctx, getState());
  enterRule(_localctx, 206, OLangParser::RuleSimpleLambda);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1183);
    match(OLangParser::ID);
    setState(1184);
    match(OLangParser::LAMBDA_ARROW);
    setState(1187);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx)) {
    case 1: {
      setState(1185);
      expression();
      break;
    }

    case 2: {
      setState(1186);
      blockExpression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimplePatternListContext ------------------------------------------------------------------

OLangParser::SimplePatternListContext::SimplePatternListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::SimplePatternElementContext *> OLangParser::SimplePatternListContext::simplePatternElement() {
  return getRuleContexts<OLangParser::SimplePatternElementContext>();
}

OLangParser::SimplePatternElementContext* OLangParser::SimplePatternListContext::simplePatternElement(size_t i) {
  return getRuleContext<OLangParser::SimplePatternElementContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::SimplePatternListContext::COMMA() {
  return getTokens(OLangParser::COMMA);
}

tree::TerminalNode* OLangParser::SimplePatternListContext::COMMA(size_t i) {
  return getToken(OLangParser::COMMA, i);
}


size_t OLangParser::SimplePatternListContext::getRuleIndex() const {
  return OLangParser::RuleSimplePatternList;
}

void OLangParser::SimplePatternListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimplePatternList(this);
}

void OLangParser::SimplePatternListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimplePatternList(this);
}


std::any OLangParser::SimplePatternListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitSimplePatternList(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::SimplePatternListContext* OLangParser::simplePatternList() {
  SimplePatternListContext *_localctx = _tracker.createInstance<SimplePatternListContext>(_ctx, getState());
  enterRule(_localctx, 208, OLangParser::RuleSimplePatternList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1189);
    simplePatternElement();
    setState(1194);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == OLangParser::COMMA) {
      setState(1190);
      match(OLangParser::COMMA);
      setState(1191);
      simplePatternElement();
      setState(1196);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimplePatternFieldListContext ------------------------------------------------------------------

OLangParser::SimplePatternFieldListContext::SimplePatternFieldListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::SimplePatternFieldContext *> OLangParser::SimplePatternFieldListContext::simplePatternField() {
  return getRuleContexts<OLangParser::SimplePatternFieldContext>();
}

OLangParser::SimplePatternFieldContext* OLangParser::SimplePatternFieldListContext::simplePatternField(size_t i) {
  return getRuleContext<OLangParser::SimplePatternFieldContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::SimplePatternFieldListContext::COMMA() {
  return getTokens(OLangParser::COMMA);
}

tree::TerminalNode* OLangParser::SimplePatternFieldListContext::COMMA(size_t i) {
  return getToken(OLangParser::COMMA, i);
}


size_t OLangParser::SimplePatternFieldListContext::getRuleIndex() const {
  return OLangParser::RuleSimplePatternFieldList;
}

void OLangParser::SimplePatternFieldListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimplePatternFieldList(this);
}

void OLangParser::SimplePatternFieldListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimplePatternFieldList(this);
}


std::any OLangParser::SimplePatternFieldListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitSimplePatternFieldList(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::SimplePatternFieldListContext* OLangParser::simplePatternFieldList() {
  SimplePatternFieldListContext *_localctx = _tracker.createInstance<SimplePatternFieldListContext>(_ctx, getState());
  enterRule(_localctx, 210, OLangParser::RuleSimplePatternFieldList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1197);
    simplePatternField();
    setState(1202);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == OLangParser::COMMA) {
      setState(1198);
      match(OLangParser::COMMA);
      setState(1199);
      simplePatternField();
      setState(1204);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimplePatternElementContext ------------------------------------------------------------------

OLangParser::SimplePatternElementContext::SimplePatternElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::SimplePatternElementContext::ID() {
  return getToken(OLangParser::ID, 0);
}

tree::TerminalNode* OLangParser::SimplePatternElementContext::WILDCARD() {
  return getToken(OLangParser::WILDCARD, 0);
}


size_t OLangParser::SimplePatternElementContext::getRuleIndex() const {
  return OLangParser::RuleSimplePatternElement;
}

void OLangParser::SimplePatternElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimplePatternElement(this);
}

void OLangParser::SimplePatternElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimplePatternElement(this);
}


std::any OLangParser::SimplePatternElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitSimplePatternElement(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::SimplePatternElementContext* OLangParser::simplePatternElement() {
  SimplePatternElementContext *_localctx = _tracker.createInstance<SimplePatternElementContext>(_ctx, getState());
  enterRule(_localctx, 212, OLangParser::RuleSimplePatternElement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1205);
    _la = _input->LA(1);
    if (!(_la == OLangParser::WILDCARD

    || _la == OLangParser::ID)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimplePatternFieldContext ------------------------------------------------------------------

OLangParser::SimplePatternFieldContext::SimplePatternFieldContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> OLangParser::SimplePatternFieldContext::ID() {
  return getTokens(OLangParser::ID);
}

tree::TerminalNode* OLangParser::SimplePatternFieldContext::ID(size_t i) {
  return getToken(OLangParser::ID, i);
}

tree::TerminalNode* OLangParser::SimplePatternFieldContext::COLON() {
  return getToken(OLangParser::COLON, 0);
}

tree::TerminalNode* OLangParser::SimplePatternFieldContext::WILDCARD() {
  return getToken(OLangParser::WILDCARD, 0);
}


size_t OLangParser::SimplePatternFieldContext::getRuleIndex() const {
  return OLangParser::RuleSimplePatternField;
}

void OLangParser::SimplePatternFieldContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimplePatternField(this);
}

void OLangParser::SimplePatternFieldContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimplePatternField(this);
}


std::any OLangParser::SimplePatternFieldContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitSimplePatternField(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::SimplePatternFieldContext* OLangParser::simplePatternField() {
  SimplePatternFieldContext *_localctx = _tracker.createInstance<SimplePatternFieldContext>(_ctx, getState());
  enterRule(_localctx, 214, OLangParser::RuleSimplePatternField);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1212);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1207);
      match(OLangParser::ID);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1208);
      match(OLangParser::ID);
      setState(1209);
      match(OLangParser::COLON);
      setState(1210);
      match(OLangParser::ID);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1211);
      match(OLangParser::WILDCARD);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockExpressionContext ------------------------------------------------------------------

OLangParser::BlockExpressionContext::BlockExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::BlockExpressionContext::LCURLY() {
  return getToken(OLangParser::LCURLY, 0);
}

OLangParser::TransformationListContext* OLangParser::BlockExpressionContext::transformationList() {
  return getRuleContext<OLangParser::TransformationListContext>(0);
}

tree::TerminalNode* OLangParser::BlockExpressionContext::RCURLY() {
  return getToken(OLangParser::RCURLY, 0);
}


size_t OLangParser::BlockExpressionContext::getRuleIndex() const {
  return OLangParser::RuleBlockExpression;
}

void OLangParser::BlockExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlockExpression(this);
}

void OLangParser::BlockExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlockExpression(this);
}


std::any OLangParser::BlockExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitBlockExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::BlockExpressionContext* OLangParser::blockExpression() {
  BlockExpressionContext *_localctx = _tracker.createInstance<BlockExpressionContext>(_ctx, getState());
  enterRule(_localctx, 216, OLangParser::RuleBlockExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1214);
    match(OLangParser::LCURLY);
    setState(1215);
    transformationList();
    setState(1216);
    match(OLangParser::RCURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TransformationListContext ------------------------------------------------------------------

OLangParser::TransformationListContext::TransformationListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::TransformationContext *> OLangParser::TransformationListContext::transformation() {
  return getRuleContexts<OLangParser::TransformationContext>();
}

OLangParser::TransformationContext* OLangParser::TransformationListContext::transformation(size_t i) {
  return getRuleContext<OLangParser::TransformationContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::TransformationListContext::SEMI() {
  return getTokens(OLangParser::SEMI);
}

tree::TerminalNode* OLangParser::TransformationListContext::SEMI(size_t i) {
  return getToken(OLangParser::SEMI, i);
}


size_t OLangParser::TransformationListContext::getRuleIndex() const {
  return OLangParser::RuleTransformationList;
}

void OLangParser::TransformationListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransformationList(this);
}

void OLangParser::TransformationListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransformationList(this);
}


std::any OLangParser::TransformationListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitTransformationList(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::TransformationListContext* OLangParser::transformationList() {
  TransformationListContext *_localctx = _tracker.createInstance<TransformationListContext>(_ctx, getState());
  enterRule(_localctx, 218, OLangParser::RuleTransformationList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1218);
    transformation();
    setState(1223);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 90, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1219);
        match(OLangParser::SEMI);
        setState(1220);
        transformation(); 
      }
      setState(1225);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 90, _ctx);
    }
    setState(1227);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == OLangParser::SEMI) {
      setState(1226);
      match(OLangParser::SEMI);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TransformationContext ------------------------------------------------------------------

OLangParser::TransformationContext::TransformationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::TransformationContext::LET() {
  return getToken(OLangParser::LET, 0);
}

tree::TerminalNode* OLangParser::TransformationContext::ID() {
  return getToken(OLangParser::ID, 0);
}

tree::TerminalNode* OLangParser::TransformationContext::EQUALS() {
  return getToken(OLangParser::EQUALS, 0);
}

OLangParser::ExpressionContext* OLangParser::TransformationContext::expression() {
  return getRuleContext<OLangParser::ExpressionContext>(0);
}

tree::TerminalNode* OLangParser::TransformationContext::COLON() {
  return getToken(OLangParser::COLON, 0);
}

OLangParser::TypeContext* OLangParser::TransformationContext::type() {
  return getRuleContext<OLangParser::TypeContext>(0);
}


size_t OLangParser::TransformationContext::getRuleIndex() const {
  return OLangParser::RuleTransformation;
}

void OLangParser::TransformationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransformation(this);
}

void OLangParser::TransformationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransformation(this);
}


std::any OLangParser::TransformationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitTransformation(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::TransformationContext* OLangParser::transformation() {
  TransformationContext *_localctx = _tracker.createInstance<TransformationContext>(_ctx, getState());
  enterRule(_localctx, 220, OLangParser::RuleTransformation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1238);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case OLangParser::LET: {
        enterOuterAlt(_localctx, 1);
        setState(1229);
        match(OLangParser::LET);
        setState(1230);
        match(OLangParser::ID);
        setState(1233);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == OLangParser::COLON) {
          setState(1231);
          match(OLangParser::COLON);
          setState(1232);
          type();
        }
        setState(1235);
        match(OLangParser::EQUALS);
        setState(1236);
        expression();
        break;
      }

      case OLangParser::MATCH:
      case OLangParser::ALWAYS:
      case OLangParser::EVENTUALLY:
      case OLangParser::MAP:
      case OLangParser::FILTER:
      case OLangParser::REDUCE:
      case OLangParser::FOREACH:
      case OLangParser::GROUP_BY:
      case OLangParser::FLATMAP:
      case OLangParser::ZIP:
      case OLangParser::PARTITION:
      case OLangParser::TAKE:
      case OLangParser::DROP:
      case OLangParser::TAKE_WHILE:
      case OLangParser::DROP_WHILE:
      case OLangParser::SORT_BY:
      case OLangParser::DISTINCT:
      case OLangParser::COUNT:
      case OLangParser::FIND:
      case OLangParser::ANY:
      case OLangParser::ALL:
      case OLangParser::JOIN:
      case OLangParser::WINDOW:
      case OLangParser::CHUNK:
      case OLangParser::SCAN:
      case OLangParser::COLLECT:
      case OLangParser::NULL_LIT:
      case OLangParser::ADD:
      case OLangParser::SUB:
      case OLangParser::NOT:
      case OLangParser::BOOLEAN:
      case OLangParser::INT_LITERAL:
      case OLangParser::DECIMAL_LITERAL:
      case OLangParser::STRING:
      case OLangParser::RAW_STRING:
      case OLangParser::MULTILINE_STRING:
      case OLangParser::LPAREN:
      case OLangParser::LBRACK:
      case OLangParser::LCURLY:
      case OLangParser::ID: {
        enterOuterAlt(_localctx, 2);
        setState(1237);
        expression();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MatchExpressionContext ------------------------------------------------------------------

OLangParser::MatchExpressionContext::MatchExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::MatchExpressionContext::MATCH() {
  return getToken(OLangParser::MATCH, 0);
}

OLangParser::ExpressionContext* OLangParser::MatchExpressionContext::expression() {
  return getRuleContext<OLangParser::ExpressionContext>(0);
}

tree::TerminalNode* OLangParser::MatchExpressionContext::LCURLY() {
  return getToken(OLangParser::LCURLY, 0);
}

OLangParser::MatchArmListContext* OLangParser::MatchExpressionContext::matchArmList() {
  return getRuleContext<OLangParser::MatchArmListContext>(0);
}

tree::TerminalNode* OLangParser::MatchExpressionContext::RCURLY() {
  return getToken(OLangParser::RCURLY, 0);
}


size_t OLangParser::MatchExpressionContext::getRuleIndex() const {
  return OLangParser::RuleMatchExpression;
}

void OLangParser::MatchExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMatchExpression(this);
}

void OLangParser::MatchExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMatchExpression(this);
}


std::any OLangParser::MatchExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitMatchExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::MatchExpressionContext* OLangParser::matchExpression() {
  MatchExpressionContext *_localctx = _tracker.createInstance<MatchExpressionContext>(_ctx, getState());
  enterRule(_localctx, 222, OLangParser::RuleMatchExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1240);
    match(OLangParser::MATCH);
    setState(1241);
    expression();
    setState(1242);
    match(OLangParser::LCURLY);
    setState(1243);
    matchArmList();
    setState(1244);
    match(OLangParser::RCURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MatchArmContext ------------------------------------------------------------------

OLangParser::MatchArmContext::MatchArmContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::PatternContext* OLangParser::MatchArmContext::pattern() {
  return getRuleContext<OLangParser::PatternContext>(0);
}

tree::TerminalNode* OLangParser::MatchArmContext::ARROW() {
  return getToken(OLangParser::ARROW, 0);
}

OLangParser::ExpressionContext* OLangParser::MatchArmContext::expression() {
  return getRuleContext<OLangParser::ExpressionContext>(0);
}

OLangParser::BlockExpressionContext* OLangParser::MatchArmContext::blockExpression() {
  return getRuleContext<OLangParser::BlockExpressionContext>(0);
}


size_t OLangParser::MatchArmContext::getRuleIndex() const {
  return OLangParser::RuleMatchArm;
}

void OLangParser::MatchArmContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMatchArm(this);
}

void OLangParser::MatchArmContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMatchArm(this);
}


std::any OLangParser::MatchArmContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitMatchArm(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::MatchArmContext* OLangParser::matchArm() {
  MatchArmContext *_localctx = _tracker.createInstance<MatchArmContext>(_ctx, getState());
  enterRule(_localctx, 224, OLangParser::RuleMatchArm);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1246);
    pattern();
    setState(1247);
    match(OLangParser::ARROW);
    setState(1250);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 94, _ctx)) {
    case 1: {
      setState(1248);
      expression();
      break;
    }

    case 2: {
      setState(1249);
      blockExpression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MatchArmListContext ------------------------------------------------------------------

OLangParser::MatchArmListContext::MatchArmListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::MatchArmContext *> OLangParser::MatchArmListContext::matchArm() {
  return getRuleContexts<OLangParser::MatchArmContext>();
}

OLangParser::MatchArmContext* OLangParser::MatchArmListContext::matchArm(size_t i) {
  return getRuleContext<OLangParser::MatchArmContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::MatchArmListContext::COMMA() {
  return getTokens(OLangParser::COMMA);
}

tree::TerminalNode* OLangParser::MatchArmListContext::COMMA(size_t i) {
  return getToken(OLangParser::COMMA, i);
}


size_t OLangParser::MatchArmListContext::getRuleIndex() const {
  return OLangParser::RuleMatchArmList;
}

void OLangParser::MatchArmListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMatchArmList(this);
}

void OLangParser::MatchArmListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMatchArmList(this);
}


std::any OLangParser::MatchArmListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitMatchArmList(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::MatchArmListContext* OLangParser::matchArmList() {
  MatchArmListContext *_localctx = _tracker.createInstance<MatchArmListContext>(_ctx, getState());
  enterRule(_localctx, 226, OLangParser::RuleMatchArmList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1252);
    matchArm();
    setState(1257);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 95, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1253);
        match(OLangParser::COMMA);
        setState(1254);
        matchArm(); 
      }
      setState(1259);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 95, _ctx);
    }
    setState(1261);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == OLangParser::COMMA) {
      setState(1260);
      match(OLangParser::COMMA);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PatternContext ------------------------------------------------------------------

OLangParser::PatternContext::PatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::OrPatternContext* OLangParser::PatternContext::orPattern() {
  return getRuleContext<OLangParser::OrPatternContext>(0);
}


size_t OLangParser::PatternContext::getRuleIndex() const {
  return OLangParser::RulePattern;
}

void OLangParser::PatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPattern(this);
}

void OLangParser::PatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPattern(this);
}


std::any OLangParser::PatternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitPattern(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::PatternContext* OLangParser::pattern() {
  PatternContext *_localctx = _tracker.createInstance<PatternContext>(_ctx, getState());
  enterRule(_localctx, 228, OLangParser::RulePattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1263);
    orPattern();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OrPatternContext ------------------------------------------------------------------

OLangParser::OrPatternContext::OrPatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::AndPatternContext *> OLangParser::OrPatternContext::andPattern() {
  return getRuleContexts<OLangParser::AndPatternContext>();
}

OLangParser::AndPatternContext* OLangParser::OrPatternContext::andPattern(size_t i) {
  return getRuleContext<OLangParser::AndPatternContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::OrPatternContext::UNION_PIPE() {
  return getTokens(OLangParser::UNION_PIPE);
}

tree::TerminalNode* OLangParser::OrPatternContext::UNION_PIPE(size_t i) {
  return getToken(OLangParser::UNION_PIPE, i);
}


size_t OLangParser::OrPatternContext::getRuleIndex() const {
  return OLangParser::RuleOrPattern;
}

void OLangParser::OrPatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrPattern(this);
}

void OLangParser::OrPatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrPattern(this);
}


std::any OLangParser::OrPatternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitOrPattern(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::OrPatternContext* OLangParser::orPattern() {
  OrPatternContext *_localctx = _tracker.createInstance<OrPatternContext>(_ctx, getState());
  enterRule(_localctx, 230, OLangParser::RuleOrPattern);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1265);
    andPattern();
    setState(1270);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == OLangParser::UNION_PIPE) {
      setState(1266);
      match(OLangParser::UNION_PIPE);
      setState(1267);
      andPattern();
      setState(1272);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AndPatternContext ------------------------------------------------------------------

OLangParser::AndPatternContext::AndPatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::PrimaryPatternContext* OLangParser::AndPatternContext::primaryPattern() {
  return getRuleContext<OLangParser::PrimaryPatternContext>(0);
}


size_t OLangParser::AndPatternContext::getRuleIndex() const {
  return OLangParser::RuleAndPattern;
}

void OLangParser::AndPatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAndPattern(this);
}

void OLangParser::AndPatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAndPattern(this);
}


std::any OLangParser::AndPatternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitAndPattern(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::AndPatternContext* OLangParser::andPattern() {
  AndPatternContext *_localctx = _tracker.createInstance<AndPatternContext>(_ctx, getState());
  enterRule(_localctx, 232, OLangParser::RuleAndPattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1273);
    primaryPattern();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrimaryPatternContext ------------------------------------------------------------------

OLangParser::PrimaryPatternContext::PrimaryPatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::WildcardPatternContext* OLangParser::PrimaryPatternContext::wildcardPattern() {
  return getRuleContext<OLangParser::WildcardPatternContext>(0);
}

OLangParser::LiteralPatternContext* OLangParser::PrimaryPatternContext::literalPattern() {
  return getRuleContext<OLangParser::LiteralPatternContext>(0);
}

OLangParser::IdentifierPatternContext* OLangParser::PrimaryPatternContext::identifierPattern() {
  return getRuleContext<OLangParser::IdentifierPatternContext>(0);
}

OLangParser::DestructurePatternContext* OLangParser::PrimaryPatternContext::destructurePattern() {
  return getRuleContext<OLangParser::DestructurePatternContext>(0);
}

OLangParser::RangePatternContext* OLangParser::PrimaryPatternContext::rangePattern() {
  return getRuleContext<OLangParser::RangePatternContext>(0);
}

OLangParser::TypePatternContext* OLangParser::PrimaryPatternContext::typePattern() {
  return getRuleContext<OLangParser::TypePatternContext>(0);
}

OLangParser::GuardPatternContext* OLangParser::PrimaryPatternContext::guardPattern() {
  return getRuleContext<OLangParser::GuardPatternContext>(0);
}

OLangParser::ParenthesisPatternContext* OLangParser::PrimaryPatternContext::parenthesisPattern() {
  return getRuleContext<OLangParser::ParenthesisPatternContext>(0);
}


size_t OLangParser::PrimaryPatternContext::getRuleIndex() const {
  return OLangParser::RulePrimaryPattern;
}

void OLangParser::PrimaryPatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryPattern(this);
}

void OLangParser::PrimaryPatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryPattern(this);
}


std::any OLangParser::PrimaryPatternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitPrimaryPattern(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::PrimaryPatternContext* OLangParser::primaryPattern() {
  PrimaryPatternContext *_localctx = _tracker.createInstance<PrimaryPatternContext>(_ctx, getState());
  enterRule(_localctx, 234, OLangParser::RulePrimaryPattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1283);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1275);
      wildcardPattern();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1276);
      literalPattern();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1277);
      identifierPattern();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1278);
      destructurePattern();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1279);
      rangePattern();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1280);
      typePattern();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1281);
      guardPattern();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1282);
      parenthesisPattern();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WildcardPatternContext ------------------------------------------------------------------

OLangParser::WildcardPatternContext::WildcardPatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::WildcardPatternContext::WILDCARD() {
  return getToken(OLangParser::WILDCARD, 0);
}


size_t OLangParser::WildcardPatternContext::getRuleIndex() const {
  return OLangParser::RuleWildcardPattern;
}

void OLangParser::WildcardPatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWildcardPattern(this);
}

void OLangParser::WildcardPatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWildcardPattern(this);
}


std::any OLangParser::WildcardPatternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitWildcardPattern(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::WildcardPatternContext* OLangParser::wildcardPattern() {
  WildcardPatternContext *_localctx = _tracker.createInstance<WildcardPatternContext>(_ctx, getState());
  enterRule(_localctx, 236, OLangParser::RuleWildcardPattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1285);
    match(OLangParser::WILDCARD);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralPatternContext ------------------------------------------------------------------

OLangParser::LiteralPatternContext::LiteralPatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::LiteralValueContext* OLangParser::LiteralPatternContext::literalValue() {
  return getRuleContext<OLangParser::LiteralValueContext>(0);
}


size_t OLangParser::LiteralPatternContext::getRuleIndex() const {
  return OLangParser::RuleLiteralPattern;
}

void OLangParser::LiteralPatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteralPattern(this);
}

void OLangParser::LiteralPatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteralPattern(this);
}


std::any OLangParser::LiteralPatternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitLiteralPattern(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::LiteralPatternContext* OLangParser::literalPattern() {
  LiteralPatternContext *_localctx = _tracker.createInstance<LiteralPatternContext>(_ctx, getState());
  enterRule(_localctx, 238, OLangParser::RuleLiteralPattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1287);
    literalValue();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierPatternContext ------------------------------------------------------------------

OLangParser::IdentifierPatternContext::IdentifierPatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::IdentifierPatternContext::ID() {
  return getToken(OLangParser::ID, 0);
}


size_t OLangParser::IdentifierPatternContext::getRuleIndex() const {
  return OLangParser::RuleIdentifierPattern;
}

void OLangParser::IdentifierPatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierPattern(this);
}

void OLangParser::IdentifierPatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierPattern(this);
}


std::any OLangParser::IdentifierPatternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitIdentifierPattern(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::IdentifierPatternContext* OLangParser::identifierPattern() {
  IdentifierPatternContext *_localctx = _tracker.createInstance<IdentifierPatternContext>(_ctx, getState());
  enterRule(_localctx, 240, OLangParser::RuleIdentifierPattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1289);
    match(OLangParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DestructurePatternContext ------------------------------------------------------------------

OLangParser::DestructurePatternContext::DestructurePatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::ObjectDestructureContext* OLangParser::DestructurePatternContext::objectDestructure() {
  return getRuleContext<OLangParser::ObjectDestructureContext>(0);
}

OLangParser::ListDestructureContext* OLangParser::DestructurePatternContext::listDestructure() {
  return getRuleContext<OLangParser::ListDestructureContext>(0);
}

OLangParser::TupleDestructureContext* OLangParser::DestructurePatternContext::tupleDestructure() {
  return getRuleContext<OLangParser::TupleDestructureContext>(0);
}

OLangParser::NamedDestructureContext* OLangParser::DestructurePatternContext::namedDestructure() {
  return getRuleContext<OLangParser::NamedDestructureContext>(0);
}


size_t OLangParser::DestructurePatternContext::getRuleIndex() const {
  return OLangParser::RuleDestructurePattern;
}

void OLangParser::DestructurePatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDestructurePattern(this);
}

void OLangParser::DestructurePatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDestructurePattern(this);
}


std::any OLangParser::DestructurePatternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitDestructurePattern(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::DestructurePatternContext* OLangParser::destructurePattern() {
  DestructurePatternContext *_localctx = _tracker.createInstance<DestructurePatternContext>(_ctx, getState());
  enterRule(_localctx, 242, OLangParser::RuleDestructurePattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1295);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case OLangParser::LCURLY: {
        enterOuterAlt(_localctx, 1);
        setState(1291);
        objectDestructure();
        break;
      }

      case OLangParser::LBRACK: {
        enterOuterAlt(_localctx, 2);
        setState(1292);
        listDestructure();
        break;
      }

      case OLangParser::LPAREN: {
        enterOuterAlt(_localctx, 3);
        setState(1293);
        tupleDestructure();
        break;
      }

      case OLangParser::ID: {
        enterOuterAlt(_localctx, 4);
        setState(1294);
        namedDestructure();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ObjectDestructureContext ------------------------------------------------------------------

OLangParser::ObjectDestructureContext::ObjectDestructureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::ObjectDestructureContext::LCURLY() {
  return getToken(OLangParser::LCURLY, 0);
}

tree::TerminalNode* OLangParser::ObjectDestructureContext::RCURLY() {
  return getToken(OLangParser::RCURLY, 0);
}

OLangParser::PatternFieldListContext* OLangParser::ObjectDestructureContext::patternFieldList() {
  return getRuleContext<OLangParser::PatternFieldListContext>(0);
}


size_t OLangParser::ObjectDestructureContext::getRuleIndex() const {
  return OLangParser::RuleObjectDestructure;
}

void OLangParser::ObjectDestructureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterObjectDestructure(this);
}

void OLangParser::ObjectDestructureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitObjectDestructure(this);
}


std::any OLangParser::ObjectDestructureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitObjectDestructure(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ObjectDestructureContext* OLangParser::objectDestructure() {
  ObjectDestructureContext *_localctx = _tracker.createInstance<ObjectDestructureContext>(_ctx, getState());
  enterRule(_localctx, 244, OLangParser::RuleObjectDestructure);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1297);
    match(OLangParser::LCURLY);
    setState(1299);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == OLangParser::WILDCARD

    || _la == OLangParser::ID) {
      setState(1298);
      patternFieldList();
    }
    setState(1301);
    match(OLangParser::RCURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ListDestructureContext ------------------------------------------------------------------

OLangParser::ListDestructureContext::ListDestructureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::ListDestructureContext::LBRACK() {
  return getToken(OLangParser::LBRACK, 0);
}

tree::TerminalNode* OLangParser::ListDestructureContext::RBRACK() {
  return getToken(OLangParser::RBRACK, 0);
}

OLangParser::PatternListContext* OLangParser::ListDestructureContext::patternList() {
  return getRuleContext<OLangParser::PatternListContext>(0);
}


size_t OLangParser::ListDestructureContext::getRuleIndex() const {
  return OLangParser::RuleListDestructure;
}

void OLangParser::ListDestructureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterListDestructure(this);
}

void OLangParser::ListDestructureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitListDestructure(this);
}


std::any OLangParser::ListDestructureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitListDestructure(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ListDestructureContext* OLangParser::listDestructure() {
  ListDestructureContext *_localctx = _tracker.createInstance<ListDestructureContext>(_ctx, getState());
  enterRule(_localctx, 246, OLangParser::RuleListDestructure);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1303);
    match(OLangParser::LBRACK);
    setState(1305);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & 291325501383901185) != 0) {
      setState(1304);
      patternList();
    }
    setState(1307);
    match(OLangParser::RBRACK);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TupleDestructureContext ------------------------------------------------------------------

OLangParser::TupleDestructureContext::TupleDestructureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::TupleDestructureContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

OLangParser::PatternListContext* OLangParser::TupleDestructureContext::patternList() {
  return getRuleContext<OLangParser::PatternListContext>(0);
}

tree::TerminalNode* OLangParser::TupleDestructureContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}


size_t OLangParser::TupleDestructureContext::getRuleIndex() const {
  return OLangParser::RuleTupleDestructure;
}

void OLangParser::TupleDestructureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTupleDestructure(this);
}

void OLangParser::TupleDestructureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTupleDestructure(this);
}


std::any OLangParser::TupleDestructureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitTupleDestructure(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::TupleDestructureContext* OLangParser::tupleDestructure() {
  TupleDestructureContext *_localctx = _tracker.createInstance<TupleDestructureContext>(_ctx, getState());
  enterRule(_localctx, 248, OLangParser::RuleTupleDestructure);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1309);
    match(OLangParser::LPAREN);
    setState(1310);
    patternList();
    setState(1311);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamedDestructureContext ------------------------------------------------------------------

OLangParser::NamedDestructureContext::NamedDestructureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::QualifiedNameContext* OLangParser::NamedDestructureContext::qualifiedName() {
  return getRuleContext<OLangParser::QualifiedNameContext>(0);
}

tree::TerminalNode* OLangParser::NamedDestructureContext::LCURLY() {
  return getToken(OLangParser::LCURLY, 0);
}

tree::TerminalNode* OLangParser::NamedDestructureContext::RCURLY() {
  return getToken(OLangParser::RCURLY, 0);
}

OLangParser::PatternFieldListContext* OLangParser::NamedDestructureContext::patternFieldList() {
  return getRuleContext<OLangParser::PatternFieldListContext>(0);
}


size_t OLangParser::NamedDestructureContext::getRuleIndex() const {
  return OLangParser::RuleNamedDestructure;
}

void OLangParser::NamedDestructureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamedDestructure(this);
}

void OLangParser::NamedDestructureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamedDestructure(this);
}


std::any OLangParser::NamedDestructureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitNamedDestructure(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::NamedDestructureContext* OLangParser::namedDestructure() {
  NamedDestructureContext *_localctx = _tracker.createInstance<NamedDestructureContext>(_ctx, getState());
  enterRule(_localctx, 250, OLangParser::RuleNamedDestructure);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1313);
    qualifiedName();
    setState(1314);
    match(OLangParser::LCURLY);
    setState(1316);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == OLangParser::WILDCARD

    || _la == OLangParser::ID) {
      setState(1315);
      patternFieldList();
    }
    setState(1318);
    match(OLangParser::RCURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RangePatternContext ------------------------------------------------------------------

OLangParser::RangePatternContext::RangePatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::SimpleRangeValueContext *> OLangParser::RangePatternContext::simpleRangeValue() {
  return getRuleContexts<OLangParser::SimpleRangeValueContext>();
}

OLangParser::SimpleRangeValueContext* OLangParser::RangePatternContext::simpleRangeValue(size_t i) {
  return getRuleContext<OLangParser::SimpleRangeValueContext>(i);
}

tree::TerminalNode* OLangParser::RangePatternContext::RANGE_OP() {
  return getToken(OLangParser::RANGE_OP, 0);
}

tree::TerminalNode* OLangParser::RangePatternContext::INCLUSIVE_RANGE() {
  return getToken(OLangParser::INCLUSIVE_RANGE, 0);
}


size_t OLangParser::RangePatternContext::getRuleIndex() const {
  return OLangParser::RuleRangePattern;
}

void OLangParser::RangePatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRangePattern(this);
}

void OLangParser::RangePatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRangePattern(this);
}


std::any OLangParser::RangePatternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitRangePattern(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::RangePatternContext* OLangParser::rangePattern() {
  RangePatternContext *_localctx = _tracker.createInstance<RangePatternContext>(_ctx, getState());
  enterRule(_localctx, 252, OLangParser::RuleRangePattern);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1320);
    simpleRangeValue();
    setState(1321);
    _la = _input->LA(1);
    if (!(_la == OLangParser::RANGE_OP

    || _la == OLangParser::INCLUSIVE_RANGE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1322);
    simpleRangeValue();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleRangeValueContext ------------------------------------------------------------------

OLangParser::SimpleRangeValueContext::SimpleRangeValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::LiteralValueContext* OLangParser::SimpleRangeValueContext::literalValue() {
  return getRuleContext<OLangParser::LiteralValueContext>(0);
}

tree::TerminalNode* OLangParser::SimpleRangeValueContext::ID() {
  return getToken(OLangParser::ID, 0);
}

OLangParser::QualifiedNameContext* OLangParser::SimpleRangeValueContext::qualifiedName() {
  return getRuleContext<OLangParser::QualifiedNameContext>(0);
}


size_t OLangParser::SimpleRangeValueContext::getRuleIndex() const {
  return OLangParser::RuleSimpleRangeValue;
}

void OLangParser::SimpleRangeValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleRangeValue(this);
}

void OLangParser::SimpleRangeValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleRangeValue(this);
}


std::any OLangParser::SimpleRangeValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitSimpleRangeValue(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::SimpleRangeValueContext* OLangParser::simpleRangeValue() {
  SimpleRangeValueContext *_localctx = _tracker.createInstance<SimpleRangeValueContext>(_ctx, getState());
  enterRule(_localctx, 254, OLangParser::RuleSimpleRangeValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1327);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 103, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1324);
      literalValue();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1325);
      match(OLangParser::ID);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1326);
      qualifiedName();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypePatternContext ------------------------------------------------------------------

OLangParser::TypePatternContext::TypePatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::SimplePatternContext* OLangParser::TypePatternContext::simplePattern() {
  return getRuleContext<OLangParser::SimplePatternContext>(0);
}

tree::TerminalNode* OLangParser::TypePatternContext::COLON() {
  return getToken(OLangParser::COLON, 0);
}

OLangParser::TypeContext* OLangParser::TypePatternContext::type() {
  return getRuleContext<OLangParser::TypeContext>(0);
}


size_t OLangParser::TypePatternContext::getRuleIndex() const {
  return OLangParser::RuleTypePattern;
}

void OLangParser::TypePatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypePattern(this);
}

void OLangParser::TypePatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypePattern(this);
}


std::any OLangParser::TypePatternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitTypePattern(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::TypePatternContext* OLangParser::typePattern() {
  TypePatternContext *_localctx = _tracker.createInstance<TypePatternContext>(_ctx, getState());
  enterRule(_localctx, 256, OLangParser::RuleTypePattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1329);
    simplePattern();
    setState(1330);
    match(OLangParser::COLON);
    setState(1331);
    type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimplePatternContext ------------------------------------------------------------------

OLangParser::SimplePatternContext::SimplePatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::WildcardPatternContext* OLangParser::SimplePatternContext::wildcardPattern() {
  return getRuleContext<OLangParser::WildcardPatternContext>(0);
}

OLangParser::LiteralPatternContext* OLangParser::SimplePatternContext::literalPattern() {
  return getRuleContext<OLangParser::LiteralPatternContext>(0);
}

OLangParser::IdentifierPatternContext* OLangParser::SimplePatternContext::identifierPattern() {
  return getRuleContext<OLangParser::IdentifierPatternContext>(0);
}

OLangParser::ParenthesisPatternContext* OLangParser::SimplePatternContext::parenthesisPattern() {
  return getRuleContext<OLangParser::ParenthesisPatternContext>(0);
}


size_t OLangParser::SimplePatternContext::getRuleIndex() const {
  return OLangParser::RuleSimplePattern;
}

void OLangParser::SimplePatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimplePattern(this);
}

void OLangParser::SimplePatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimplePattern(this);
}


std::any OLangParser::SimplePatternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitSimplePattern(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::SimplePatternContext* OLangParser::simplePattern() {
  SimplePatternContext *_localctx = _tracker.createInstance<SimplePatternContext>(_ctx, getState());
  enterRule(_localctx, 258, OLangParser::RuleSimplePattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1337);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case OLangParser::WILDCARD: {
        enterOuterAlt(_localctx, 1);
        setState(1333);
        wildcardPattern();
        break;
      }

      case OLangParser::NULL_LIT:
      case OLangParser::BOOLEAN:
      case OLangParser::INT_LITERAL:
      case OLangParser::DECIMAL_LITERAL:
      case OLangParser::STRING:
      case OLangParser::RAW_STRING:
      case OLangParser::MULTILINE_STRING: {
        enterOuterAlt(_localctx, 2);
        setState(1334);
        literalPattern();
        break;
      }

      case OLangParser::ID: {
        enterOuterAlt(_localctx, 3);
        setState(1335);
        identifierPattern();
        break;
      }

      case OLangParser::LPAREN: {
        enterOuterAlt(_localctx, 4);
        setState(1336);
        parenthesisPattern();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GuardPatternContext ------------------------------------------------------------------

OLangParser::GuardPatternContext::GuardPatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::SimplePatternContext* OLangParser::GuardPatternContext::simplePattern() {
  return getRuleContext<OLangParser::SimplePatternContext>(0);
}

tree::TerminalNode* OLangParser::GuardPatternContext::WHEN() {
  return getToken(OLangParser::WHEN, 0);
}

OLangParser::SimpleConditionContext* OLangParser::GuardPatternContext::simpleCondition() {
  return getRuleContext<OLangParser::SimpleConditionContext>(0);
}


size_t OLangParser::GuardPatternContext::getRuleIndex() const {
  return OLangParser::RuleGuardPattern;
}

void OLangParser::GuardPatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGuardPattern(this);
}

void OLangParser::GuardPatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGuardPattern(this);
}


std::any OLangParser::GuardPatternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitGuardPattern(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::GuardPatternContext* OLangParser::guardPattern() {
  GuardPatternContext *_localctx = _tracker.createInstance<GuardPatternContext>(_ctx, getState());
  enterRule(_localctx, 260, OLangParser::RuleGuardPattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1339);
    simplePattern();
    setState(1340);
    match(OLangParser::WHEN);
    setState(1341);
    simpleCondition();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleConditionContext ------------------------------------------------------------------

OLangParser::SimpleConditionContext::SimpleConditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::SimpleConditionContext::ID() {
  return getToken(OLangParser::ID, 0);
}

OLangParser::LiteralValueContext* OLangParser::SimpleConditionContext::literalValue() {
  return getRuleContext<OLangParser::LiteralValueContext>(0);
}

tree::TerminalNode* OLangParser::SimpleConditionContext::EQ() {
  return getToken(OLangParser::EQ, 0);
}

tree::TerminalNode* OLangParser::SimpleConditionContext::NEQ() {
  return getToken(OLangParser::NEQ, 0);
}

tree::TerminalNode* OLangParser::SimpleConditionContext::LT() {
  return getToken(OLangParser::LT, 0);
}

tree::TerminalNode* OLangParser::SimpleConditionContext::GT() {
  return getToken(OLangParser::GT, 0);
}

tree::TerminalNode* OLangParser::SimpleConditionContext::LE() {
  return getToken(OLangParser::LE, 0);
}

tree::TerminalNode* OLangParser::SimpleConditionContext::GE() {
  return getToken(OLangParser::GE, 0);
}


size_t OLangParser::SimpleConditionContext::getRuleIndex() const {
  return OLangParser::RuleSimpleCondition;
}

void OLangParser::SimpleConditionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleCondition(this);
}

void OLangParser::SimpleConditionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleCondition(this);
}


std::any OLangParser::SimpleConditionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitSimpleCondition(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::SimpleConditionContext* OLangParser::simpleCondition() {
  SimpleConditionContext *_localctx = _tracker.createInstance<SimpleConditionContext>(_ctx, getState());
  enterRule(_localctx, 262, OLangParser::RuleSimpleCondition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1347);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case OLangParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(1343);
        match(OLangParser::ID);
        setState(1344);
        _la = _input->LA(1);
        if (!((((_la - 85) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 85)) & 63) != 0)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(1345);
        literalValue();
        break;
      }

      case OLangParser::NULL_LIT:
      case OLangParser::BOOLEAN:
      case OLangParser::INT_LITERAL:
      case OLangParser::DECIMAL_LITERAL:
      case OLangParser::STRING:
      case OLangParser::RAW_STRING:
      case OLangParser::MULTILINE_STRING: {
        enterOuterAlt(_localctx, 2);
        setState(1346);
        literalValue();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParenthesisPatternContext ------------------------------------------------------------------

OLangParser::ParenthesisPatternContext::ParenthesisPatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::ParenthesisPatternContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

OLangParser::PatternContext* OLangParser::ParenthesisPatternContext::pattern() {
  return getRuleContext<OLangParser::PatternContext>(0);
}

tree::TerminalNode* OLangParser::ParenthesisPatternContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}


size_t OLangParser::ParenthesisPatternContext::getRuleIndex() const {
  return OLangParser::RuleParenthesisPattern;
}

void OLangParser::ParenthesisPatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParenthesisPattern(this);
}

void OLangParser::ParenthesisPatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParenthesisPattern(this);
}


std::any OLangParser::ParenthesisPatternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitParenthesisPattern(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ParenthesisPatternContext* OLangParser::parenthesisPattern() {
  ParenthesisPatternContext *_localctx = _tracker.createInstance<ParenthesisPatternContext>(_ctx, getState());
  enterRule(_localctx, 264, OLangParser::RuleParenthesisPattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1349);
    match(OLangParser::LPAREN);
    setState(1350);
    pattern();
    setState(1351);
    match(OLangParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PatternFieldContext ------------------------------------------------------------------

OLangParser::PatternFieldContext::PatternFieldContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::PatternFieldContext::ID() {
  return getToken(OLangParser::ID, 0);
}

tree::TerminalNode* OLangParser::PatternFieldContext::COLON() {
  return getToken(OLangParser::COLON, 0);
}

OLangParser::PatternContext* OLangParser::PatternFieldContext::pattern() {
  return getRuleContext<OLangParser::PatternContext>(0);
}

tree::TerminalNode* OLangParser::PatternFieldContext::WILDCARD() {
  return getToken(OLangParser::WILDCARD, 0);
}


size_t OLangParser::PatternFieldContext::getRuleIndex() const {
  return OLangParser::RulePatternField;
}

void OLangParser::PatternFieldContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPatternField(this);
}

void OLangParser::PatternFieldContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPatternField(this);
}


std::any OLangParser::PatternFieldContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitPatternField(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::PatternFieldContext* OLangParser::patternField() {
  PatternFieldContext *_localctx = _tracker.createInstance<PatternFieldContext>(_ctx, getState());
  enterRule(_localctx, 266, OLangParser::RulePatternField);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1358);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 106, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1353);
      match(OLangParser::ID);
      setState(1354);
      match(OLangParser::COLON);
      setState(1355);
      pattern();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1356);
      match(OLangParser::ID);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1357);
      match(OLangParser::WILDCARD);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PatternFieldListContext ------------------------------------------------------------------

OLangParser::PatternFieldListContext::PatternFieldListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::PatternFieldContext *> OLangParser::PatternFieldListContext::patternField() {
  return getRuleContexts<OLangParser::PatternFieldContext>();
}

OLangParser::PatternFieldContext* OLangParser::PatternFieldListContext::patternField(size_t i) {
  return getRuleContext<OLangParser::PatternFieldContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::PatternFieldListContext::COMMA() {
  return getTokens(OLangParser::COMMA);
}

tree::TerminalNode* OLangParser::PatternFieldListContext::COMMA(size_t i) {
  return getToken(OLangParser::COMMA, i);
}


size_t OLangParser::PatternFieldListContext::getRuleIndex() const {
  return OLangParser::RulePatternFieldList;
}

void OLangParser::PatternFieldListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPatternFieldList(this);
}

void OLangParser::PatternFieldListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPatternFieldList(this);
}


std::any OLangParser::PatternFieldListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitPatternFieldList(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::PatternFieldListContext* OLangParser::patternFieldList() {
  PatternFieldListContext *_localctx = _tracker.createInstance<PatternFieldListContext>(_ctx, getState());
  enterRule(_localctx, 268, OLangParser::RulePatternFieldList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1360);
    patternField();
    setState(1365);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1361);
        match(OLangParser::COMMA);
        setState(1362);
        patternField(); 
      }
      setState(1367);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx);
    }
    setState(1369);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == OLangParser::COMMA) {
      setState(1368);
      match(OLangParser::COMMA);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PatternListContext ------------------------------------------------------------------

OLangParser::PatternListContext::PatternListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::PatternContext *> OLangParser::PatternListContext::pattern() {
  return getRuleContexts<OLangParser::PatternContext>();
}

OLangParser::PatternContext* OLangParser::PatternListContext::pattern(size_t i) {
  return getRuleContext<OLangParser::PatternContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::PatternListContext::COMMA() {
  return getTokens(OLangParser::COMMA);
}

tree::TerminalNode* OLangParser::PatternListContext::COMMA(size_t i) {
  return getToken(OLangParser::COMMA, i);
}


size_t OLangParser::PatternListContext::getRuleIndex() const {
  return OLangParser::RulePatternList;
}

void OLangParser::PatternListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPatternList(this);
}

void OLangParser::PatternListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPatternList(this);
}


std::any OLangParser::PatternListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitPatternList(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::PatternListContext* OLangParser::patternList() {
  PatternListContext *_localctx = _tracker.createInstance<PatternListContext>(_ctx, getState());
  enterRule(_localctx, 270, OLangParser::RulePatternList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1371);
    pattern();
    setState(1376);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1372);
        match(OLangParser::COMMA);
        setState(1373);
        pattern(); 
      }
      setState(1378);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx);
    }
    setState(1380);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == OLangParser::COMMA) {
      setState(1379);
      match(OLangParser::COMMA);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MutationExpressionContext ------------------------------------------------------------------

OLangParser::MutationExpressionContext::MutationExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::PostfixExpressionContext* OLangParser::MutationExpressionContext::postfixExpression() {
  return getRuleContext<OLangParser::PostfixExpressionContext>(0);
}

tree::TerminalNode* OLangParser::MutationExpressionContext::MUTATE_AT() {
  return getToken(OLangParser::MUTATE_AT, 0);
}

OLangParser::MutationSiteContext* OLangParser::MutationExpressionContext::mutationSite() {
  return getRuleContext<OLangParser::MutationSiteContext>(0);
}

OLangParser::MutationChangeContext* OLangParser::MutationExpressionContext::mutationChange() {
  return getRuleContext<OLangParser::MutationChangeContext>(0);
}


size_t OLangParser::MutationExpressionContext::getRuleIndex() const {
  return OLangParser::RuleMutationExpression;
}

void OLangParser::MutationExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMutationExpression(this);
}

void OLangParser::MutationExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMutationExpression(this);
}


std::any OLangParser::MutationExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitMutationExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::MutationExpressionContext* OLangParser::mutationExpression() {
  MutationExpressionContext *_localctx = _tracker.createInstance<MutationExpressionContext>(_ctx, getState());
  enterRule(_localctx, 272, OLangParser::RuleMutationExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1382);
    postfixExpression();
    setState(1383);
    match(OLangParser::MUTATE_AT);
    setState(1384);
    mutationSite();
    setState(1385);
    mutationChange();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MutationSiteContext ------------------------------------------------------------------

OLangParser::MutationSiteContext::MutationSiteContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::MutationSiteContext::INT_LITERAL() {
  return getToken(OLangParser::INT_LITERAL, 0);
}

tree::TerminalNode* OLangParser::MutationSiteContext::ID() {
  return getToken(OLangParser::ID, 0);
}

tree::TerminalNode* OLangParser::MutationSiteContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

tree::TerminalNode* OLangParser::MutationSiteContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}

OLangParser::RangeExpressionContext* OLangParser::MutationSiteContext::rangeExpression() {
  return getRuleContext<OLangParser::RangeExpressionContext>(0);
}


size_t OLangParser::MutationSiteContext::getRuleIndex() const {
  return OLangParser::RuleMutationSite;
}

void OLangParser::MutationSiteContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMutationSite(this);
}

void OLangParser::MutationSiteContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMutationSite(this);
}


std::any OLangParser::MutationSiteContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitMutationSite(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::MutationSiteContext* OLangParser::mutationSite() {
  MutationSiteContext *_localctx = _tracker.createInstance<MutationSiteContext>(_ctx, getState());
  enterRule(_localctx, 274, OLangParser::RuleMutationSite);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1393);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 111, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1387);
      match(OLangParser::INT_LITERAL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1388);
      match(OLangParser::ID);
      setState(1389);
      match(OLangParser::LPAREN);
      setState(1390);
      match(OLangParser::INT_LITERAL);
      setState(1391);
      match(OLangParser::RPAREN);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1392);
      rangeExpression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MutationChangeContext ------------------------------------------------------------------

OLangParser::MutationChangeContext::MutationChangeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> OLangParser::MutationChangeContext::ID() {
  return getTokens(OLangParser::ID);
}

tree::TerminalNode* OLangParser::MutationChangeContext::ID(size_t i) {
  return getToken(OLangParser::ID, i);
}

tree::TerminalNode* OLangParser::MutationChangeContext::BIO_TRANSFORM() {
  return getToken(OLangParser::BIO_TRANSFORM, 0);
}

std::vector<OLangParser::ExpressionContext *> OLangParser::MutationChangeContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::MutationChangeContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}


size_t OLangParser::MutationChangeContext::getRuleIndex() const {
  return OLangParser::RuleMutationChange;
}

void OLangParser::MutationChangeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMutationChange(this);
}

void OLangParser::MutationChangeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMutationChange(this);
}


std::any OLangParser::MutationChangeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitMutationChange(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::MutationChangeContext* OLangParser::mutationChange() {
  MutationChangeContext *_localctx = _tracker.createInstance<MutationChangeContext>(_ctx, getState());
  enterRule(_localctx, 276, OLangParser::RuleMutationChange);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1402);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 112, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1395);
      match(OLangParser::ID);
      setState(1396);
      match(OLangParser::BIO_TRANSFORM);
      setState(1397);
      match(OLangParser::ID);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1398);
      expression();
      setState(1399);
      match(OLangParser::BIO_TRANSFORM);
      setState(1400);
      expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RangeExpressionContext ------------------------------------------------------------------

OLangParser::RangeExpressionContext::RangeExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::ExpressionContext *> OLangParser::RangeExpressionContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::RangeExpressionContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}

tree::TerminalNode* OLangParser::RangeExpressionContext::RANGE_OP() {
  return getToken(OLangParser::RANGE_OP, 0);
}

tree::TerminalNode* OLangParser::RangeExpressionContext::INCLUSIVE_RANGE() {
  return getToken(OLangParser::INCLUSIVE_RANGE, 0);
}

tree::TerminalNode* OLangParser::RangeExpressionContext::EXCLUSIVE_RANGE() {
  return getToken(OLangParser::EXCLUSIVE_RANGE, 0);
}


size_t OLangParser::RangeExpressionContext::getRuleIndex() const {
  return OLangParser::RuleRangeExpression;
}

void OLangParser::RangeExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRangeExpression(this);
}

void OLangParser::RangeExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRangeExpression(this);
}


std::any OLangParser::RangeExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitRangeExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::RangeExpressionContext* OLangParser::rangeExpression() {
  RangeExpressionContext *_localctx = _tracker.createInstance<RangeExpressionContext>(_ctx, getState());
  enterRule(_localctx, 278, OLangParser::RuleRangeExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1416);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 113, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1404);
      expression();
      setState(1405);
      match(OLangParser::RANGE_OP);
      setState(1406);
      expression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1408);
      expression();
      setState(1409);
      match(OLangParser::INCLUSIVE_RANGE);
      setState(1410);
      expression();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1412);
      expression();
      setState(1413);
      match(OLangParser::EXCLUSIVE_RANGE);
      setState(1414);
      expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ListExpressionContext ------------------------------------------------------------------

OLangParser::ListExpressionContext::ListExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::ListExpressionContext::LBRACK() {
  return getToken(OLangParser::LBRACK, 0);
}

tree::TerminalNode* OLangParser::ListExpressionContext::RBRACK() {
  return getToken(OLangParser::RBRACK, 0);
}

OLangParser::ExpressionListContext* OLangParser::ListExpressionContext::expressionList() {
  return getRuleContext<OLangParser::ExpressionListContext>(0);
}


size_t OLangParser::ListExpressionContext::getRuleIndex() const {
  return OLangParser::RuleListExpression;
}

void OLangParser::ListExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterListExpression(this);
}

void OLangParser::ListExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitListExpression(this);
}


std::any OLangParser::ListExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitListExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ListExpressionContext* OLangParser::listExpression() {
  ListExpressionContext *_localctx = _tracker.createInstance<ListExpressionContext>(_ctx, getState());
  enterRule(_localctx, 280, OLangParser::RuleListExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1418);
    match(OLangParser::LBRACK);
    setState(1420);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2233785277761980416) != 0 || (((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & 291324401880665089) != 0) {
      setState(1419);
      expressionList();
    }
    setState(1422);
    match(OLangParser::RBRACK);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ObjectExpressionContext ------------------------------------------------------------------

OLangParser::ObjectExpressionContext::ObjectExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::ObjectExpressionContext::LCURLY() {
  return getToken(OLangParser::LCURLY, 0);
}

tree::TerminalNode* OLangParser::ObjectExpressionContext::RCURLY() {
  return getToken(OLangParser::RCURLY, 0);
}

OLangParser::ObjectFieldListContext* OLangParser::ObjectExpressionContext::objectFieldList() {
  return getRuleContext<OLangParser::ObjectFieldListContext>(0);
}


size_t OLangParser::ObjectExpressionContext::getRuleIndex() const {
  return OLangParser::RuleObjectExpression;
}

void OLangParser::ObjectExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterObjectExpression(this);
}

void OLangParser::ObjectExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitObjectExpression(this);
}


std::any OLangParser::ObjectExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitObjectExpression(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ObjectExpressionContext* OLangParser::objectExpression() {
  ObjectExpressionContext *_localctx = _tracker.createInstance<ObjectExpressionContext>(_ctx, getState());
  enterRule(_localctx, 282, OLangParser::RuleObjectExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1424);
    match(OLangParser::LCURLY);
    setState(1426);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == OLangParser::STRING

    || _la == OLangParser::ID) {
      setState(1425);
      objectFieldList();
    }
    setState(1428);
    match(OLangParser::RCURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ObjectFieldContext ------------------------------------------------------------------

OLangParser::ObjectFieldContext::ObjectFieldContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::ObjectFieldContext::COLON() {
  return getToken(OLangParser::COLON, 0);
}

OLangParser::ExpressionContext* OLangParser::ObjectFieldContext::expression() {
  return getRuleContext<OLangParser::ExpressionContext>(0);
}

tree::TerminalNode* OLangParser::ObjectFieldContext::ID() {
  return getToken(OLangParser::ID, 0);
}

tree::TerminalNode* OLangParser::ObjectFieldContext::STRING() {
  return getToken(OLangParser::STRING, 0);
}


size_t OLangParser::ObjectFieldContext::getRuleIndex() const {
  return OLangParser::RuleObjectField;
}

void OLangParser::ObjectFieldContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterObjectField(this);
}

void OLangParser::ObjectFieldContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitObjectField(this);
}


std::any OLangParser::ObjectFieldContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitObjectField(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ObjectFieldContext* OLangParser::objectField() {
  ObjectFieldContext *_localctx = _tracker.createInstance<ObjectFieldContext>(_ctx, getState());
  enterRule(_localctx, 284, OLangParser::RuleObjectField);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1430);
    _la = _input->LA(1);
    if (!(_la == OLangParser::STRING

    || _la == OLangParser::ID)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1431);
    match(OLangParser::COLON);
    setState(1432);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ObjectFieldListContext ------------------------------------------------------------------

OLangParser::ObjectFieldListContext::ObjectFieldListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::ObjectFieldContext *> OLangParser::ObjectFieldListContext::objectField() {
  return getRuleContexts<OLangParser::ObjectFieldContext>();
}

OLangParser::ObjectFieldContext* OLangParser::ObjectFieldListContext::objectField(size_t i) {
  return getRuleContext<OLangParser::ObjectFieldContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::ObjectFieldListContext::COMMA() {
  return getTokens(OLangParser::COMMA);
}

tree::TerminalNode* OLangParser::ObjectFieldListContext::COMMA(size_t i) {
  return getToken(OLangParser::COMMA, i);
}


size_t OLangParser::ObjectFieldListContext::getRuleIndex() const {
  return OLangParser::RuleObjectFieldList;
}

void OLangParser::ObjectFieldListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterObjectFieldList(this);
}

void OLangParser::ObjectFieldListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitObjectFieldList(this);
}


std::any OLangParser::ObjectFieldListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitObjectFieldList(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ObjectFieldListContext* OLangParser::objectFieldList() {
  ObjectFieldListContext *_localctx = _tracker.createInstance<ObjectFieldListContext>(_ctx, getState());
  enterRule(_localctx, 286, OLangParser::RuleObjectFieldList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1434);
    objectField();
    setState(1439);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1435);
        match(OLangParser::COMMA);
        setState(1436);
        objectField(); 
      }
      setState(1441);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx);
    }
    setState(1443);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == OLangParser::COMMA) {
      setState(1442);
      match(OLangParser::COMMA);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentStatementContext ------------------------------------------------------------------

OLangParser::AssignmentStatementContext::AssignmentStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::QualifiedNameContext* OLangParser::AssignmentStatementContext::qualifiedName() {
  return getRuleContext<OLangParser::QualifiedNameContext>(0);
}

tree::TerminalNode* OLangParser::AssignmentStatementContext::EQUALS() {
  return getToken(OLangParser::EQUALS, 0);
}

OLangParser::ExpressionContext* OLangParser::AssignmentStatementContext::expression() {
  return getRuleContext<OLangParser::ExpressionContext>(0);
}

tree::TerminalNode* OLangParser::AssignmentStatementContext::SEMI() {
  return getToken(OLangParser::SEMI, 0);
}


size_t OLangParser::AssignmentStatementContext::getRuleIndex() const {
  return OLangParser::RuleAssignmentStatement;
}

void OLangParser::AssignmentStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentStatement(this);
}

void OLangParser::AssignmentStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentStatement(this);
}


std::any OLangParser::AssignmentStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitAssignmentStatement(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::AssignmentStatementContext* OLangParser::assignmentStatement() {
  AssignmentStatementContext *_localctx = _tracker.createInstance<AssignmentStatementContext>(_ctx, getState());
  enterRule(_localctx, 288, OLangParser::RuleAssignmentStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1445);
    qualifiedName();
    setState(1446);
    match(OLangParser::EQUALS);
    setState(1447);
    expression();
    setState(1448);
    match(OLangParser::SEMI);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnnotationPairListContext ------------------------------------------------------------------

OLangParser::AnnotationPairListContext::AnnotationPairListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::AnnotationPairContext *> OLangParser::AnnotationPairListContext::annotationPair() {
  return getRuleContexts<OLangParser::AnnotationPairContext>();
}

OLangParser::AnnotationPairContext* OLangParser::AnnotationPairListContext::annotationPair(size_t i) {
  return getRuleContext<OLangParser::AnnotationPairContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::AnnotationPairListContext::COMMA() {
  return getTokens(OLangParser::COMMA);
}

tree::TerminalNode* OLangParser::AnnotationPairListContext::COMMA(size_t i) {
  return getToken(OLangParser::COMMA, i);
}


size_t OLangParser::AnnotationPairListContext::getRuleIndex() const {
  return OLangParser::RuleAnnotationPairList;
}

void OLangParser::AnnotationPairListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnnotationPairList(this);
}

void OLangParser::AnnotationPairListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnnotationPairList(this);
}


std::any OLangParser::AnnotationPairListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitAnnotationPairList(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::AnnotationPairListContext* OLangParser::annotationPairList() {
  AnnotationPairListContext *_localctx = _tracker.createInstance<AnnotationPairListContext>(_ctx, getState());
  enterRule(_localctx, 290, OLangParser::RuleAnnotationPairList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1450);
    annotationPair();
    setState(1455);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == OLangParser::COMMA) {
      setState(1451);
      match(OLangParser::COMMA);
      setState(1452);
      annotationPair();
      setState(1457);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnnotationPairContext ------------------------------------------------------------------

OLangParser::AnnotationPairContext::AnnotationPairContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::AnnotationPairContext::ID() {
  return getToken(OLangParser::ID, 0);
}

tree::TerminalNode* OLangParser::AnnotationPairContext::COLON() {
  return getToken(OLangParser::COLON, 0);
}

OLangParser::AnnotationValueContext* OLangParser::AnnotationPairContext::annotationValue() {
  return getRuleContext<OLangParser::AnnotationValueContext>(0);
}


size_t OLangParser::AnnotationPairContext::getRuleIndex() const {
  return OLangParser::RuleAnnotationPair;
}

void OLangParser::AnnotationPairContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnnotationPair(this);
}

void OLangParser::AnnotationPairContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnnotationPair(this);
}


std::any OLangParser::AnnotationPairContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitAnnotationPair(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::AnnotationPairContext* OLangParser::annotationPair() {
  AnnotationPairContext *_localctx = _tracker.createInstance<AnnotationPairContext>(_ctx, getState());
  enterRule(_localctx, 292, OLangParser::RuleAnnotationPair);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1458);
    match(OLangParser::ID);
    setState(1459);
    match(OLangParser::COLON);
    setState(1460);
    annotationValue();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnnotationValueContext ------------------------------------------------------------------

OLangParser::AnnotationValueContext::AnnotationValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

OLangParser::LiteralValueContext* OLangParser::AnnotationValueContext::literalValue() {
  return getRuleContext<OLangParser::LiteralValueContext>(0);
}

OLangParser::ListLiteralContext* OLangParser::AnnotationValueContext::listLiteral() {
  return getRuleContext<OLangParser::ListLiteralContext>(0);
}


size_t OLangParser::AnnotationValueContext::getRuleIndex() const {
  return OLangParser::RuleAnnotationValue;
}

void OLangParser::AnnotationValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnnotationValue(this);
}

void OLangParser::AnnotationValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnnotationValue(this);
}


std::any OLangParser::AnnotationValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitAnnotationValue(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::AnnotationValueContext* OLangParser::annotationValue() {
  AnnotationValueContext *_localctx = _tracker.createInstance<AnnotationValueContext>(_ctx, getState());
  enterRule(_localctx, 294, OLangParser::RuleAnnotationValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1464);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case OLangParser::NULL_LIT:
      case OLangParser::BOOLEAN:
      case OLangParser::INT_LITERAL:
      case OLangParser::DECIMAL_LITERAL:
      case OLangParser::STRING:
      case OLangParser::RAW_STRING:
      case OLangParser::MULTILINE_STRING: {
        enterOuterAlt(_localctx, 1);
        setState(1462);
        literalValue();
        break;
      }

      case OLangParser::LBRACK: {
        enterOuterAlt(_localctx, 2);
        setState(1463);
        listLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ListLiteralContext ------------------------------------------------------------------

OLangParser::ListLiteralContext::ListLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::ListLiteralContext::LBRACK() {
  return getToken(OLangParser::LBRACK, 0);
}

tree::TerminalNode* OLangParser::ListLiteralContext::RBRACK() {
  return getToken(OLangParser::RBRACK, 0);
}

OLangParser::AnnotationValueListContext* OLangParser::ListLiteralContext::annotationValueList() {
  return getRuleContext<OLangParser::AnnotationValueListContext>(0);
}


size_t OLangParser::ListLiteralContext::getRuleIndex() const {
  return OLangParser::RuleListLiteral;
}

void OLangParser::ListLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterListLiteral(this);
}

void OLangParser::ListLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitListLiteral(this);
}


std::any OLangParser::ListLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitListLiteral(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ListLiteralContext* OLangParser::listLiteral() {
  ListLiteralContext *_localctx = _tracker.createInstance<ListLiteralContext>(_ctx, getState());
  enterRule(_localctx, 296, OLangParser::RuleListLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1466);
    match(OLangParser::LBRACK);
    setState(1468);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & 701488418521089) != 0) {
      setState(1467);
      annotationValueList();
    }
    setState(1470);
    match(OLangParser::RBRACK);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnnotationValueListContext ------------------------------------------------------------------

OLangParser::AnnotationValueListContext::AnnotationValueListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::AnnotationValueContext *> OLangParser::AnnotationValueListContext::annotationValue() {
  return getRuleContexts<OLangParser::AnnotationValueContext>();
}

OLangParser::AnnotationValueContext* OLangParser::AnnotationValueListContext::annotationValue(size_t i) {
  return getRuleContext<OLangParser::AnnotationValueContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::AnnotationValueListContext::COMMA() {
  return getTokens(OLangParser::COMMA);
}

tree::TerminalNode* OLangParser::AnnotationValueListContext::COMMA(size_t i) {
  return getToken(OLangParser::COMMA, i);
}


size_t OLangParser::AnnotationValueListContext::getRuleIndex() const {
  return OLangParser::RuleAnnotationValueList;
}

void OLangParser::AnnotationValueListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnnotationValueList(this);
}

void OLangParser::AnnotationValueListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnnotationValueList(this);
}


std::any OLangParser::AnnotationValueListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitAnnotationValueList(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::AnnotationValueListContext* OLangParser::annotationValueList() {
  AnnotationValueListContext *_localctx = _tracker.createInstance<AnnotationValueListContext>(_ctx, getState());
  enterRule(_localctx, 298, OLangParser::RuleAnnotationValueList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1472);
    annotationValue();
    setState(1477);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == OLangParser::COMMA) {
      setState(1473);
      match(OLangParser::COMMA);
      setState(1474);
      annotationValue();
      setState(1479);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifiedNameContext ------------------------------------------------------------------

OLangParser::QualifiedNameContext::QualifiedNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> OLangParser::QualifiedNameContext::ID() {
  return getTokens(OLangParser::ID);
}

tree::TerminalNode* OLangParser::QualifiedNameContext::ID(size_t i) {
  return getToken(OLangParser::ID, i);
}

std::vector<tree::TerminalNode *> OLangParser::QualifiedNameContext::DOT() {
  return getTokens(OLangParser::DOT);
}

tree::TerminalNode* OLangParser::QualifiedNameContext::DOT(size_t i) {
  return getToken(OLangParser::DOT, i);
}


size_t OLangParser::QualifiedNameContext::getRuleIndex() const {
  return OLangParser::RuleQualifiedName;
}

void OLangParser::QualifiedNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualifiedName(this);
}

void OLangParser::QualifiedNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualifiedName(this);
}


std::any OLangParser::QualifiedNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitQualifiedName(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::QualifiedNameContext* OLangParser::qualifiedName() {
  QualifiedNameContext *_localctx = _tracker.createInstance<QualifiedNameContext>(_ctx, getState());
  enterRule(_localctx, 300, OLangParser::RuleQualifiedName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1480);
    match(OLangParser::ID);
    setState(1485);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1481);
        match(OLangParser::DOT);
        setState(1482);
        match(OLangParser::ID); 
      }
      setState(1487);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralValueContext ------------------------------------------------------------------

OLangParser::LiteralValueContext::LiteralValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::LiteralValueContext::BOOLEAN() {
  return getToken(OLangParser::BOOLEAN, 0);
}

tree::TerminalNode* OLangParser::LiteralValueContext::INT_LITERAL() {
  return getToken(OLangParser::INT_LITERAL, 0);
}

tree::TerminalNode* OLangParser::LiteralValueContext::DECIMAL_LITERAL() {
  return getToken(OLangParser::DECIMAL_LITERAL, 0);
}

tree::TerminalNode* OLangParser::LiteralValueContext::STRING() {
  return getToken(OLangParser::STRING, 0);
}

tree::TerminalNode* OLangParser::LiteralValueContext::RAW_STRING() {
  return getToken(OLangParser::RAW_STRING, 0);
}

tree::TerminalNode* OLangParser::LiteralValueContext::MULTILINE_STRING() {
  return getToken(OLangParser::MULTILINE_STRING, 0);
}

tree::TerminalNode* OLangParser::LiteralValueContext::NULL_LIT() {
  return getToken(OLangParser::NULL_LIT, 0);
}


size_t OLangParser::LiteralValueContext::getRuleIndex() const {
  return OLangParser::RuleLiteralValue;
}

void OLangParser::LiteralValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteralValue(this);
}

void OLangParser::LiteralValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteralValue(this);
}


std::any OLangParser::LiteralValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitLiteralValue(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::LiteralValueContext* OLangParser::literalValue() {
  LiteralValueContext *_localctx = _tracker.createInstance<LiteralValueContext>(_ctx, getState());
  enterRule(_localctx, 302, OLangParser::RuleLiteralValue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1488);
    _la = _input->LA(1);
    if (!((((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & 138538465099777) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionListContext ------------------------------------------------------------------

OLangParser::ExpressionListContext::ExpressionListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::ExpressionContext *> OLangParser::ExpressionListContext::expression() {
  return getRuleContexts<OLangParser::ExpressionContext>();
}

OLangParser::ExpressionContext* OLangParser::ExpressionListContext::expression(size_t i) {
  return getRuleContext<OLangParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::ExpressionListContext::COMMA() {
  return getTokens(OLangParser::COMMA);
}

tree::TerminalNode* OLangParser::ExpressionListContext::COMMA(size_t i) {
  return getToken(OLangParser::COMMA, i);
}


size_t OLangParser::ExpressionListContext::getRuleIndex() const {
  return OLangParser::RuleExpressionList;
}

void OLangParser::ExpressionListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionList(this);
}

void OLangParser::ExpressionListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionList(this);
}


std::any OLangParser::ExpressionListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitExpressionList(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ExpressionListContext* OLangParser::expressionList() {
  ExpressionListContext *_localctx = _tracker.createInstance<ExpressionListContext>(_ctx, getState());
  enterRule(_localctx, 304, OLangParser::RuleExpressionList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1490);
    expression();
    setState(1495);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == OLangParser::COMMA) {
      setState(1491);
      match(OLangParser::COMMA);
      setState(1492);
      expression();
      setState(1497);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdListContext ------------------------------------------------------------------

OLangParser::IdListContext::IdListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> OLangParser::IdListContext::ID() {
  return getTokens(OLangParser::ID);
}

tree::TerminalNode* OLangParser::IdListContext::ID(size_t i) {
  return getToken(OLangParser::ID, i);
}

std::vector<tree::TerminalNode *> OLangParser::IdListContext::COMMA() {
  return getTokens(OLangParser::COMMA);
}

tree::TerminalNode* OLangParser::IdListContext::COMMA(size_t i) {
  return getToken(OLangParser::COMMA, i);
}


size_t OLangParser::IdListContext::getRuleIndex() const {
  return OLangParser::RuleIdList;
}

void OLangParser::IdListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdList(this);
}

void OLangParser::IdListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdList(this);
}


std::any OLangParser::IdListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitIdList(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::IdListContext* OLangParser::idList() {
  IdListContext *_localctx = _tracker.createInstance<IdListContext>(_ctx, getState());
  enterRule(_localctx, 306, OLangParser::RuleIdList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1498);
    match(OLangParser::ID);
    setState(1503);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == OLangParser::COMMA) {
      setState(1499);
      match(OLangParser::COMMA);
      setState(1500);
      match(OLangParser::ID);
      setState(1505);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentContext ------------------------------------------------------------------

OLangParser::ArgumentContext::ArgumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::ArgumentContext::ID() {
  return getToken(OLangParser::ID, 0);
}

tree::TerminalNode* OLangParser::ArgumentContext::EQUALS() {
  return getToken(OLangParser::EQUALS, 0);
}

OLangParser::ExpressionContext* OLangParser::ArgumentContext::expression() {
  return getRuleContext<OLangParser::ExpressionContext>(0);
}

OLangParser::LambdaArgumentRuleContext* OLangParser::ArgumentContext::lambdaArgumentRule() {
  return getRuleContext<OLangParser::LambdaArgumentRuleContext>(0);
}


size_t OLangParser::ArgumentContext::getRuleIndex() const {
  return OLangParser::RuleArgument;
}

void OLangParser::ArgumentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgument(this);
}

void OLangParser::ArgumentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgument(this);
}


std::any OLangParser::ArgumentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitArgument(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ArgumentContext* OLangParser::argument() {
  ArgumentContext *_localctx = _tracker.createInstance<ArgumentContext>(_ctx, getState());
  enterRule(_localctx, 308, OLangParser::RuleArgument);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1511);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 125, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1506);
      match(OLangParser::ID);
      setState(1507);
      match(OLangParser::EQUALS);
      setState(1508);
      expression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1509);
      lambdaArgumentRule();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1510);
      expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LambdaArgumentRuleContext ------------------------------------------------------------------

OLangParser::LambdaArgumentRuleContext::LambdaArgumentRuleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* OLangParser::LambdaArgumentRuleContext::ID() {
  return getToken(OLangParser::ID, 0);
}

tree::TerminalNode* OLangParser::LambdaArgumentRuleContext::LAMBDA_ARROW() {
  return getToken(OLangParser::LAMBDA_ARROW, 0);
}

OLangParser::ExpressionContext* OLangParser::LambdaArgumentRuleContext::expression() {
  return getRuleContext<OLangParser::ExpressionContext>(0);
}

OLangParser::BlockExpressionContext* OLangParser::LambdaArgumentRuleContext::blockExpression() {
  return getRuleContext<OLangParser::BlockExpressionContext>(0);
}

tree::TerminalNode* OLangParser::LambdaArgumentRuleContext::LPAREN() {
  return getToken(OLangParser::LPAREN, 0);
}

OLangParser::ParameterListContext* OLangParser::LambdaArgumentRuleContext::parameterList() {
  return getRuleContext<OLangParser::ParameterListContext>(0);
}

tree::TerminalNode* OLangParser::LambdaArgumentRuleContext::RPAREN() {
  return getToken(OLangParser::RPAREN, 0);
}

OLangParser::SimpleDestructureContext* OLangParser::LambdaArgumentRuleContext::simpleDestructure() {
  return getRuleContext<OLangParser::SimpleDestructureContext>(0);
}


size_t OLangParser::LambdaArgumentRuleContext::getRuleIndex() const {
  return OLangParser::RuleLambdaArgumentRule;
}

void OLangParser::LambdaArgumentRuleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLambdaArgumentRule(this);
}

void OLangParser::LambdaArgumentRuleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLambdaArgumentRule(this);
}


std::any OLangParser::LambdaArgumentRuleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitLambdaArgumentRule(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::LambdaArgumentRuleContext* OLangParser::lambdaArgumentRule() {
  LambdaArgumentRuleContext *_localctx = _tracker.createInstance<LambdaArgumentRuleContext>(_ctx, getState());
  enterRule(_localctx, 310, OLangParser::RuleLambdaArgumentRule);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1533);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case OLangParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(1513);
        match(OLangParser::ID);
        setState(1514);
        match(OLangParser::LAMBDA_ARROW);
        setState(1517);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 126, _ctx)) {
        case 1: {
          setState(1515);
          expression();
          break;
        }

        case 2: {
          setState(1516);
          blockExpression();
          break;
        }

        default:
          break;
        }
        break;
      }

      case OLangParser::LPAREN: {
        enterOuterAlt(_localctx, 2);
        setState(1519);
        match(OLangParser::LPAREN);
        setState(1520);
        parameterList();
        setState(1521);
        match(OLangParser::RPAREN);
        setState(1522);
        match(OLangParser::LAMBDA_ARROW);
        setState(1525);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 127, _ctx)) {
        case 1: {
          setState(1523);
          expression();
          break;
        }

        case 2: {
          setState(1524);
          blockExpression();
          break;
        }

        default:
          break;
        }
        break;
      }

      case OLangParser::LBRACK:
      case OLangParser::LCURLY: {
        enterOuterAlt(_localctx, 3);
        setState(1527);
        simpleDestructure();
        setState(1528);
        match(OLangParser::LAMBDA_ARROW);
        setState(1531);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 128, _ctx)) {
        case 1: {
          setState(1529);
          expression();
          break;
        }

        case 2: {
          setState(1530);
          blockExpression();
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentListContext ------------------------------------------------------------------

OLangParser::ArgumentListContext::ArgumentListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<OLangParser::ArgumentContext *> OLangParser::ArgumentListContext::argument() {
  return getRuleContexts<OLangParser::ArgumentContext>();
}

OLangParser::ArgumentContext* OLangParser::ArgumentListContext::argument(size_t i) {
  return getRuleContext<OLangParser::ArgumentContext>(i);
}

std::vector<tree::TerminalNode *> OLangParser::ArgumentListContext::COMMA() {
  return getTokens(OLangParser::COMMA);
}

tree::TerminalNode* OLangParser::ArgumentListContext::COMMA(size_t i) {
  return getToken(OLangParser::COMMA, i);
}


size_t OLangParser::ArgumentListContext::getRuleIndex() const {
  return OLangParser::RuleArgumentList;
}

void OLangParser::ArgumentListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgumentList(this);
}

void OLangParser::ArgumentListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<OLangParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgumentList(this);
}


std::any OLangParser::ArgumentListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<OLangParserVisitor*>(visitor))
    return parserVisitor->visitArgumentList(this);
  else
    return visitor->visitChildren(this);
}

OLangParser::ArgumentListContext* OLangParser::argumentList() {
  ArgumentListContext *_localctx = _tracker.createInstance<ArgumentListContext>(_ctx, getState());
  enterRule(_localctx, 312, OLangParser::RuleArgumentList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1535);
    argument();
    setState(1540);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == OLangParser::COMMA) {
      setState(1536);
      match(OLangParser::COMMA);
      setState(1537);
      argument();
      setState(1542);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

void OLangParser::initialize() {
  std::call_once(olangparserParserOnceFlag, olangparserParserInitialize);
}
